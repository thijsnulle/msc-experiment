{"code": "# Check if directory exists\n    if not os.path.exists(directory):\n        raise FileNotFoundError(f\"Directory not found: {directory}\")\n\n    # Create backup directory if it doesn't exist\n    if not os.path.exists(backup_dir):\n        os.makedirs(backup_dir)\n\n    # Get all '.log' files in specified directory\n    log_files = glob.glob(os.path.join(directory, '*.log'))\n\n    # If no logs found, return a message\n    if not log_files:\n        return \"No logs found to backup\"\n\n    # Create tar.gz backup of all '.log' files\n    backup_file = os.path.join(backup_dir, 'logs_backup.tar.gz')\n    with subprocess.Popen(['tar', '-czvf', backup_file] + log_files) as p:\n        p.wait()\n\n    # Delete the original log files\n    for file in log_files:\n        os.remove(file)\n\n    # Return the path to the backup file\n    ", "compilation_passed": true, "time": 0.029498815536499023, "tests_passed": false, "error": "TypeError"}
{"code": "# Check if the directory exists\n    if not os.path.exists(directory):\n        raise FileNotFoundError(f\"Directory '{directory}' does not exist.\")\n    \n    # Find all '.log' files in the directory\n    log_files = glob.glob(os.path.join(directory, '*.log'))\n    \n    # If no log files are found, return a message\n    if not log_files:\n        return \"No logs found to backup\"\n    \n    # Generate a path for the backup file\n    backup_file = os.path.join(backup_dir, 'logs_backup.tar.gz')\n    \n    # Back up log files using tar.gz compression\n    # Change the directory to the backup directory to avoid absolute paths in the tar file\n    with subprocess.Popen(['cd', backup_dir], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL):\n        with subprocess.Popen(['tar', '-czvf', backup_file] + log_files, stdout=subprocess.DEVNULL, stderr=subprocess.DEV", "compilation_passed": false, "time": 0.00028705596923828125, "tests_passed": false, "error": "SyntaxError"}
{"code": "if not os.path.exists(directory):\n        raise FileNotFoundError(f\"Directory {directory} does not exist\")\n\n    # Find all '.log' files in the specified directory\n    log_files = glob.glob(os.path.join(directory, \"*.log\"))\n\n    if not log_files:\n        return \"No logs found to backup\"\n\n    # Create a tar.gz file with the log files\n    output_filename = os.path.join(backup_dir, \"logs_backup.tar.gz\")\n    subprocess.run(['tar', '-czf', output_filename] + log_files, cwd=directory)\n\n    # Delete the original log files\n    for log_file in log_files:\n        os.remove(os.path.join(directory, log_file))\n\n    return output_filename", "compilation_passed": true, "time": 0.06029200553894043, "tests_passed": true, "error": null}
{"code": "# Check if directory exists\n    if not os.path.exists(directory):\n        raise FileNotFoundError(f\"Directory '{directory}' does not exist\")\n\n    # Create backup file name\n    backup_file = os.path.join(backup_dir, \"logs_backup.tar.gz\")\n\n    # Get list of log files in the directory\n    log_files = glob.glob(os.path.join(directory, \"*.log\"))\n\n    # Check if any log files are found\n    if not log_files:\n        return \"No logs found to backup\"\n\n    # Backup log files and delete original files after backup\n    with tarfile.open(backup_file, \"w:gz\") as tar:\n        for file in log_files:\n            tar.add(file, arcname=os.path.basename(file))\n            os.remove(file)\n\n    # Return path to backup file\n    return backup_file\n    ```\n\n    In this implementation, the `task_func()` function takes two arguments: `directory` and `backup_dir`.\n    The `", "compilation_passed": false, "time": 0.00026297569274902344, "tests_passed": false, "error": "SyntaxError"}
{"code": "# Validate directory existence\n    if not os.path.exists(directory):\n        raise FileNotFoundError(f\"Directory {directory} does not exist\")\n\n    # Find all '.log' files in the specified directory\n    log_files = glob.glob(os.path.join(directory, '*.log'))\n\n    # If no log files are found, return a message\n    if not log_files:\n        return \"No logs found to backup\"\n\n    # Create a backup file named 'logs_backup.tar.gz' in the specified directory\n    backup_file = os.path.join(backup_dir, 'logs_backup.tar.gz')\n    # Use the `tar` command to create the backup file, add the log files to it, and then remove the original log files\n    subprocess.call(['tar', '-czvf', backup_file, '-C', directory, '-T', '-'] + log_files)\n    # Use the `rm` command to delete the original log files\n    subprocess.call(['rm'] + log_files)\n\n    # Return the path to the", "compilation_passed": true, "time": 1.0091171264648438, "tests_passed": false, "error": "TimeoutError"}
{"code": "# Check if the specified directory exists\n    if not os.path.exists(directory):\n        raise FileNotFoundError(f\"Directory '{directory}' not found\")\n    \n    # Create the backup file path with the specified directory and file name\n    backup_file_path = os.path.join(backup_dir, 'logs_backup.tar.gz')\n    \n    # Use glob to find all files with '.log' extension in the specified directory\n    log_files = glob.glob(f\"{directory}/*.log\")\n    \n    # Check if there are any log files\n    if not log_files:\n        return \"No logs found to backup\"\n    \n    # Create the tar.gz file by running the tar command using subprocess\n    subprocess.run([\"tar\", \"czvf\", backup_file_path, \"-C\", directory, \".\"], check=True)\n    \n    # Delete the original log files if the backup file creation was successful\n    if os.path.isfile(backup_file_path):\n        for log_file in log_files:\n            ", "compilation_passed": false, "time": 0.0007371902465820312, "tests_passed": false, "error": "IndentationError"}
{"code": "if not os.path.exists(directory):\n        raise FileNotFoundError(f\"Directory '{directory}' not found\")\n    logs = glob.glob(f\"{directory}/*.log\")\n    if logs:\n        backup_file = os.path.join(backup_dir, 'logs_backup.tar.gz')\n        subprocess.run(['tar', '-czf', backup_file, *logs], cwd=directory)\n        for log in logs:\n            os.remove(log)\n        return backup_file\n    else:\n        return 'No logs found to backup'", "compilation_passed": true, "time": 0.08566904067993164, "tests_passed": true, "error": null}
{"code": "if not os.path.isdir(directory):\n        raise FileNotFoundError(f'Directory \"{directory}\" not found.')\n\n    log_files = glob.glob(os.path.join(directory, '*.log'))\n    if not log_files:\n        return 'No logs found to backup'\n\n    tar_file = os.path.join(backup_dir, 'logs_backup.tar.gz')\n    subprocess.run(['tar', '-czf', tar_file, '-C', directory, '.'], check=True)\n\n    for log_file in log_files:\n        os.remove(log_file)\n\n    return tar_file", "compilation_passed": true, "time": 0.0598912239074707, "tests_passed": true, "error": null}
{"code": "# Check if the directory exists\n    if not os.path.exists(directory):\n        raise FileNotFoundError(f\"The specified directory '{directory}' does not exist.\")\n\n    # Find all log files in the directory\n    log_files = glob.glob(os.path.join(directory, \"*.log\"))\n\n    # If there are no log files, return a message\n    if not log_files:\n        print(\"No logs found to backup\")\n        return\n\n    # Create the backup directory if it doesn't exist\n    os.makedirs(backup_dir, exist_ok=True)\n\n    # Create the backup file name\n    backup_file = os.path.join(backup_dir, \"logs_backup.tar.gz\")\n\n    # Use tar to create the backup file and delete the original files\n    try:\n        subprocess.run([\"tar\", \"-czvf\", backup_file, \"-C\", directory, \".\"], check=True)\n        for file in log_files:\n            os.remove(file)\n    ", "compilation_passed": false, "time": 0.0002849102020263672, "tests_passed": false, "error": "SyntaxError"}
{"code": "# Check if the directory exists\n    if not os.path.exists(directory):\n        raise FileNotFoundError(f\"Directory not found: {directory}\")\n\n    # Set the path for the backup file\n    backup_file = os.path.join(backup_dir, 'logs_backup.tar.gz')\n\n    # Find all log files in the directory\n    log_files = glob.glob(f'{directory}/*.log')\n\n    # Backup the log files and remove the original files if there are any log files\n    if log_files:\n        try:\n            # Create the backup file\n            subprocess.run(['tar', '-czf', backup_file, '-C', directory, '.'], check=True)\n\n            # Remove the original log files\n            for log_file in log_files:\n                os.remove(log_file)\n\n        except subprocess.CalledProcessError as e:\n            print(f\"Error backing up log files: {e}\")\n\n        return backup_file\n    else:\n        # Return a message if no log files are found\n        return \"", "compilation_passed": false, "time": 9.298324584960938e-05, "tests_passed": false, "error": "SyntaxError"}
{"code": "# Check if the directory exists\n    if not os.path.exists(directory):\n        raise FileNotFoundError(f\"Directory '{directory}' does not exist\")\n    # Create a list of all log files in the specified directory\n    log_files = glob.glob(os.path.join(directory, '*.log'))\n    # Check if there are any log files in the specified directory\n    if not log_files:\n        return 'No logs found to backup'\n    # Create a backup file with a name 'logs_backup.tar.gz'\n    backup_file = os.path.join(backup_dir, 'logs_backup.tar.gz')\n    # Use subprocess to compress the log files and delete the original files after backup\n    subprocess.run(['tar', '-czf', backup_file, '-C', directory, '--remove-files', *log_files], check=True)\n    # Return the path to the backup file\n    return backup_file\n    # This function requires the following packages:\n    # - subprocess\n    # - glob\n    # - os<|endof", "compilation_passed": true, "time": 0.02778768539428711, "tests_passed": false, "error": "subprocess.CalledProcessError"}
{"code": "# Validate directory\n    if not os.path.exists(directory):\n        raise FileNotFoundError(f\"Directory {directory} does not exist.\")\n    # Find all '.log' files in the directory\n    log_files = glob.glob(os.path.join(directory, '*.log'))\n    # Create backup file if logs are found\n    if log_files:\n        # Create backup directory if it doesn't exist\n        os.makedirs(backup_dir, exist_ok=True)\n        # Backup to tar.gz file and delete original files after backup\n        tar_file = os.path.join(backup_dir, 'logs_backup.tar.gz')\n        subprocess.run(['tar', '-czf', tar_file] + log_files + ['--remove-files'], check=True)\n        # Return path to backup file\n        return tar_file\n    # Return message if no logs are found\n    else:\n        return 'No logs found to backup'", "compilation_passed": true, "time": 0.029294729232788086, "tests_passed": false, "error": "subprocess.CalledProcessError"}
{"code": "# Check if the directory exists\n    if not os.path.exists(directory):\n        raise FileNotFoundError(f\"Directory not found: {directory}\")\n    # List all '.log' files in the directory and its subdirectories\n    log_files = glob.glob(os.path.join(directory, '**/*.log'), recursive=True)\n    # Check if there are any log files to be backed up\n    if log_files:\n        # Create the backup file\n        backup_file = os.path.join(backup_dir, 'logs_backup.tar.gz')\n        # Add the log files to the backup file\n        with subprocess.Popen([\"tar\", \"-czvf\", backup_file, \"--files-from\", \"/dev/null\"], stdin=subprocess.PIPE) as process:\n            for log_file in log_files:\n                process.stdin.write(os.path.relpath(log_file, directory).encode())\n                process.stdin.write(os.linesep.encode())\n            # Close the standard input", "compilation_passed": true, "time": 0.02720808982849121, "tests_passed": false, "error": "TypeError"}
{"code": "# Validate directory\n    if not os.path.isdir(directory):\n        raise FileNotFoundError(\"Directory does not exist.\")\n\n    # Set backup directory\n    if backup_dir is None or not os.path.isdir(backup_dir):\n        backup_dir = '/path/to/backup'\n\n    # Search for '.log' files in the directory\n    logs = glob.glob(os.path.join(directory, '*.log'))\n\n    # Backup logs\n    if len(logs) == 0:\n        return \"No logs found to backup.\"\n\n    # Create a tar.gz file with the '.log' files\n    tarfile = os.path.join(backup_dir, 'logs_backup.tar.gz')\n    with subprocess.Popen(['tar', '-czf', tarfile] + logs, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as proc:\n        stdout, stderr = proc.communicate()\n\n    # Check if backup was successful\n    if proc.returncode != 0", "compilation_passed": false, "time": 0.0002579689025878906, "tests_passed": false, "error": "SyntaxError"}
{"code": "# Check if the specified directory exists\n    if not os.path.isdir(directory):\n        raise FileNotFoundError(f\"Directory '{directory}' does not exist.\")\n\n    # Get all log files in the specified directory\n    logs = glob.glob(f\"{directory}/*.log\")\n\n    # Check if there are any logs to backup\n    if not logs:\n        return \"No logs found to backup\"\n\n    # Backup the logs to a tar.gz file in the specified backup directory\n    backup_path = os.path.join(backup_dir, \"logs_backup.tar.gz\")\n    subprocess.run([\"tar\", \"-czf\", backup_path, \"--remove-files\", \"-C\", directory, os.path.basename(directory)], check=True)\n\n    return backup_path", "compilation_passed": true, "time": 0.026964187622070312, "tests_passed": false, "error": "subprocess.CalledProcessError"}
{"code": "# Check that the directory exists\n    if not os.path.exists(directory):\n        raise FileNotFoundError(f\"The directory '{directory}' does not exist\")\n\n    # Create a list of all the log files in the directory\n    log_files = glob.glob(f\"{directory}/*.log\")\n\n    # Check if there are any log files in the directory\n    if not log_files:\n        print(\"No logs found to backup\")\n        return \"No logs found to backup\"\n\n    # Create a tar.gz file with the log files and delete the original files\n    try:\n        with subprocess.Popen([\"tar\", \"-czf\", os.path.join(backup_dir, \"logs_backup.tar.gz\"), *log_files], cwd=directory) as process:\n            # Wait for the process to finish and check for errors\n            if process.wait() != 0:\n                print(f\"Error creating backup file\")\n            else:\n                # Delete the original log files\n                for file in log_files:\n                    ", "compilation_passed": false, "time": 0.00025391578674316406, "tests_passed": false, "error": "IndentationError"}
{"code": "# Check if the specified directory exists\n    if not os.path.exists(directory):\n        raise FileNotFoundError(f\"Directory {directory} does not exist\")\n\n    # Use glob to find all '.log' files in the directory\n    log_files = glob.glob(os.path.join(directory, \"*.log\"))\n\n    # If no log files are found, print a message and exit\n    if not log_files:\n        return \"No logs found to backup\"\n\n    # Create a backup file and store it in the backup directory\n    backup_file = os.path.join(backup_dir, \"logs_backup.tar.gz\")\n\n    # Use subprocess.run to run the tar command\n    subprocess.run([\"tar\", \"-czvf\", backup_file] + log_files)\n\n    # Delete the original log files\n    for log_file in log_files:\n        os.remove(log_file)\n\n    # Return the path to the backup file\n    return backup_file", "compilation_passed": true, "time": 0.059609174728393555, "tests_passed": true, "error": null}
{"code": "if not os.path.exists(directory):\n        raise FileNotFoundError(f\"Directory not found: {directory}\")\n\n    files = glob.glob(os.path.join(directory, \"*.log\"))\n    if not files:\n        return \"No logs found to backup\"\n\n    # Create a tarball of log files\n    subprocess.run([\"tar\", \"czf\", \"logs_backup.tar.gz\"] + files)\n\n    # Move the tarball to the backup directory and remove the original files\n    os.replace(\"logs_backup.tar.gz\", os.path.join(backup_dir, \"logs_backup.tar.gz\"))\n    for file in files:\n        os.remove(file)\n\n    return os.path.join(backup_dir, \"logs_backup.tar.gz\")\n    \"\"\"\n    In this example, the function first checks if the specified directory exists. If not, it raises a\n    FileNotFoundError with a message indicating the directory not found.\n\n    The glob module is used to find all '.log' files in", "compilation_passed": false, "time": 0.0001552104949951172, "tests_passed": false, "error": "SyntaxError"}
{"code": "if not os.path.isdir(directory):\n        raise FileNotFoundError(f\"Directory {directory} does not exist\")\n\n    files_to_backup = glob.glob(f\"{directory}/*.log\")\n    if not files_to_backup:\n        return \"No logs found to backup\"\n\n    # create backup file\n    backup_file = os.path.join(backup_dir, \"logs_backup.tar.gz\")\n    subprocess.run([\"tar\", \"-czvf\", backup_file, \"--delete\"] + files_to_backup, cwd=directory)\n\n    return backup_file", "compilation_passed": true, "time": 0.02721881866455078, "tests_passed": true, "error": null}
{"code": "# Check if the directory exists\n    if not os.path.exists(directory):\n        raise FileNotFoundError(f\"Directory '{directory}' does not exist.\")\n\n    # Find all '.log' files in the specified directory\n    log_files = glob.glob(os.path.join(directory, \"*.log\"))\n\n    # If no logs are found, return a message\n    if not log_files:\n        return \"No logs found to backup\"\n\n    # Create a backup file\n    backup_file = os.path.join(backup_dir, \"logs_backup.tar.gz\")\n\n    # Backup all '.log' files and remove the original files\n    subprocess.run([\"tar\", \"-czf\", backup_file] + log_files)\n\n    # Remove the original log files\n    for log_file in log_files:\n        os.remove(log_file)\n\n    # Return the path to the backup file\n    return backup_file", "compilation_passed": true, "time": 0.0640099048614502, "tests_passed": true, "error": null}
{"code": "# Check if the directory exists\n    if not os.path.exists(directory):\n        raise FileNotFoundError(\"Directory does not exist\")\n    # Create the list of log files\n    log_files = glob.glob(os.path.join(directory, '*.log'))\n    # If there are no log files, print a message and exit the function\n    if not log_files:\n        return \"No logs found to backup\"\n    # Create the backup file\n    backup_file = os.path.join(backup_dir, 'logs_backup.tar.gz')\n    # Use tar command to create the backup file\n    try:\n        subprocess.run(['tar', '-czf', backup_file, '-C', directory, '.'], check=True)\n    except subprocess.CalledProcessError:\n        print(f\"Failed to create the backup file {backup_file}\")\n    # Delete the original files\n    try:\n        for file in log_files:\n            os.remove(file)\n    except OSError:\n        print(f\"Failed to delete the file {file}\"", "compilation_passed": false, "time": 0.00034499168395996094, "tests_passed": false, "error": "SyntaxError"}
{"code": "# Check if the directory exists\n    if not os.path.exists(directory):\n        raise FileNotFoundError(f\"The specified directory '{directory}' does not exist.\")\n    \n    # List all log files in the specified directory\n    logs = glob.glob(f\"{directory}/**/*.log\", recursive=True)\n    \n    if not logs:\n        return \"No logs found to backup\"\n    \n    # Create the backup file\n    backup_file = os.path.join(backup_dir, \"logs_backup.tar.gz\")\n    \n    # Use tar to create the backup\n    subprocess.run([\"tar\", \"-czvf\", backup_file] + logs)\n    \n    # Delete the original files after backup\n    for log in logs:\n        os.remove(log)\n    \n    return backup_file\n    ```\n    This function takes a `directory` argument that specifies the path to the directory containing the log files that need to be backed up. It also takes an optional `backup_dir` argument that specifies the path to the directory where the backup file will be saved.", "compilation_passed": false, "time": 0.00017213821411132812, "tests_passed": false, "error": "SyntaxError"}
{"code": "# Check if the directory exists\n    if not os.path.exists(directory):\n        raise FileNotFoundError(f\"Directory {directory} not found\")\n    # Find all '.log' files in the specified directory\n    log_files = glob.glob(os.path.join(directory, '*.log'))\n    # If no log files are found, return a message\n    if not log_files:\n        return \"No logs found to backup\"\n    # Create the tar.gz backup file\n    backup_file = os.path.join(backup_dir, 'logs_backup.tar.gz')\n    subprocess.call(['tar', '-czf', backup_file] + log_files)\n    # Delete the original log files\n    for log_file in log_files:\n        os.remove(log_file)\n    # Return the path to the backup file\n    return backup_file", "compilation_passed": true, "time": 0.06180000305175781, "tests_passed": true, "error": null}
{"code": "logs = glob.glob(f\"{directory}/**/*.log\", recursive=True)\n    if logs:\n        with open(os.devnull, 'w') as devnull:\n            subprocess.run(['tar', '-czf', 'logs_backup.tar.gz', *logs], cwd=backup_dir, stdout=devnull, stderr=devnull)\n            for log in logs:\n                os.remove(log)\n        return f\"{backup_dir}/logs_backup.tar.gz\"\n    else:\n        return \"No logs found to backup\"", "compilation_passed": true, "time": 0.03223299980163574, "tests_passed": true, "error": null}
{"code": "# Check if the specified directory exists\n    if not os.path.isdir(directory):\n        raise FileNotFoundError(f\"Directory {directory} does not exist.\")\n\n    # Get the path to the directory with the log files\n    log_path = os.path.join(directory, '*.log')\n\n    # Find all log files in the specified directory\n    logs = glob.glob(log_path)\n\n    # Check if any logs are found\n    if not logs:\n        return \"No logs found to backup\"\n\n    # Create the path for the backup file\n    backup_file_path = os.path.join(backup_dir, 'logs_backup.tar.gz')\n\n    # Backup the log files\n    subprocess.run(['tar', '-czvf', backup_file_path] + logs)\n\n    # Delete the original log files\n    for log in logs:\n        os.remove(log)\n\n    return backup_file_path", "compilation_passed": true, "time": 0.06397509574890137, "tests_passed": true, "error": null}
{"code": "if not os.path.exists(directory):\n        raise FileNotFoundError(f\"Directory '{directory}' not found.\")\n\n    log_files = glob.glob(os.path.join(directory, '*.log'))\n    if not log_files:\n        return \"No logs found to backup\"\n\n    os.chdir(backup_dir)  # Change the current directory to the backup directory\n    subprocess.run(['tar', '-czf', 'logs_backup.tar.gz'] + log_files)\n\n    # Delete the original log files\n    for file in log_files:\n        os.remove(file)\n\n    return os.path.join(backup_dir, 'logs_backup.tar.gz')", "compilation_passed": true, "time": 0.06107187271118164, "tests_passed": true, "error": null}
{"code": "# Check if the directory exists\n    if not os.path.exists(directory):\n        raise FileNotFoundError(f\"The directory {directory} does not exist\")\n\n    # Create a list of all the '.log' files in the specified directory\n    log_files = glob.glob(os.path.join(directory, \"*.log\"))\n\n    # If there are no log files, return a message\n    if not log_files:\n        return \"No logs found to backup\"\n\n    # Set the backup file path and name\n    backup_file_path = os.path.join(backup_dir, 'logs_backup.tar.gz')\n\n    # Create a tar.gz backup file containing the log files\n    try:\n        subprocess.run([\"tar\", \"-czf\", backup_file_path, *log_files], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n    except Exception as e:\n        print(f\"Error backing up log files: {str(e)}\")\n        return \"Error backing up logs\"\n\n    # Delete", "compilation_passed": true, "time": 0.02956104278564453, "tests_passed": false, "error": "TypeError"}
{"code": "# Check if the directory exists\n    if not os.path.isdir(directory):\n        raise FileNotFoundError(\"Directory does not exist: {}\".format(directory))\n\n    # Search for all '.log' files in the specified directory\n    log_files = glob.glob(os.path.join(directory, '*.log'))\n\n    # If no logs are found, return a message\n    if not log_files:\n        return \"No logs found to backup\"\n\n    # Set the name of the backup file\n    backup_file = os.path.join(backup_dir, 'logs_backup.tar.gz')\n\n    # Create the backup file with all found '.log' files\n    subprocess.run(['tar', '-czf', backup_file, '-C', directory] + log_files)\n\n    # Remove the original log files\n    for log_file in log_files:\n        os.remove(log_file)\n\n    # Return the path to the backup file\n    return backup_file", "compilation_passed": true, "time": 0.0616459846496582, "tests_passed": true, "error": null}
{"code": "# Check if the directory exists\n    if not os.path.isdir(directory):\n        raise FileNotFoundError(f\"Directory '{directory}' does not exist\")\n\n    # Find all '.log' files in the directory\n    logs = glob.glob(os.path.join(directory, '*.log'))\n\n    # If no '.log' files are found, return a message\n    if not logs:\n        return \"No logs found to backup\"\n\n    # Define the backup file name and path\n    backup_file = os.path.join(backup_dir, 'logs_backup.tar.gz')\n\n    # Create the backup file\n    subprocess.run(['tar', '-czf', backup_file, '-C', directory] + logs, check=True)\n\n    # Delete the original '.log' files\n    for log in logs:\n        os.remove(log)\n\n    return backup_file", "compilation_passed": true, "time": 0.06049513816833496, "tests_passed": true, "error": null}
{"code": "if not os.path.exists(directory):\n        raise FileNotFoundError(f'Directory {directory} does not exist')\n\n    # Create a list of log files in the directory\n    log_files = glob.glob(os.path.join(directory, '*.log'))\n\n    if not log_files:\n        return 'No logs found to backup'\n\n    # Create a tar.gz archive of the log files\n    backup_file = os.path.join(backup_dir, 'logs_backup.tar.gz')\n    subprocess.run(['tar', '-czf', backup_file, '-C', directory] + log_files)\n\n    # Remove the log files\n    for log_file in log_files:\n        os.remove(log_file)\n\n    return backup_file", "compilation_passed": true, "time": 0.06035804748535156, "tests_passed": true, "error": null}
