{"code": "# Set the random seed for reproducibility\n    np.random.seed(seed)\n\n    # Generate samples from the normal distribution with the given mean and standard deviation\n    samples = np.random.normal(mu, sigma, num_samples)\n\n    # Create a histogram of the samples\n    ax = plt.hist(samples, bins=num_bins, density=True)\n\n    # Get the bin edges for the histogram\n    bins = ax[1]\n\n    # Calculate the center of each bin\n    bin_centers = (bins[1:] + bins[:-1]) / 2\n\n    # Fit a second order polynomial to the data using OLS regression\n    x = np.column_stack((np.ones_like(bin_centers), bin_centers))\n    y = np.exp(-(bin_centers - mu) ** 2 / (2 * sigma ** 2)) / (sigma * np.sqrt(2 * np.pi))\n    model = ols('y ~ poly(x1, 2)', {'x1': bin_centers, 'y': y}).fit()\n\n", "compilation_passed": true, "time": 0.010865926742553711, "tests_passed": false, "error": "        ^^^^^^^^^^^"}
{"code": "# Set random seed for reproducibility\n    np.random.seed(seed)\n    # Generate random samples from a normal distribution with the given mean and standard deviation\n    samples = np.random.normal(mu, sigma, size=num_samples)\n    # Create a histogram of the samples with the given number of bins\n    counts, bins = np.histogram(samples, bins=num_bins)\n    # Create a grid of x values for the PDF and OLS lines\n    x = np.linspace(min(samples), max(samples), num_samples)\n    # Create a line plot of the PDF of the normal distribution on the histogram\n    pdf = norm.pdf(x, mu, sigma)\n    ax = plt.plot(x, pdf, 'r-', label='PDF')\n    # Create a line plot of the OLS fit to the histogram data\n    ols_results = ols('counts ~ x + np.square(x)', {'counts':counts, 'x':x}).fit()\n    ols_fit = ols_results.fittedvalues\n    ax = plt.plot(x, ols_fit,", "compilation_passed": false, "time": 0.0002429485321044922, "tests_passed": false, "error": "SyntaxError"}
{"code": "np.random.seed(seed)\n    samples = np.random.normal(mu, sigma, num_samples)\n\n    bin_edges = np.linspace(samples.min(), samples.max(), num_bins+1)\n    bin_counts = np.histogram(samples, bins=bin_edges)[0]\n\n    bin_centers = (bin_edges[:-1] + bin_edges[1:])/2\n    ols_fit = np.polyfit(bin_centers, bin_counts, deg=2)\n\n    ax = plt.subplot()\n    ax.hist(samples, bins=bin_edges, alpha=0.5, edgecolor='black')\n\n    bin_centers = np.linspace(bin_edges[0], bin_edges[-1], 1000)\n    bin_counts = np.polyval(ols_fit, bin_centers)\n    ax.plot(bin_centers, bin_counts, color='red')\n\n    pdf_values = np.exp(-(bin_centers-mu)**2/2/sigma**", "compilation_passed": false, "time": 0.0002789497375488281, "tests_passed": false, "error": "SyntaxError"}
{"code": "np.random.seed(seed)\n    x = np.random.normal(mu, sigma, num_samples)\n    ax = plt.hist(x, bins=num_bins, alpha=0.5)\n    bins = np.linspace(min(x), max(x), num_bins)\n    x_binned = (x - mu) / sigma\n    y_binned = np.digitize(x_binned, bins=bins)\n    y_binned = (y_binned - 1) / (num_bins - 1) * 2 - 1\n    y_binned_mean = []\n    for i in range(num_bins):\n        y_binned_mean.append(np.mean(x[y_binned == i]))\n    model = ols('y_binned_mean ~ x_binned + I(x_binned**2)', {'x_binned': x_binned, 'y_binned_mean': y_binned_mean}).fit()\n    plt.plot(x_binned, model.fittedvalues,", "compilation_passed": false, "time": 0.0002491474151611328, "tests_passed": false, "error": "SyntaxError"}
{"code": "# Set the random seed for reproducibility.\n    np.random.seed(seed)\n\n    # Create a normal distribution with the given mean and standard deviation, and generate samples from it.\n    x = mu + sigma * np.random.randn(num_samples)\n\n    # Fit the normal distribution with the generated samples.\n    fit = stats.norm.fit(x)\n\n    # Create a histogram of the samples, and bin them into 30 bins.\n    _, bin_edges = np.histogram(x, num_bins)\n\n    # Create the bin centers for the histogram.\n    bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2\n\n    # Calculate the PDF of the normal distribution for the bin centers, using the fitted parameters.\n    pdf = stats.norm.pdf(bin_centers, loc=fit[0], scale=fit[1])\n\n    # Create the Axes object for the plot.\n    fig, ax = plt.subplots()\n\n    # Plot the histogram of the samples, using the bin centers and the PDF as x", "compilation_passed": true, "time": 0.0011382102966308594, "tests_passed": false, "error": "NameError"}
{"code": "# set the random seed for reproducibility\n    np.random.seed(seed)\n\n    # generate random normal samples\n    samples = np.random.normal(mu, sigma, size=num_samples)\n\n    # calculate the histogram of the samples\n    counts, bins = np.histogram(samples, bins=num_bins, density=True)\n\n    # calculate the x values for the probability density function\n    bin_width = bins[1] - bins[0]\n    x = np.linspace(bins[0], bins[-1], 1000)\n\n    # calculate the probability density function\n    pdf = (1 / (sigma * np.sqrt(2 * np.pi))) * np.exp(-(x - mu) ** 2 / (2 * sigma ** 2))\n\n    # fit a second order polynomial to the histogram counts using OLS regression\n    model = ols('counts ~ x + I(x**2)', {'x': (bins[:-1] + bins[1:]) / 2, 'counts': counts}).fit()\n    ols_fit = model.fittedvalues", "compilation_passed": true, "time": 0.0020859241485595703, "tests_passed": true, "error": null}
{"code": "np.random.seed(seed) # Set the seed for reproducibility\n    dist = np.random.normal(mu, sigma, num_samples) # Generate samples from the normal distribution\n\n    hist, edges = np.histogram(dist, bins=num_bins, density=True) # Compute the histogram and bin edges\n    x = (edges[1:] + edges[:-1]) / 2 # Compute the bin centers\n    y = hist # Get the bin counts\n\n    # Fit the model with ordinary least squares (OLS) regression\n    model = ols(\"y ~ x + np.square(x)\").fit(data=pd.DataFrame({'x': x, 'y': y}))\n\n    # Get the fitted values for the model\n    y_predicted = model.fittedvalues\n\n    # Create the figure and axes with the histogram\n    fig, ax = plt.subplots()\n    ax.hist(dist, bins=num_bins, density=True)\n\n    # Compute the PDF of the normal distribution\n    pdf = (1 / (sigma * np.sqrt(2 * np.pi))) * np.exp", "compilation_passed": true, "time": 0.0011527538299560547, "tests_passed": false, "error": "TypeError"}
{"code": "np.random.seed(seed)\n    data = np.random.normal(mu, sigma, size=num_samples)\n\n    bins = np.linspace(data.min(), data.max(), num_bins)\n    bin_counts = np.histogram(data, bins=bins)[0]\n    bin_edges = bins\n    bin_width = bin_edges[1] - bin_edges[0]\n    bin_mids = bin_edges[:-1] + 0.5 * bin_width\n\n    ax = plt.hist(data, bins=bins, density=True, alpha=0.5, label='Histogram')\n    pdf = np.exp(-(bin_mids - mu) ** 2 / (2 * sigma ** 2)) / (sigma * np.sqrt(2 * np.pi))\n\n    plt.plot(bin_mids, pdf, color='red', label='PDF')\n\n    model = ols(\"bin_counts ~ bin_mids + I(bin_mids**2)\", {\"bin_counts\": bin_counts, \"bin", "compilation_passed": false, "time": 0.00011587142944335938, "tests_passed": false, "error": "SyntaxError"}
{"code": "# Set the random seed for reproducibility\n    np.random.seed(seed)\n\n    # Generate samples from a normal distribution with the given mean and standard deviation\n    samples = np.random.normal(mu, sigma, num_samples)\n\n    # Create a histogram of the samples with the given number of bins\n    ax = plt.hist(samples, bins=num_bins, density=True)\n\n    # Add a line for the PDF of a normal distribution with the given mean and standard deviation\n    x = np.linspace(min(samples), max(samples), num_samples)\n    y = (1 / (sigma * np.sqrt(2 * np.pi))) * np.exp(-((x - mu)**2) / (2 * sigma**2))\n    ax[0].plot(x, y, 'r')\n\n    # Add a second order polynomial function on the histogram fitted bin-wise using OLS regression\n    num_bins = len(ax[1])\n    bin_width = (max(samples) - min(samples)) / num_bins\n    bin_centers = np.linspace(min", "compilation_passed": false, "time": 0.00023484230041503906, "tests_passed": false, "error": "SyntaxError"}
{"code": "np.random.seed(seed)\n\n    data = np.random.normal(mu, sigma, size=num_samples)\n    ax = plt.hist(data, bins=num_bins, density=True)\n\n    x = np.linspace(min(data), max(data), num_samples)\n    plt.plot(x, scipy.stats.norm.pdf(x, mu, sigma), color='red')\n\n    # Fit second-order polynomial regression\n    x_binned = np.histogram(data, bins=num_bins)[0]\n    x_binned = x_binned / sum(x_binned)\n\n    # Convert x_binned to a pandas dataframe with a column name\n    x_binned = pd.DataFrame(x_binned, columns=['x_binned'])\n\n    # Add a second column for the squared values of x_binned\n    x_binned['x_binned_squared'] = x_binned['x_binned']**2\n\n    # Create the model formula using the column names\n    formula = 'y ~", "compilation_passed": false, "time": 9.393692016601562e-05, "tests_passed": false, "error": "SyntaxError"}
{"code": "np.random.seed(seed)\n    samples = np.random.normal(loc=mu, scale=sigma, size=num_samples)\n\n    # Plot the histogram with the density curve\n    ax = plt.subplot(211)\n    ax.hist(samples, bins=num_bins, density=True, edgecolor='black', color='lightgreen')\n    ax.set_xlabel('Value')\n    ax.set_ylabel('Density')\n    ax.set_title('Histogram of a Normal Distribution')\n\n    # Overlay the probability density function (PDF) of the normal distribution\n    x = np.linspace(min(samples), max(samples), 1000)\n    y = (1 / (sigma * np.sqrt(2 * np.pi))) * np.exp(-((x - mu) ** 2) / (2 * sigma ** 2))\n    ax.plot(x, y, label='PDF', color='red')\n\n    # Overlay the second order polynomial function fitted by OLS regression on the histogram\n    ax2 = plt.subplot(2", "compilation_passed": false, "time": 0.00023412704467773438, "tests_passed": false, "error": "SyntaxError"}
{"code": "np.random.seed(seed)\n    data = np.random.normal(mu, sigma, size=num_samples)\n    bin_edges = np.histogram_bin_edges(data, bins=num_bins)\n    midpoints = 0.5 * (bin_edges[:-1] + bin_edges[1:])\n    bin_width = bin_edges[1] - bin_edges[0]\n    bins = [x * bin_width for x in midpoints]\n\n    # Fit a second-order polynomial to the histogram\n    x = midpoints.reshape(-1, 1)\n    y = np.histogram(data, bins=num_bins)[0]\n    model = ols('y ~ x + x**2')\n    results = model.fit(x, y)\n    y_hat = results.predict(x)\n    plt.plot(midpoints, y_hat, color='green')\n\n    # Plot the histogram\n    plt.hist(data, bins=num_bins, density=True)\n\n    # Add the probability density function (PDF) of the normal distribution", "compilation_passed": true, "time": 0.0011510848999023438, "tests_passed": false, "error": "TypeError"}
{"code": "np.random.seed(seed)\n    # Create the data\n    data = np.random.normal(mu, sigma, size=num_samples)\n    # Plot the histogram\n    plt.hist(data, bins=num_bins, density=True)\n    # Get the bins\n    bins = plt.xlim()\n    # Create the bin centers\n    bin_centers = np.linspace(bins[0], bins[1], num_bins + 1)\n    # Create the bin centers\n    bin_centers = np.linspace(bins[0], bins[1], num_bins + 1)\n    # Create the bin centers\n    bin_centers = np.linspace(bins[0], bins[1], num_bins + 1)\n    # Create the bin centers\n    bin_centers = np.linspace(bins[0], bins[1], num_bins + 1)\n    # Create the bin centers\n    bin_centers = np.linspace(bins[0], bins[1], num_bins + 1)\n    #", "compilation_passed": true, "time": 0.007046222686767578, "tests_passed": true, "error": null}
{"code": "np.random.seed(seed)\n    num_bins = int(num_bins)\n    num_samples = int(num_samples)\n\n    # Generate random samples from a normal distribution\n    samples = np.random.normal(mu, sigma, num_samples)\n\n    # Create histogram\n    fig, ax = plt.subplots(figsize=(10, 6))\n    ax.hist(samples, bins=num_bins, edgecolor='black', linewidth=1.2)\n\n    # Get bin edges\n    bin_edges = ax.get_children()[0].get_edgecolor()\n\n    # Get bin edges for the histogram\n    bin_edges = ax.get_children()[0].get_edgecolor()\n    bin_edges = np.concatenate((bin_edges[:, :1], bin_edges[:, 0:3:2]))\n\n    # Add PDF of the normal distribution on the histogram\n    x = np.linspace(min(samples), max(samples), num_bins * 10)\n    y = scipy.stats.norm.pdf(", "compilation_passed": false, "time": 0.0002601146697998047, "tests_passed": false, "error": "SyntaxError"}
{"code": "np.random.seed(seed)\n    samples = np.random.normal(mu, sigma, num_samples)\n\n    ax = plt.hist(samples, bins=num_bins, density=True, edgecolor='black', alpha=0.5, label=\"Histogram\")\n    bin_centers = (ax[1][1:] + ax[1][:-1]) / 2\n    bin_counts = ax[0]\n    plt.plot(bin_centers, bin_counts, label=\"Histogram\")\n\n    # Add the probability density function\n    x_range = np.linspace(mu - 3 * sigma, mu + 3 * sigma, num_bins * 10)\n    y_range = 1 / (np.sqrt(2 * np.pi) * sigma) * np.exp(-(x_range - mu)**2 / (2 * sigma**2))\n    plt.plot(x_range, y_range, label=\"PDF\", color=\"red\")\n\n    # Add the OLS regression line\n    model = ols(f\"", "compilation_passed": false, "time": 0.00010895729064941406, "tests_passed": false, "error": "SyntaxError"}
{"code": "# Set the random seed for reproducibility\n    np.random.seed(seed)\n\n    # Generate a random normal distribution with the given mean, standard deviation, and number of samples\n    samples = np.random.normal(mu, sigma, num_samples)\n\n    # Create a histogram with the generated samples\n    fig, ax = plt.subplots()\n    ax.hist(samples, bins=num_bins, density=True)\n\n    # Add a line showing the normal distribution PDF with the given mean and standard deviation\n    x = np.linspace(min(samples), max(samples), 100)\n    ax.plot(x, scipy.stats.norm.pdf(x, mu, sigma), label='PDF', color='r')\n\n    # Fit a second order polynomial function on the histogram bin-wise using OLS regression\n    bin_centers = np.array([(ax.patches[i].get_bbox().x0+ax.patches[i].get_bbox().x1)/2 for i in range(num_bins)])\n    bin_heights =", "compilation_passed": false, "time": 0.0002129077911376953, "tests_passed": false, "error": "SyntaxError"}
{"code": "# Set the random seed for reproducibility\n    np.random.seed(seed)\n\n    # Generate samples from a normal distribution with the given mean and standard deviation\n    x = np.random.normal(mu, sigma, size=num_samples)\n\n    # Fit a histogram to the samples with the given number of bins\n    counts, bins = np.histogram(x, bins=num_bins)\n\n    # Calculate the bin centers and widths for plotting\n    bin_centers = (bins[1:] + bins[:-1]) / 2\n    bin_widths = bins[1:] - bins[:-1]\n\n    # Calculate the PDF of the normal distribution for the histogram bin centers\n    pdf = np.exp(-((bin_centers - mu) ** 2) / (2 * sigma ** 2)) / (sigma * np.sqrt(2 * np.pi))\n\n    # Create the figure and plot the histogram\n    fig, ax = plt.subplots()\n    ax.bar(bin_centers, counts, width=bin_widths, alpha=0.5, label='Histogram')\n\n", "compilation_passed": true, "time": 0.02228403091430664, "tests_passed": true, "error": null}
{"code": "np.random.seed(seed)\n    samples = np.random.normal(mu, sigma, num_samples)\n\n    fig, ax = plt.subplots()\n    bins = np.linspace(samples.min(), samples.max(), num_bins)\n\n    # Plot histogram\n    hist, bins, patches = ax.hist(samples, bins=bins, density=True, edgecolor='black')\n\n    # Add PDF overlaid\n    x = np.linspace(bins.min(), bins.max(), num_samples)\n    pdf = np.exp(-(x - mu) ** 2 / (2 * sigma ** 2)) / (sigma * np.sqrt(2 * np.pi))\n    ax.plot(x, pdf, 'r')\n\n    # Add OLS overlaid\n    y_hat = ols('hist ~ bins').fit(bins, hist).fittedvalues\n    ax.plot(bins, y_hat, 'g')\n\n    return ax", "compilation_passed": true, "time": 0.022379159927368164, "tests_passed": false, "error": "TypeError"}
{"code": "np.random.seed(seed)\n    data = np.random.normal(mu, sigma, size=num_samples)\n\n    # Create a histogram of the data\n    plt.hist(data, bins=num_bins, edgecolor='black', alpha=0.6)\n    plt.xlabel('Data')\n    plt.ylabel('Count')\n    plt.title('Histogram of Normal Distribution')\n\n    # Create a line plot of the PDF\n    x = np.linspace(min(data), max(data), 100)\n    plt.plot(x, scipy.stats.norm.pdf(x, mu, sigma), color='red')\n\n    # Fit a second order polynomial to the binned data\n    num_bins = 30\n    bin_edges = np.histogram_bin_edges(data, bins=num_bins)\n    bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2\n    bin_counts = np.histogram(data, bins=bin_edges)[0]\n    bin_counts = bin", "compilation_passed": true, "time": 0.006974935531616211, "tests_passed": false, "error": "NameError"}
{"code": "# Set the random seed for reproducibility\n    np.random.seed(seed)\n    # Generate random samples from a normal distribution with the given mean and standard deviation\n    samples = np.random.normal(mu, sigma, size=num_samples)\n    # Create a histogram of the samples with the given number of bins\n    ax = plt.hist(samples, bins=num_bins, density=True, edgecolor=\"black\", color=\"yellow\")\n\n    # Define a function that returns the probability density function (PDF) of a normal distribution\n    # with the given mean and standard deviation\n    def normal_pdf(x, mean, std):\n        return (1 / (std * np.sqrt(2 * np.pi))) * np.exp(-(x - mean)**2 / (2 * std**2))\n\n    # Create an Axes object for the histogram with the same axes as the histogram\n    ax = plt.gca()\n    # Get the x-axis limits of the histogram\n    xlim = ax.get_xlim()\n    # Generate x-axis values for the PDF\n    x = np.linspace", "compilation_passed": true, "time": 0.006533145904541016, "tests_passed": true, "error": null}
{"code": "np.random.seed(seed)\n    data = np.random.normal(mu, sigma, num_samples)\n\n    ax = plt.subplot(111)\n    ax.hist(data, bins=num_bins, density=True, edgecolor='black', linewidth=0.5)\n    ax.set_xlim(min(data), max(data))\n\n    x = np.linspace(min(data), max(data), 100)\n    y = sp.stats.norm.pdf(x, mu, sigma)\n    ax.plot(x, y, color='red', linewidth=2)\n\n    # Fit OLS regression\n    model_fit = ols(f'data ~ x + np.power(x, 2)', {'x': x}).fit()\n    y_hat = model_fit.fittedvalues\n    ax.plot(x, y_hat, color='green', linewidth=2)\n\n    ax.set_title(f'Mean = {mu}, Standard Deviation = {sigma}')\n    return ax", "compilation_passed": true, "time": 0.007203102111816406, "tests_passed": false, "error": "NameError"}
{"code": "np.random.seed(seed)\n    x = np.random.normal(mu, sigma, num_samples)\n    plt.hist(x, bins=num_bins, edgecolor='black')\n    pdf_x = np.linspace(min(x), max(x), 1000)\n    pdf_y = 1/(sigma * np.sqrt(2 * np.pi)) * np.exp(-(pdf_x - mu)**2 / (2 * sigma**2))\n    plt.plot(pdf_x, pdf_y, label='PDF', color='red')\n    model = ols(f\"x ~ np.poly([x, x**2])\", data={'x': x}).fit()\n    plt.plot(x, model.params[0] + model.params[1] * x + model.params[2] * x ** 2, label='OLS', color='green')\n    plt.legend()\n    plt.show()\n    return plt.gca()", "compilation_passed": true, "time": 0.008157014846801758, "tests_passed": false, "error": "        ^^^^^^^^^^^^^^^^^^"}
{"code": "# Set the random seed for reproducibility\n    np.random.seed(seed)\n\n    # Generate the random samples from a normal distribution with the given mean and standard deviation\n    samples = np.random.normal(loc=mu, scale=sigma, size=num_samples)\n\n    # Plot the histogram with the specified number of bins\n    ax = plt.hist(samples, bins=num_bins, density=True, edgecolor='black')\n\n    # Set the x-values for the normal distribution PDF and overlay the PDF on the histogram\n    x = np.linspace(-2, 2, 1000)\n    y = (1 / (sigma * np.sqrt(2 * np.pi))) * np.exp(-(x - mu) ** 2 / (2 * sigma ** 2))\n    plt.plot(x, y, color='r', label=f'PDF')\n\n    # Fit a second-order polynomial regression on the histogram bin edges and overlay the fitted curve on the histogram\n    x_edges = np.linspace(min(samples), max(samples), num_bins+1)\n", "compilation_passed": true, "time": 0.006803035736083984, "tests_passed": true, "error": null}
{"code": "np.random.seed(seed) # set the random seed for reproducibility\n    data = np.random.normal(mu, sigma, size=num_samples) # generate samples from the normal distribution\n\n    # Create a histogram of the data with 30 bins\n    fig, ax = plt.subplots()\n    ax.hist(data, bins=num_bins, density=True, edgecolor='black')\n\n    # Overlay the PDF of the normal distribution on the histogram\n    x = np.linspace(mu - 3*sigma, mu + 3*sigma, 1000) # generate a range of x values to plot the PDF\n    y = (1 / (sigma * np.sqrt(2 * np.pi))) * np.exp(-((x - mu) ** 2 / (2 * sigma ** 2))) # calculate the PDF values\n    ax.plot(x, y, color='red', label='PDF') # plot the PDF and add a label\n\n    # Fit a second order polynomial function to the histogram using OLS regression\n    data_df = pd.DataFrame({'x': data}) # convert", "compilation_passed": true, "time": 0.023957014083862305, "tests_passed": false, "error": "NameError"}
{"code": "np.random.seed(seed)\n    X = np.random.normal(mu, sigma, num_samples)\n    ax = plt.hist(X, bins=num_bins, density=True)\n    # Add the probability density function\n    x = np.linspace(min(X), max(X), num_bins)\n    y = (1 / (np.sqrt(2 * np.pi) * sigma)) * np.exp(-((x - mu) ** 2) / (2 * sigma ** 2))\n    plt.plot(x, y, 'r-')\n    # Add the second order polynomial function\n    y_ols = ols('X ~ ns(X, 2)').fit(X, y).fittedvalues\n    plt.plot(X, y_ols, 'g-')\n    return plt.gca()", "compilation_passed": true, "time": 0.006774187088012695, "tests_passed": false, "error": "TypeError"}
{"code": "np.random.seed(seed)\n    x = np.random.normal(mu, sigma, size=num_samples)\n    plt.hist(x, bins=num_bins)\n    plt.show()\n    ax = plt.gca()\n    return ax", "compilation_passed": true, "time": 0.006843090057373047, "tests_passed": true, "error": null}
{"code": "# Set the random seed for reproducibility\n    np.random.seed(seed)\n    # Create the data\n    data = np.random.normal(mu, sigma, num_samples)\n\n    # Plot the histogram\n    ax = plt.hist(data, bins=num_bins)\n\n    # Define the x-axis values for the PDF\n    x = np.linspace(min(data), max(data), 1000)\n\n    # Plot the PDF\n    y = 1 / (sigma * np.sqrt(2 * np.pi)) * np.exp(-(x - mu) ** 2 / (2 * sigma ** 2))\n    plt.plot(x, y, 'r')\n\n    # Fit the bin-wise OLS regression\n    df = pd.DataFrame({\"x\": np.digitize(data, ax[1]), \"y\": data})\n    ols_result = ols(\"y ~ x\", data=df).fit()\n    plt.plot(x, ols_result.fittedvalues, 'g')\n    return ax", "compilation_passed": true, "time": 0.006536960601806641, "tests_passed": false, "error": "NameError"}
{"code": "np.random.seed(seed)\n    samples = np.random.normal(mu, sigma, num_samples)\n\n    fig, ax = plt.subplots()\n    ax.hist(samples, bins=num_bins, density=True)\n\n    # Compute the probability density function of the normal distribution\n    x = np.linspace(min(samples), max(samples), num_bins)\n    y = 1/(sigma * np.sqrt(2 * np.pi)) * np.exp(- (x - mu)**2 / (2 * sigma**2))\n\n    # Overlay the PDF on the histogram\n    ax.plot(x, y, 'r-')\n\n    # Compute the bin edges\n    bin_edges = np.linspace(min(samples), max(samples), num_bins+1)\n\n    # Compute the bin means\n    bin_means = (bin_edges[1:] + bin_edges[:-1]) / 2\n\n    # Compute the bin counts\n    bin_counts = np.histogram(samples, bins=bin_edges)[0]\n\n    # Fit", "compilation_passed": true, "time": 0.02200603485107422, "tests_passed": true, "error": null}
{"code": "np.random.seed(seed)\n    # generate samples from a normal distribution with the given mean and standard deviation\n    samples = np.random.normal(mu, sigma, num_samples)\n    # create a histogram with the given number of bins\n    fig, ax = plt.subplots()\n    ax.hist(samples, bins=num_bins)\n    # overlay the probability density function (PDF) of the normal distribution\n    # with the given mean and standard deviation\n    x = np.linspace(mu - 3 * sigma, mu + 3 * sigma, 1000)\n    y = (1 / (sigma * np.sqrt(2 * np.pi))) * np.exp(-((x - mu) ** 2 / (2 * sigma ** 2)))\n    ax.plot(x, y, color='red', label='PDF')\n    # overlay a second order polynomial function fitted bin-wise using OLS regression\n    # get the edges of the bins\n    bin_edges = np.linspace(mu - 3 * sigma, mu + 3 * sigma, num_bins + 1)\n    # get", "compilation_passed": true, "time": 0.021944046020507812, "tests_passed": true, "error": null}
{"code": "np.random.seed(seed)\n    dist = np.random.normal(mu, sigma, num_samples)\n\n    # create histogram and overlay probability density function\n    ax = plt.subplot(2, 1, 1)\n    ax.hist(dist, bins=num_bins, density=True)\n    x = np.linspace(dist.min(), dist.max(), 1000)\n    ax.plot(x, norm.pdf(x, mu, sigma))\n\n    # overlay second order polynomial function fitted bin-wise\n    y = dist\n    model = ols(\"y ~ np.log(x) + I(np.log(x) ** 2)\", {\"x\": x, \"y\": y}).fit()\n    ax.plot(x, model.fittedvalues)\n    ax.legend([\"PDF\", \"OLS\"])\n    ax.set_title(f\"Mean: {mu}, Standard Deviation: {sigma}\")\n\n    return ax", "compilation_passed": true, "time": 0.009736061096191406, "tests_passed": false, "error": "NameError"}
