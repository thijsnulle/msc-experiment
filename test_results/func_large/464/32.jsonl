{"code": "return json.dumps(my_obj, default=serialize_complex, indent=4)", "compilation_passed": true, "time": 0.0007569789886474609, "tests_passed": false, "error": "NameError"}
{"code": "return json.dumps(my_obj, default=custom_default_function)", "compilation_passed": true, "time": 0.0006961822509765625, "tests_passed": false, "error": "NameError"}
{"code": "return json.dumps(my_obj, default=serializer, indent=4)", "compilation_passed": true, "time": 0.0007660388946533203, "tests_passed": false, "error": "NameError"}
{"code": "# Your code here ...\n    result = json.dumps(my_obj, default=lambda x: x.strftime('%Y-%m-%dT%H:%M:%S') if isinstance(x, datetime) else str(x.value) if isinstance(x, Decimal) else str(x) if not isinstance(x, str) else x, ensure_ascii=False, check_circular=False, allow_nan=True, cls=None, indent=None, separators=None, encoding=\"utf-8\", default=None, sort_keys=True, ignore_nan=True)\n    return result", "compilation_passed": false, "time": 0.0005209445953369141, "tests_passed": false, "error": "SyntaxError"}
{"code": "# Create a custom encoder for datetime and Decimal objects\n    custom_encoder = {\n        datetime: lambda x: x.isoformat(),\n        Decimal: lambda x: str(x)\n    }\n\n    class CustomEncoder(json.JSONEncoder):\n        def default(self, obj):\n            if type(obj) in custom_encoder:\n                return custom_encoder[type(obj)](obj)\n            return json.JSONEncoder.default(self, obj)\n\n    # Use the custom encoder to serialize the object\n    return json.dumps(my_obj, cls=CustomEncoder)", "compilation_passed": true, "time": 0.0009262561798095703, "tests_passed": true, "error": null}
{"code": "return json.dumps(my_obj, default=lambda obj: (obj.isoformat() if isinstance(obj, datetime) else\n        str(obj) if isinstance(obj, Decimal) else None))", "compilation_passed": true, "time": 0.0008718967437744141, "tests_passed": true, "error": null}
{"code": "def serialize_datetime(obj):\n        if isinstance(obj, datetime):\n            return obj.isoformat()\n        raise TypeError\n\n    def serialize_decimal(obj):\n        if isinstance(obj, Decimal):\n            return float(obj)\n        raise TypeError\n\n    default_encoders = {\n        datetime: serialize_datetime,\n        Decimal: serialize_decimal,\n    }\n\n    return json.dumps(my_obj, default=lambda obj: default_encoders[type(obj)](obj))", "compilation_passed": true, "time": 0.0010159015655517578, "tests_passed": false, "error": "KeyError"}
{"code": "def custom_serializer(obj):\n        if isinstance(obj, datetime):\n            return obj.isoformat()\n        if isinstance(obj, Decimal):\n            return str(obj)\n        raise TypeError(f\"Object of type {obj.__class__.__name__} is not JSON serializable\")\n\n    return json.dumps(my_obj, default=custom_serializer)", "compilation_passed": true, "time": 0.0008268356323242188, "tests_passed": true, "error": null}
{"code": "class TaskJSONEncoder(json.JSONEncoder):\n        def default(self, obj):\n            if isinstance(obj, datetime):\n                return obj.isoformat()\n            elif isinstance(obj, Decimal):\n                return str(obj)\n            return json.JSONEncoder.default(self, obj)\n\n    return json.dumps(my_obj, cls=TaskJSONEncoder, sort_keys=True)", "compilation_passed": true, "time": 0.0009610652923583984, "tests_passed": true, "error": null}
{"code": "def my_encoder(obj):\n        if isinstance(obj, datetime):\n            return obj.isoformat()\n        if isinstance(obj, Decimal):\n            return str(obj)\n        raise TypeError(f\"Type {type(obj)} not serializable.\")\n\n    return json.dumps(my_obj, default=my_encoder)", "compilation_passed": true, "time": 0.0008399486541748047, "tests_passed": true, "error": null}
{"code": "return json.dumps(my_obj, default=serialize_complex_types)", "compilation_passed": true, "time": 0.0006711483001708984, "tests_passed": false, "error": "NameError"}
{"code": "class CustomEncoder(json.JSONEncoder):\n        def default(self, obj):\n            if isinstance(obj, datetime):\n                return obj.isoformat()\n            if isinstance(obj, Decimal):\n                return float(obj)\n            return super().default(obj)\n\n    return json.dumps(my_obj, cls=CustomEncoder)", "compilation_passed": true, "time": 0.0009739398956298828, "tests_passed": true, "error": null}
{"code": "def default(obj):\n        if isinstance(obj, datetime):\n            return obj.isoformat()\n        if isinstance(obj, Decimal):\n            return float(obj)\n        return str(obj)\n\n    return json.dumps(my_obj, default=default)", "compilation_passed": true, "time": 0.0008649826049804688, "tests_passed": true, "error": null}
{"code": "def custom_serializer(obj):\n        if isinstance(obj, datetime):\n            return obj.isoformat()\n        if isinstance(obj, Decimal):\n            return str(obj)\n        raise TypeError(f\"Type {type(obj)} not serializable\")\n\n    return json.dumps(my_obj, default=custom_serializer)", "compilation_passed": true, "time": 0.0008199214935302734, "tests_passed": true, "error": null}
{"code": "class CustomEncoder(json.JSONEncoder):\n        def default(self, obj):\n            if isinstance(obj, datetime):\n                # Serialize datetime as ISO 8601 format string\n                return obj.isoformat()\n            elif isinstance(obj, Decimal):\n                # Serialize Decimal as plain string\n                return str(obj)\n            else:\n                # Fall back to default encoding\n                return super().default(obj)\n\n    return json.dumps(my_obj, cls=CustomEncoder)", "compilation_passed": true, "time": 0.0008871555328369141, "tests_passed": true, "error": null}
{"code": "# Implement your logic here\n    return json.dumps(my_obj, default=lambda obj: obj.isoformat() if isinstance(obj, datetime) else float(obj) if isinstance(obj, Decimal) else None)", "compilation_passed": true, "time": 0.0008268356323242188, "tests_passed": true, "error": null}
{"code": "class TaskEncoder(json.JSONEncoder):\n        def default(self, obj):\n            if isinstance(obj, datetime):\n                return obj.isoformat()\n            if isinstance(obj, Decimal):\n                return str(obj)\n            return super().default(obj)\n\n    return json.dumps(my_obj, cls=TaskEncoder)", "compilation_passed": true, "time": 0.0008540153503417969, "tests_passed": true, "error": null}
{"code": "class MyJsonEncoder(json.JSONEncoder):\n        def default(self, obj):\n            if isinstance(obj, datetime):\n                return obj.isoformat()\n            if isinstance(obj, Decimal):\n                return str(obj)\n            return json.JSONEncoder.default(self, obj)\n\n    return json.dumps(my_obj, cls=MyJsonEncoder)", "compilation_passed": true, "time": 0.0008859634399414062, "tests_passed": true, "error": null}
{"code": "def convert_obj_to_json(obj):\n        \"\"\"Convert `obj` to a JSON-compatible object\"\"\"\n        if isinstance(obj, datetime):\n            return obj.isoformat()\n        if isinstance(obj, Decimal):\n            return float(obj)\n        if isinstance(obj, My_class):\n            return {'__my_class__': True, 'value': obj.value}\n        return obj\n\n    class CustomJSONEncoder(json.JSONEncoder):\n        def default(self, obj):\n            return convert_obj_to_json(obj)\n\n    # If `my_obj` is already a JSON string, return it as is\n    if isinstance(my_obj, str) and my_obj.startswith('{') and my_obj.endswith('}'):\n        return my_obj\n\n    return json.dumps(my_obj, cls=CustomJSONEncoder)", "compilation_passed": true, "time": 0.0010929107666015625, "tests_passed": false, "error": "NameError"}
{"code": "def custom_encoder(obj):\n        if isinstance(obj, datetime):\n            return obj.isoformat()\n        elif isinstance(obj, Decimal):\n            return str(obj)\n\n    return json.dumps(my_obj, default=custom_encoder, sort_keys=True)", "compilation_passed": true, "time": 0.0008828639984130859, "tests_passed": true, "error": null}
{"code": "class CustomEncoder(json.JSONEncoder):\n        def default(self, obj):\n            if isinstance(obj, datetime):\n                return obj.isoformat()\n            if isinstance(obj, Decimal):\n                return str(obj)\n            return json.JSONEncoder.default(self, obj)\n\n    return json.dumps(my_obj, cls=CustomEncoder)", "compilation_passed": true, "time": 0.0008580684661865234, "tests_passed": true, "error": null}
{"code": "return json.dumps(\n        my_obj, default=lambda x: x.isoformat() if isinstance(x, datetime) else str(x), ensure_ascii=False\n    )", "compilation_passed": true, "time": 0.0008409023284912109, "tests_passed": true, "error": null}
{"code": "class CustomJsonEncoder(json.JSONEncoder):\n        \"\"\"\n        Custom JSON encoder class to handle datetime and Decimal data types.\n\n        This class overrides the default behaviour of the `json.JSONEncoder` to handle datetime and Decimal objects.\n        It supports serializing datetime objects to ISO format strings (e.g., \"2023-04-01T12:00:00\"), and\n        decimal objects to simple strings (e.g., \"10.99\").\n\n        Note: This encoder class is used internally within the `task_func` function and not intended to be used separately.\n        \"\"\"\n        def default(self, obj):\n            if isinstance(obj, datetime):\n                return obj.isoformat()\n            elif isinstance(obj, Decimal):\n                return str(obj)\n            return super().default(obj)\n\n    return json.dumps(my_obj, cls=CustomJsonEncoder)", "compilation_passed": true, "time": 0.0008966922760009766, "tests_passed": true, "error": null}
{"code": "# Your code here...\n    pass # Delete \"pass\" when writing your code", "compilation_passed": true, "time": 0.0008428096771240234, "tests_passed": false, "error": "TypeError"}
{"code": "class MyEncoder(json.JSONEncoder):\n        def default(self, my_obj):\n            if isinstance(my_obj, datetime):\n                return my_obj.isoformat()\n            if isinstance(my_obj, Decimal):\n                return float(my_obj)\n            return json.JSONEncoder.default(self, my_obj)\n\n    return json.dumps(my_obj, cls=MyEncoder)", "compilation_passed": true, "time": 0.0008702278137207031, "tests_passed": true, "error": null}
{"code": "if isinstance(my_obj, datetime):\n        return my_obj.isoformat()\n    if isinstance(my_obj, Decimal):\n        return str(my_obj)", "compilation_passed": true, "time": 0.0007598400115966797, "tests_passed": false, "error": "TypeError"}
{"code": "class MyEncoder(json.JSONEncoder):\n        def default(self, o):\n            if isinstance(o, datetime):\n                return o.isoformat()\n            if isinstance(o, Decimal):\n                return str(o)\n            return super(MyEncoder, self).default(o)\n    result = json.dumps(my_obj, cls=MyEncoder)\n    return result", "compilation_passed": true, "time": 0.0008780956268310547, "tests_passed": true, "error": null}
{"code": "return json.dumps(my_obj, default=lambda o: o.isoformat() if isinstance(o, datetime) else o.__str__() if isinstance(o, Decimal) else None)", "compilation_passed": true, "time": 0.0008440017700195312, "tests_passed": true, "error": null}
{"code": "# return json.dumps(my_obj, indent=2, cls=ComplexEncoder)\n\n    # This is an alternative version that can be used when the `ComplexEncoder` class is not used to serialize complex data types. \n    def encode_complex(obj):\n        if isinstance(obj, datetime):\n            iso = obj.isoformat()\n            return iso\n        elif isinstance(obj, Decimal):\n            return float(obj)\n\n    # This is an alternative version that can be used when the `ComplexEncoder` class is not used to serialize complex data types. \n    return json.dumps(my_obj, default=encode_complex)", "compilation_passed": true, "time": 0.0008292198181152344, "tests_passed": true, "error": null}
{"code": "# Initialize a list of custom serialization functions for datetime and Decimal\n    handlers = {datetime: lambda dt: dt.isoformat(), Decimal: lambda d: str(d)}\n\n    return json.dumps(\n        my_obj,\n        indent=4,\n        default=lambda x: handlers[type(x)](x),\n        sort_keys=True,\n    )", "compilation_passed": true, "time": 0.0008871555328369141, "tests_passed": true, "error": null}
