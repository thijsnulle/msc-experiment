{"code": "try:\n        factorial = lambda x: x if x <= 1 else x * factorial(x - 1)\n        if not numbers: return [], []\n        factorial_sums = list(map(lambda x: reduce(lambda a, b: a + b,\n                                                    map(factorial, x)),\n                                  permutations(numbers)))\n        permutations_list = list(permutations(numbers))\n        return factorial_sums, permutations_list\n    except Exception as e:\n        return (str(e), None)", "compilation_passed": true, "time": 0.0009505748748779297, "tests_passed": true, "error": null}
{"code": "factorials = [math.factorial(i) for i in numbers]\n    sum_factorials = list(map(lambda x: reduce(lambda a, b: a+b, x),\n                              [factorials for i in range(len(numbers))]))\n    permutations_list = [p for p in permutations(numbers)]\n    return sum_factorials, permutations_list", "compilation_passed": true, "time": 0.00092315673828125, "tests_passed": true, "error": null}
{"code": "if not numbers:\n        return [], []\n\n    factorial_sum = lambda num: reduce(lambda x, y: x*y, range(1, num+1))\n    permutations = [tuple(number) for number in list(permutations(numbers))]\n    factorial_numbers = [\n        sum(map(factorial_sum, [number for number in list(number_tuple)]))\n        for number_tuple in permutations\n    ]\n    return factorial_numbers, permutations", "compilation_passed": true, "time": 0.0008759498596191406, "tests_passed": false, "error": "UnboundLocalError"}
{"code": "if not all(isinstance(num, int) for num in numbers):\n        raise TypeError(\"List must contain only integers\")\n    if not all(num >= 0 for num in numbers):\n        raise ValueError(\"Numbers must be non-negative\")\n    perm = list(permutations(numbers))\n    fac = [reduce(lambda a, b: a+b,\n                  (math.factorial(i) for i in item)) for item in perm]\n    return fac, perm", "compilation_passed": true, "time": 0.0009188652038574219, "tests_passed": false, "error": "TypeError"}
{"code": "if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\n        raise TypeError(\"input numbers must be a list of integers\")\n    if any(num < 0 for num in numbers):\n        raise ValueError(\"input numbers must be positive\")\n    if not numbers:\n        return [], []\n    # Generate all permutations of numbers\n    permutations_ = list(permutations(numbers))\n    # Calculate factorial sums\n    factorial_sums = [reduce(lambda x, y: x * y, map(math.factorial, p)) for p in permutations_]\n\n    # Convert each permutation tuple to a list\n    permutations_list = [list(p) for p in permutations_]\n\n    return factorial_sums, permutations_list", "compilation_passed": true, "time": 0.0009379386901855469, "tests_passed": true, "error": null}
{"code": "# Check that input is a list of integers.\n    if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\n        raise TypeError(\"Input numbers must be a list of integers\")\n\n    # Check that input is not negative.\n    if any(num < 0 for num in numbers):\n        raise ValueError(\"Input numbers cannot be negative\")\n\n    # Generate all permutations of numbers and calculate the sum \n    # of the factorials of each number in each permutation.\n    factorials = []\n    permutations = []\n    for p in permutations(numbers):\n        factorials.append(reduce(lambda a, b: a * math.factorial(b), p, 1))\n        permutations.append(p)\n    return factorials, permutations", "compilation_passed": true, "time": 0.0008921623229980469, "tests_passed": false, "error": "TypeError"}
{"code": "# Checking input numbers\n    if not numbers:\n        return []\n\n    # Creating list of tuples\n    list_of_permutations = []\n    for i in permutations(numbers):\n        list_of_permutations.append(i)\n\n    # Creating list of sum of factorials for each element of list of tuples\n    result = []\n    for i in list_of_permutations:\n        result.append(reduce(lambda x, y: x + y, list(map(lambda x: math.factorial(x), i))))\n\n    # Returning values\n    return result, list_of_permutations", "compilation_passed": true, "time": 0.0008461475372314453, "tests_passed": false, "error": "ValueError"}
{"code": "try:\n        if not all(isinstance(x, int) for x in numbers):\n            raise TypeError('numbers must be a list of integers')\n        elif not all(x >= 0 for x in numbers):\n            raise ValueError('input numbers must be non-negative')\n    except (TypeError, ValueError):\n        print('Error: input numbers must be a list of non-negative integers')\n        return [], []\n\n    if not numbers:\n        return [], []\n\n    # Generate all permutations of the list of numbers\n    permutations = [list(perm) for perm in permutations(numbers)]\n\n    # Calculate the sum of the factorials of each number in each permutation\n    factorials = [reduce(lambda x, y: x * y, range(1, num + 1)) for num in numbers]\n    factorial_sums = [sum(factorials) for perm in permutations]\n\n    return factorial_sums, permutations", "compilation_passed": true, "time": 0.0009768009185791016, "tests_passed": false, "error": "UnboundLocalError"}
{"code": "if numbers is []:\n        return [], []\n    if not isinstance(numbers, list):\n        raise TypeError(\"The argument should be a list of integers!\")\n    if any(not isinstance(x, int) for x in numbers):\n        raise TypeError(\"All elements in the list should be integers!\")\n    if any(x < 0 for x in numbers):\n        raise ValueError(\"Only positive integers are allowed!\")\n    permutations_list = list(permutations(numbers))\n    sum_list = list(\n        reduce(\n            lambda x, y: x + y,\n            [math.factorial(n) for n in x],\n        ) for x in permutations_list\n    )\n    return sum_list, permutations_list", "compilation_passed": true, "time": 0.0009648799896240234, "tests_passed": false, "error": "TypeError"}
{"code": "if not isinstance(numbers, list) or not all(isinstance(i, int) for i in numbers):\n        raise TypeError(\"numbers must be a list of integers\")\n\n    if not all(i >= 0 for i in numbers):\n        raise ValueError(\"input numbers must be non-negative\")\n\n    factorials = [math.factorial(i) for i in numbers]\n    if not numbers:\n        return []\n\n    permutations_list = list(permutations(numbers))\n    return list(reduce(lambda x, y: x + math.factorial(y), num, 0) for num in permutations_list), permutations_list", "compilation_passed": true, "time": 0.001013040542602539, "tests_passed": false, "error": "ValueError"}
{"code": "if not numbers:\n        return [], []\n\n    # Check if numbers is a list of integers\n    if not isinstance(numbers, list):\n        raise TypeError('Input numbers must be a list')\n    if not all(isinstance(n, int) for n in numbers):\n        raise TypeError('Input numbers must be integers')\n\n    # Check if input numbers are negative\n    if any(n < 0 for n in numbers):\n        raise ValueError('Input numbers must be non-negative')\n\n    # Get all permutations of the list\n    perms = permutations(numbers)\n\n    # Calculate the factorial sum for each permutation\n    sums = []\n    for perm in perms:\n        factorials = [math.factorial(n) for n in perm]\n        sums.append(reduce(lambda x, y: x + y, factorials))\n\n    return sums, list(perms)", "compilation_passed": true, "time": 0.0009911060333251953, "tests_passed": true, "error": null}
{"code": "try:\n        if not all(isinstance(i, int) for i in numbers):\n            raise TypeError(f\"{type(numbers)} is not int\")\n        if not all(i >= 0 for i in numbers):\n            raise ValueError(\"Numbers can't be negative\")\n        perm = list(permutations(numbers))\n        fac = list(map(lambda x: reduce(lambda a, b: a + math.factorial(b), x, 0), perm))\n        return fac, perm\n    except (TypeError, ValueError) as e:\n        print(e)\n        return [], []", "compilation_passed": true, "time": 0.0009980201721191406, "tests_passed": true, "error": null}
{"code": "if not numbers:\n        return [], []\n\n    if not isinstance(numbers, list):\n        raise TypeError(f\"Expected list, got {type(numbers)}.\")\n\n    if not all([isinstance(num, int) for num in numbers]):\n        raise TypeError(\"Numbers should be a list of integers.\")\n\n    if not all([num >= 0 for num in numbers]):\n        raise ValueError(\"Numbers should be positive integers.\")\n\n    # Generate all permutations of the input list.\n    permutations_list = list(permutations(numbers))\n\n    # Calculate the factorial sum of each permutation.\n    factorial_sums = [reduce(lambda x, y: x * math.factorial(y), permutation) for permutation in permutations_list]\n\n    # Convert factorial_sums to a list\n    factorial_sums = list(factorial_sums)\n\n    # Convert permutations_list to a list of lists\n    permutations_list = [list(permutation) for permutation in permutations_list]\n\n    return factor", "compilation_passed": true, "time": 0.0009379386901855469, "tests_passed": false, "error": "NameError"}
{"code": "if not numbers:\n        return [], []\n\n    # Check if numbers is a list of integers\n    if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\n        raise TypeError(\"numbers must be a list of integers.\")\n\n    # Check if input numbers are not negative\n    if any(num < 0 for num in numbers):\n        raise ValueError(\"input numbers must be positive or zero.\")\n\n    # Generate permutations of numbers and calculate sum of factorials for each permutation\n    perm = list(permutations(numbers))\n    fac = [sum(map(math.factorial, perm)) for perm in permutations(numbers)]\n\n    return fac, perm", "compilation_passed": true, "time": 0.0009350776672363281, "tests_passed": true, "error": null}
{"code": "try:\n        permutations_list = list(permutations(numbers)) # Calculate all permutations of numbers using itertools.permutations\n\n        # Calculate the sum of the factorials of each number in each permutation\n        factorial_sum_list = [sum(map(lambda num: math.factorial(num), permutation)) for permutation in permutations_list]\n\n        return [factorial_sum_list, permutations_list]\n    except TypeError as e:\n        print(e)\n    except ValueError as e:\n        print(e)", "compilation_passed": true, "time": 0.0009100437164306641, "tests_passed": true, "error": null}
{"code": "try:\n        factorials = [math.factorial(num) for num in numbers]\n        if any(num < 0 for num in numbers):\n            raise ValueError('Numbers must be positive.')\n        sums = [reduce(lambda a, b: a+b, factorials)] * \\\n            math.factorial(len(factorials))\n    except TypeError:\n        raise TypeError('Numbers must be a list of integers.')\n    # Create all permutations of the input list and calculate the sum of the \n    # factorials of each number in each permutation.\n    perms = list(permutations(numbers))\n\n    # Return the list of factorial sums and the list of all permutations.\n    return sums, perms", "compilation_passed": true, "time": 0.000911712646484375, "tests_passed": false, "error": "TypeError"}
{"code": "if not isinstance(numbers, list) or not all(isinstance(n, int) for n in numbers):\n        raise TypeError(\"Input numbers must be a list of integers.\")\n    if any(n < 0 for n in numbers):\n        raise ValueError(\"Input numbers must not be negative.\")\n    perm_list = list(permutations(numbers))\n    fac_list = list(map(lambda x: reduce(lambda a, b: a * b, map(math.factorial, x)), perm_list))\n    return fac_list, perm_list", "compilation_passed": true, "time": 0.000885009765625, "tests_passed": true, "error": null}
{"code": "# Check input data\n    if numbers is not None and numbers != []:\n        if isinstance(numbers, list) and all(isinstance(i, int) for i in numbers):\n            if any(i < 0 for i in numbers):\n                raise ValueError(\"Input data cannot contain negative numbers.\")\n        else:\n            raise TypeError(\"Input data must be a list of integers.\")\n    else:\n        return [], []\n\n    # Generate all permutations\n    permut = list(permutations(numbers))\n    factorial_sum = []\n    for item in permut:\n        sum_fac = reduce(lambda x, y: x * math.factorial(y), item, 1)\n        factorial_sum.append(sum_fac)\n\n    return factorial_sum, permut", "compilation_passed": true, "time": 0.0009560585021972656, "tests_passed": true, "error": null}
{"code": "if numbers == []:\n        return [], []\n    elif any(isinstance(x, int) is False for x in numbers):\n        raise TypeError\n    elif any(x < 0 for x in numbers):\n        raise ValueError\n    else:\n        factorials = []\n        perms = list(permutations(numbers, len(numbers)))\n        for i in perms:\n            factorials.append(reduce(lambda a, b: a + math.factorial(b), i, 0))\n        return factorials, perms", "compilation_passed": true, "time": 0.0009658336639404297, "tests_passed": true, "error": null}
{"code": "if not isinstance(numbers, list):\n        raise TypeError('Numbers must be a list of integers.')\n    if not all(isinstance(number, int) for number in numbers):\n        raise TypeError('Numbers must be a list of integers.')\n    if any(number < 0 for number in numbers):\n        raise ValueError('Numbers must be positive integers.')\n\n    factorial_sums = []\n    permutations_list = []\n\n    if numbers == []:\n        return [], []\n    else:\n        for perm in permutations(numbers):\n            permutations_list.append(perm)\n            factorial_sums.append(reduce(lambda a, b: a + b, map(math.factorial, perm)))\n\n    return factorial_sums, permutations_list", "compilation_passed": true, "time": 0.0010249614715576172, "tests_passed": true, "error": null}
{"code": "# Check input\n    if not numbers or not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n    for n in numbers:\n        if not isinstance(n, int) or n < 0:\n            raise ValueError(\"Input numbers must be non-negative integers.\")\n\n    if not numbers:\n        return [], []\n\n    # Create a list of permutations\n    permutations = list(permutations(numbers))\n\n    # Calculate the factorial sum of each permutation\n    factorial_sum = [reduce(lambda x, y: x * y, map(math.factorial, p))\n                     for p in permutations]\n    return factorial_sum, permutations", "compilation_passed": true, "time": 0.0008590221405029297, "tests_passed": false, "error": "UnboundLocalError"}
{"code": "if not numbers:\n        return [], []\n\n    if not isinstance(numbers, list):\n        raise TypeError('numbers must be a list of integers')\n\n    if any(num < 0 for num in numbers):\n        raise ValueError('numbers must not be negative')\n\n    if not all(isinstance(num, int) for num in numbers):\n        raise TypeError('numbers must be a list of integers')\n\n    permutations = list(permutations(numbers))\n    factorial_sums = [sum(math.factorial(num) for num in nums) for nums in permutations]\n    return factorial_sums, permutations", "compilation_passed": true, "time": 0.0008571147918701172, "tests_passed": false, "error": "UnboundLocalError"}
{"code": "if not all([isinstance(num, int) for num in numbers]):\n        raise TypeError('numbers must be a list of integers')\n    if any([num < 0 for num in numbers]):\n        raise ValueError('input numbers must be non-negative')\n    factorials = [math.factorial(num) for num in numbers]\n    permutations_numbers = [perm for perm in permutations(numbers)]\n    factorials_sum = [reduce(lambda x, y: x + y, perm) for perm in permutations(factorials)]\n    return factorials_sum, permutations_numbers", "compilation_passed": true, "time": 0.0009288787841796875, "tests_passed": false, "error": "TypeError"}
{"code": "# check input type\n    if not isinstance(numbers, list) or not all(\n        isinstance(num, int) for num in numbers\n    ):\n        raise TypeError(\"Input numbers should be a list of integers\")\n\n    # check input numbers\n    if any(num < 0 for num in numbers):\n        raise ValueError(\"Input numbers should not be negative\")\n\n    # Generate permutations of numbers\n    perms = permutations(numbers)\n    permutations_list = list(perms)\n\n    # Calculate the sum of the factorials of each number in each permutation\n    result = []\n    for perm in permutations_list:\n        # Calculate the factorial of each number and sum it up\n        factorial_sum = reduce(lambda x, y: x + y, (math.factorial(num) for num in perm))\n        result.append(factorial_sum)\n\n    # Return the list containing the sums of the factorials of each number in\n    # each permutation and a list containing all permutations of numbers\n    return result, permutations_list", "compilation_passed": true, "time": 0.0009529590606689453, "tests_passed": false, "error": "TypeError"}
{"code": "# Check if numbers is a list of integers\n    if not isinstance(numbers, list) or any(not isinstance(x, int) for x in numbers):\n        raise TypeError(\"numbers must be a list of integers.\")\n\n    # Check if numbers is not negative\n    if any(x < 0 for x in numbers):\n        raise ValueError(\"numbers must not be negative.\")\n\n    # Generate permutations of the list of numbers\n    permutations_list = permutations(numbers)\n    permutations_list_new = list(permutations_list)\n    # Calculate the sum of the factorials of each number in each permutation\n    factorials_list = []\n    for p in permutations_list_new:\n        factorials = [math.factorial(x) for x in p]\n        factorials_list.append(sum(factorials))\n\n    return factorials_list, permutations_list_new", "compilation_passed": true, "time": 0.0009462833404541016, "tests_passed": true, "error": null}
{"code": "if numbers == []:\n        return [], []\n\n    perms = list(permutations(numbers))\n\n    fac = [\n        reduce(lambda x, y: x + y, map(lambda i: math.factorial(i), perm))\n        for perm in perms\n    ]\n\n    return fac, perms", "compilation_passed": true, "time": 0.0014500617980957031, "tests_passed": true, "error": null}
{"code": "if numbers == []:\n        return [], []\n    for num in numbers:\n        if not isinstance(num, int) or num < 0:\n            raise ValueError('Input numbers must be positive integers')\n    perms = permutations(numbers)\n    perms = list(perms)\n    fac = list(map(lambda nums: reduce(lambda x, y: x + y, map(lambda num: math.factorial(num), nums)), perms))\n    return fac, perms", "compilation_passed": true, "time": 0.000949859619140625, "tests_passed": true, "error": null}
{"code": "if not numbers:\n        return [], []\n    if not all(isinstance(n, int) for n in numbers):\n        raise TypeError('numbers should be a list of integers')\n    if any(n < 0 for n in numbers):\n        raise ValueError('input numbers should be positive')\n\n    perm = list(permutations(numbers))\n    fac = [reduce(lambda x, y: x * y, (math.factorial(n) for n in p)) for p in perm]\n    return fac, perm", "compilation_passed": true, "time": 0.0009541511535644531, "tests_passed": true, "error": null}
{"code": "if not isinstance(numbers, list) or not all(isinstance(x, int) for x in numbers):\n        raise TypeError(\"Input numbers must be a list of integers.\")\n    if not all(x >= 0 for x in numbers):\n        raise ValueError(\"Input numbers cannot be negative.\")\n    if numbers == []:\n        return [], []\n    perms = permutations(numbers)\n    fac = [reduce(lambda x, y: x+y, map(lambda x: math.factorial(x), x)) for x in perms]\n    return fac, list(perms)", "compilation_passed": true, "time": 0.0009152889251708984, "tests_passed": true, "error": null}
{"code": "if numbers is None:\n        raise ValueError(\"No data\")\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n    if not all(isinstance(num, int) for num in numbers):\n        raise TypeError(\"Input list must contain only integers.\")\n    if not all(num >= 0 for num in numbers):\n        raise ValueError(\"Input numbers must be positive integers.\")\n\n    if not numbers:\n        return [], []\n\n    perms = permutations(numbers)\n    perms = [perm for perm in perms]\n    fac = [reduce(lambda x, y: math.factorial(x) + math.factorial(y), perm) for perm in perms]\n\n    return fac, perms", "compilation_passed": true, "time": 0.0009462833404541016, "tests_passed": true, "error": null}
