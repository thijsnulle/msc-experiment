{"code": "file_contents = [open(file_path, \"rb\").read() for file_path in file_paths]\n    file_names = [file_path.split(\"/\")[-1] for file_path in file_paths]\n    buffer = io.BytesIO()\n    with zipfile.ZipFile(buffer, \"w\", zipfile.ZIP_DEFLATED) as zip_file:\n        for file_name, file_content in zip(file_names, file_contents):\n            zip_file.writestr(file_name, file_content)\n    buffer.seek(0)\n    response = FileResponse(buffer)\n    response[\"Content-Type\"] = \"application/zip\"\n    response[\"Content-Disposition\"] = 'attachment; filename=\"files.zip\"'\n    return response", "compilation_passed": true, "time": 0.0009391307830810547, "tests_passed": false, "error": "FileNotFoundError"}
{"code": "mem_zip = io.BytesIO()\n    zip_file = zipfile.ZipFile(mem_zip, 'w')\n    for file_path in file_paths:\n        if os.path.isfile(file_path):\n            # Add a file to the archive\n            zip_file.write(file_path, os.path.basename(file_path))\n        else:\n            # Write content to a file in the archive\n            file_name = f\"{file_path.split('.')[-1]}.txt\"\n            zip_file.writestr(file_name, file_path)\n    zip_file.close()\n    # Generate the response with the ZIP file as an attachment\n    mem_zip.seek(0)\n    response = FileResponse(mem_zip, filename=\"files.zip\")\n    return response", "compilation_passed": true, "time": 0.0007290840148925781, "tests_passed": false, "error": "NameError"}
{"code": "# Generate a temporary BytesIO object to hold the zip file in memory\n    zip_buffer = io.BytesIO()\n\n    # Open a zip file stream in 'w' write mode, using 'zip_buffer' as the backing stream.\n    with zipfile.ZipFile(zip_buffer, 'w') as zip_file:\n\n        # For each file path in the input list, read the file content and add it to the ZIP file\n        for file_path in file_paths:\n            file_content = open(file_path, 'r').read()\n            filename = file_path.split('/')[-1]\n            zip_file.writestr(filename, file_content)\n\n    # Reset the seek to the beginning of the zip_buffer stream, as the write process is complete\n    zip_buffer.seek(0)\n\n    # Return the response as a FileResponse with appropriate content type and attachment header\n    return FileResponse(zip_buffer, as_attachment=True, filename='files.zip')", "compilation_passed": true, "time": 0.0007481575012207031, "tests_passed": false, "error": "FileNotFoundError"}
{"code": "# Create a memory buffer to hold the ZIP file\n    buffer = io.BytesIO()\n\n    # Open the ZIP file in write mode with the buffer\n    with zipfile.ZipFile(buffer, 'w', compression=zipfile.ZIP_DEFLATED) as zip_file:\n        for file in file_paths:\n            # Extract the file path, name, and content from the provided list\n            file_path = file['file_path']\n            file_name = file['file_name']\n            file_content = file['file_content']\n\n            # Check if the file is a directory or a single file and zip accordingly\n            if os.path.isdir(file_path):\n                # Zip entire directory\n                for root, dirs, files in os.walk(file_path):\n                    for file in files:\n                        # Create a relative path for the file within the ZIP\n                        arcname = os.path.relpath(os.path.join(root, file), file_path)\n                        zip_file.write(os.path.join(root, file)", "compilation_passed": false, "time": 0.00019288063049316406, "tests_passed": false, "error": "SyntaxError"}
{"code": "# Create a temporary file-like object in memory\n    zip_buffer = io.BytesIO()\n\n    with zipfile.ZipFile(zip_buffer, 'x') as zip_file:\n        for file_path in file_paths:\n            if os.path.isfile(file_path):\n                # If the file path is a valid file, add it to the zip file\n                zip_file.write(file_path)\n            elif isinstance(file_path, str):\n                # If the file path is a string, treat it as file content and write it to a new file in the zip\n                file_name = file_path.replace(\"\\\\\", \"/\").split(\"/\")[-1]\n                zip_file.writestr(file_name, file_path)\n            else:\n                # If the file path is not valid or not supported, log an error\n                # logger.error(f\"Error: {file_path} is not a valid file path or file content.\")\n                print(f\"Error: {file_path} is not a valid file path or file content.\"", "compilation_passed": false, "time": 0.00016188621520996094, "tests_passed": false, "error": "SyntaxError"}
{"code": "zip_buffer = io.BytesIO()\n    with zipfile.ZipFile(zip_buffer, 'x', zipfile.ZIP_DEFLATED, False) as zip_file:\n        for file_path in file_paths:\n            zip_file.write(file_path)\n\n    response = FileResponse(zip_buffer, filename='files.zip')\n    response['Content-Type'] = 'application/zip'\n    response['Content-Disposition'] = 'attachment; filename=\"files.zip\"'\n    return response", "compilation_passed": true, "time": 0.000949859619140625, "tests_passed": false, "error": "FileNotFoundError"}
{"code": "# Check if settings have been configured before accessing settings.MEDIA_ROOT\n    if not settings.configured:\n        raise RuntimeError(\n            'Settings are not configured. Call settings.configure() with necessary settings before calling this function.'\n        )\n    zip_buffer = io.BytesIO()\n    zip_file = zipfile.ZipFile(zip_buffer, 'x')\n    for file_path in file_paths:\n        with open(file_path, 'rb') as file:\n            file_name = os.path.basename(file_path)\n            zip_file.writestr(file_name, file.read())\n    zip_file.close()\n    response = FileResponse(zip_buffer, filename='files.zip', as_attachment=True, content_type='application/zip')\n    return response", "compilation_passed": true, "time": 0.0007860660552978516, "tests_passed": false, "error": "FileNotFoundError"}
{"code": "buffer = io.BytesIO()\n    with zipfile.ZipFile(buffer, 'w') as zfile:\n        for file_path in file_paths:\n            filename = file_path.split(\"/\")[-1]\n            zfile.writestr(filename, open(file_path, 'rb').read())\n    buffer.seek(0)\n    return FileResponse(buffer, as_attachment=True, filename='files.zip')", "compilation_passed": true, "time": 0.0006840229034423828, "tests_passed": false, "error": "FileNotFoundError"}
{"code": "# Create a new BytesIO object for storing the zip contents in memory\n    zip_buffer = io.BytesIO()\n\n    # Create a zip file using the BytesIO object as the buffer\n    with zipfile.ZipFile(zip_buffer, \"w\", compression=zipfile.ZIP_DEFLATED) as zip_file:\n        # Iterate over the provided file paths\n        for file_path in file_paths:\n            # Add the file to the zip file with its relative path\n            zip_file.write(file_path, arcname=os.path.basename(file_path))\n\n    # Create a FileResponse with the zip file contents as the file\n    response = FileResponse(zip_buffer)\n\n    # Set the content type header to application/zip\n    response[\"Content-Type\"] = \"application/zip\"\n\n    # Set the content disposition header to attachment with a filename of files.zip\n    response[\"Content-Disposition\"] = 'attachment; filename=\"files.zip\"'\n\n    # Return the FileResponse object\n    return response", "compilation_passed": true, "time": 0.0007240772247314453, "tests_passed": false, "error": "NameError"}
{"code": "if not settings.configured:\n        settings.configure()\n    file_path_list = file_paths.split(\",\")\n    temp_zip = io.BytesIO()\n    zfile = zipfile.ZipFile(temp_zip, \"a\")\n    for file_path in file_path_list:\n        if os.path.exists(file_path):\n            zfile.write(file_path, os.path.basename(file_path), zipfile.ZIP_DEFLATED)\n        else:\n            try:\n                with open(file_path, 'r') as f:\n                    content = f.read()\n                zfile.writestr(os.path.basename(file_path), content)\n            except IOError:\n                print(\"File not found:\", file_path)\n    zfile.close()\n    temp_zip.seek(0)\n    return FileResponse(temp_zip, filename='files.zip', as_attachment=True)", "compilation_passed": true, "time": 0.0007979869842529297, "tests_passed": false, "error": "AttributeError"}
{"code": "mem_file = io.BytesIO()\n    with zipfile.ZipFile(mem_file, \"w\", zipfile.ZIP_DEFLATED) as zipf:\n        for file_path in file_paths:\n            if isinstance(file_path, str):\n                file_name = os.path.basename(file_path)\n                if os.path.isfile(file_path):\n                    zipf.write(file_path, file_name)\n                else:\n                    # If the path is not a valid file, add an empty file to the zip\n                    zipf.writestr(file_name, b\"\")\n            else:\n                # Assume file_path is the content of the file\n                file_name = file_path[0]\n                zipf.writestr(file_name, file_path[1])\n    mem_file.seek(0)\n    response = FileResponse(mem_file, as_attachment=True, filename=\"files.zip\")\n    response['Content-Type'] = 'application/zip'\n    return response", "compilation_passed": true, "time": 0.0007178783416748047, "tests_passed": false, "error": "NameError"}
{"code": "# Create in-memory zip file\n    zip_file = io.BytesIO()\n\n    with zipfile.ZipFile(zip_file, 'w') as zip_obj:\n        for file_path in file_paths:\n            # Check if the path is a file\n            if os.path.isfile(file_path):\n                zip_obj.write(file_path, os.path.basename(file_path))\n            else:\n                # Assume it's a file contents string\n                zip_obj.writestr(file_path, file_path)\n\n    # Reset the stream position to 0\n    zip_file.seek(0)\n\n    # Create the FileResponse\n    response = FileResponse(zip_file)\n    response['Content-Type'] = 'application/zip'\n    response['Content-Disposition'] = f'attachment; filename=\"files.zip\"'\n\n    return response", "compilation_passed": true, "time": 0.0007388591766357422, "tests_passed": false, "error": "NameError"}
{"code": "response = FileResponse(io.BytesIO())\n    response['Content-Type'] = 'application/zip'\n    response['Content-Disposition'] = 'attachment; filename=\"files.zip\"'\n    with zipfile.ZipFile(response, 'a') as zip:\n        for file_path in file_paths:\n            if os.path.isfile(file_path):\n                zip.write(file_path)\n            else:\n                if not os.path.isdir(file_path):\n                    os.makedirs(file_path)\n                for root, _, files in os.walk(file_path):\n                    for file in files:\n                        zip.write(os.path.join(root, file))\n    return response", "compilation_passed": true, "time": 0.0008330345153808594, "tests_passed": false, "error": "AttributeError"}
{"code": "with zipfile.ZipFile(io.BytesIO(), 'w', compression=zipfile.ZIP_DEFLATED) as zip_file:\n        for file_path in file_paths:\n            if os.path.exists(file_path):\n                zip_file.write(file_path, os.path.basename(file_path))\n            else:\n                zip_file.writestr(os.path.basename(file_path), file_path)\n    file_bytes = zip_file.getvalue()\n    return FileResponse(\n        io.BytesIO(file_bytes),\n        as_attachment=True, filename='files.zip',\n        content_type='application/zip',\n    )", "compilation_passed": true, "time": 0.0007460117340087891, "tests_passed": false, "error": "NameError"}
{"code": "if not settings.configured:\n        settings.configure()\n    response = FileResponse(io.BytesIO(), as_attachment=True, filename=\"files.zip\")\n    response[\"Content-Type\"] = \"application/zip\"\n    response[\"Content-Disposition\"] = \"attachment; filename=files.zip\"\n    with zipfile.ZipFile(response, \"w\", zipfile.ZIP_DEFLATED) as zip_file:\n        for file_path in file_paths:\n            zip_file.write(file_path)\n\n    return response", "compilation_passed": true, "time": 0.0013318061828613281, "tests_passed": false, "error": "OSError"}
{"code": "zip_buffer = io.BytesIO()\n    with zipfile.ZipFile(zip_buffer, \"w\", compression=zipfile.ZIP_DEFLATED) as zip_file:\n        for file_path in file_paths:\n            filename = os.path.basename(file_path)\n            if os.path.exists(file_path):\n                zip_file.write(file_path, filename)\n            else:\n                zip_file.writestr(filename, file_path)\n    zip_buffer.seek(0)\n    response = FileResponse(zip_buffer)\n    response[\"Content-Type\"] = \"application/zip\"\n    response[\"Content-Disposition\"] = \"attachment; filename=%s\" % settings.FILE_NAME_ZIP\n    return response", "compilation_passed": true, "time": 0.0007870197296142578, "tests_passed": false, "error": "NameError"}
{"code": "# Initialize a memory buffer to store the ZIP file\n    with io.BytesIO() as zip_buffer:\n        # Open a zip file in write mode in the memory buffer\n        with zipfile.ZipFile(zip_buffer, 'w', compression=zipfile.ZIP_DEFLATED, allowZip64=True) as zip_file:\n            # Loop through the provided file paths\n            for file_path in file_paths:\n                # Check if the file path exists\n                if os.path.exists(file_path):\n                    # Add the file to the ZIP file using its base name as the file name in the ZIP\n                    zip_file.write(file_path, os.path.basename(file_path))\n                else:\n                    # Add the file content as a separate file in the ZIP file\n                    zip_file.writestr(os.path.basename(file_path), file_path)\n\n        # Reset the buffer position to 0\n        zip_buffer.seek(0)\n\n    # Set the response content to the generated ZIP file\n", "compilation_passed": true, "time": 0.0007011890411376953, "tests_passed": false, "error": "NameError"}
{"code": "response = HttpRequest()\n\n    # Create a BytesIO object to store the ZIP file data\n    zip_bytes = io.BytesIO()\n\n    # Create a zipfile object\n    with zipfile.ZipFile(zip_bytes, mode='w', compression=zipfile.ZIP_DEFLATED) as zip_file:\n        # Iterate through the file paths and add each file to the ZIP file\n        for file_path in file_paths:\n            # Add the file to the ZIP file with its base name as the archive name\n            zip_file.write(file_path, os.path.basename(file_path))\n\n    # Return the ZIP file as a Django FileResponse\n    response = FileResponse(zip_bytes)\n    response['Content-Type'] = 'application/zip'\n    response['Content-Disposition'] = 'attachment; filename=\"files.zip\"'\n    return response", "compilation_passed": true, "time": 0.001064300537109375, "tests_passed": false, "error": "NameError"}
{"code": "buffer = io.BytesIO()\n    with zipfile.ZipFile(buffer, 'w', zipfile.ZIP_DEFLATED, False) as zip_file:\n        for file_path in file_paths:\n            if os.path.isfile(file_path):\n                zip_file.write(file_path, os.path.basename(file_path))\n    buffer.seek(0)\n    response = FileResponse(buffer, filename=\"files.zip\")\n    response['Content-Disposition'] = f\"attachment; filename='files.zip'\"\n    response['Content-Type'] = 'application/zip'\n    return response", "compilation_passed": true, "time": 0.0006902217864990234, "tests_passed": false, "error": "NameError"}
{"code": "with io.BytesIO() as memory_file:\n        with zipfile.ZipFile(memory_file, mode='w') as zip_file:\n            for file_path in file_paths:\n                if os.path.isfile(file_path):\n                    filename = os.path.basename(file_path)\n                    zip_file.write(file_path, filename)\n                else:\n                    filename = f'file_{len(zip_file.filelist)}'\n                    zip_file.writestr(filename, file_path)\n        memory_file.seek(0)\n        return FileResponse(memory_file, filename='files.zip', content_type='application/zip')", "compilation_passed": true, "time": 0.0007529258728027344, "tests_passed": false, "error": "NameError"}
{"code": "zip_file = io.BytesIO()\n    with zipfile.ZipFile(zip_file, 'w') as zf:\n        for path in file_paths:\n            if os.path.exists(path):\n                zf.write(path, os.path.basename(path))\n            else:\n                zf.writestr(os.path.basename(path), path)\n    zip_file.seek(0)\n    response = FileResponse(zip_file)\n    response['Content-Type'] = 'application/zip'\n    response['Content-Disposition'] = 'attachment; filename=\"files.zip\"'\n    return response", "compilation_passed": true, "time": 0.0006809234619140625, "tests_passed": false, "error": "NameError"}
{"code": "if not settings.configured:\n        settings.configure()\n\n    # Create a temporary buffer to store the zip file\n    buffer = io.BytesIO()\n    # Create a zip file object and write the files to the buffer\n    zip_file = zipfile.ZipFile(buffer, \"w\", zipfile.ZIP_DEFLATED)\n    for file_path in file_paths:\n        zip_file.write(file_path, os.path.basename(file_path))\n    # Close the zip file\n    zip_file.close()\n\n    # Create a file response object from the buffer and set the content type to ZIP\n    buffer.seek(0)\n    return FileResponse(buffer, content_type=\"application/zip\")", "compilation_passed": true, "time": 0.0007128715515136719, "tests_passed": false, "error": "NameError"}
{"code": "# Create a BytesIO object to store the ZIP file\n    zip_bytes = io.BytesIO()\n\n    # Create a ZIP file and add the specified files to it\n    with zipfile.ZipFile(zip_bytes, mode='w') as zip_file:\n        for file_path in file_paths:\n            # Add the file to the ZIP file, with the file name as the ZIP entry name\n            zip_file.write(file_path, os.path.basename(file_path))\n\n    # Reset the file position to the beginning of the BytesIO object\n    zip_bytes.seek(0)\n\n    # Create a FileResponse and set the 'Content-Disposition' header to trigger a download\n    file_response = FileResponse(zip_bytes)\n    file_response['Content-Type'] = 'application/zip'\n    file_response['Content-Disposition'] = 'attachment; filename=\"files.zip\"'\n\n    return file_response", "compilation_passed": true, "time": 0.0006551742553710938, "tests_passed": false, "error": "NameError"}
{"code": "files = []\n    for file_path in file_paths:\n        files.append(file_path)\n    memory_zipfile = io.BytesIO()\n    with zipfile.ZipFile(memory_zipfile, 'w', zipfile.ZIP_DEFLATED, False) as zip_file:\n        for file_path in files:\n            if os.path.exists(file_path):\n                zip_file.write(file_path, os.path.basename(file_path))\n    memory_zipfile.seek(0)\n    response = FileResponse(memory_zipfile, as_attachment=True, filename='files.zip')\n    return response", "compilation_passed": true, "time": 0.00074005126953125, "tests_passed": false, "error": "NameError"}
{"code": "# Check if settings are configured\n    if not settings.configured:\n        # Set minimal necessary settings for the application\n        settings.configure(\n            DEBUG=True,\n            SECRET_KEY='dummy-secret-key',  # Replace with a secure key\n            INSTALLED_APPS=[],\n            MIDDLEWARE=[],\n            ROOT_URLCONF=None,\n        )\n\n    # Generate a temporary ZIP file in memory\n    with io.BytesIO() as f:\n        # Open the ZIP file in write mode\n        with zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED) as zipf:\n            for file_path in file_paths:\n                # Add each file to the ZIP file\n                zipf.write(file_path, file_path)\n\n        # Move the file pointer to the beginning of the file\n        f.seek(0)\n\n        # Create a FileResponse with the generated ZIP file as an attachment\n        response = FileResponse(f, filename=\"files.zip\", content_type=\"application", "compilation_passed": false, "time": 8.225440979003906e-05, "tests_passed": false, "error": "SyntaxError"}
{"code": "if not settings.configured:\n        settings.configure()\n\n    # Create a BytesIO object to hold the ZIP file in memory\n    zip_buffer = io.BytesIO()\n\n    # Create a ZIP file in the memory buffer\n    with zipfile.ZipFile(zip_buffer, 'x', zipfile.ZIP_DEFLATED) as zipf:\n        for file_path in file_paths:\n            # Add files or contents to the ZIP file\n            if os.path.exists(file_path):\n                zipf.write(file_path, os.path.basename(file_path))\n            else:\n                zipf.writestr(os.path.basename(file_path), file_path)\n\n    zip_buffer.seek(0)\n    # Return the ZIP file as a Django FileResponse object with the attachment header\n    return FileResponse(zip_buffer, as_attachment=True, filename='files.zip')", "compilation_passed": true, "time": 0.0006935596466064453, "tests_passed": false, "error": "NameError"}
{"code": "memory_zipfile = io.BytesIO()\n    with zipfile.ZipFile(memory_zipfile, mode=\"w\") as z:\n        for file_path in file_paths:\n            z.writestr(f\"{file_path.name}\", open(file_path.path, 'rb').read())\n    memory_zipfile.seek(0)\n    response = FileResponse(memory_zipfile)\n    response[\"Content-Type\"] = \"application/zip\"\n    response[\n        \"Content-Disposition\"\n    ] = f'attachment; filename=\"files.zip\"'  # noqa: E501\n    return response", "compilation_passed": true, "time": 0.0007307529449462891, "tests_passed": false, "error": "AttributeError"}
{"code": "# Create an in-memory ZIP file\n    zip_buffer = io.BytesIO()\n    # Open the ZIP file for writing\n    with zipfile.ZipFile(zip_buffer, mode='w', compression=zipfile.ZIP_DEFLATED) as zip_file:\n        # Add the specified files to the ZIP file\n        for file in file_paths:\n            # Assuming 'file' is the path to the file to be added to the ZIP\n            zip_file.write(file, os.path.basename(file))\n\n    # Create a Django FileResponse from the ZIP file\n    return FileResponse(zip_buffer, as_attachment=True, filename='files.zip')", "compilation_passed": true, "time": 0.0006499290466308594, "tests_passed": false, "error": "NameError"}
{"code": "file_list = [f for f in file_paths]\n    if not file_list:\n        return None\n    zip_file = io.BytesIO()\n    with zipfile.ZipFile(zip_file, mode='w', compression=zipfile.ZIP_DEFLATED) as zf:\n        for file_path in file_list:\n            filename = os.path.basename(file_path)\n            zf.write(file_path, filename)\n    zip_file.seek(0)\n    response = FileResponse(zip_file)\n    response['Content-Type'] = 'application/zip'\n    response['Content-Disposition'] = 'attachment; filename=\"files.zip\"'\n    return response", "compilation_passed": true, "time": 0.0007600784301757812, "tests_passed": false, "error": "NameError"}
{"code": "if not settings.configured:\n        settings.configure()\n\n    response = FileResponse(\n        io.BytesIO(),\n        as_attachment=True,\n        filename='files.zip'\n    )\n    with zipfile.ZipFile(response, 'w') as archive:\n        for file_path in file_paths:\n            file_name = os.path.basename(file_path)\n            if os.path.exists(file_path):\n                archive.write(file_path, arcname=file_name)\n            else:\n                archive.writestr(file_name, file_path)\n\n    return response", "compilation_passed": true, "time": 0.0009317398071289062, "tests_passed": false, "error": "OSError"}
