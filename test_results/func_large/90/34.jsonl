{"code": "# Validate the input parameters\n    if not isinstance(k, int) or k < 0:\n        raise ValueError(\"'k' must be a non-negative integer.\")\n\n    # Constants\n    radius = 6371  # km\n\n    # Calculate the distance between target and each data point\n    data['Distance'] = np.sqrt(np.square(data['Latitude'] - target[0]) + np.square(data['Longitude'] - target[1]))\n\n    # Sort the data by distance in ascending order\n    sorted_data = data.sort_values(by='Distance')\n\n    # Extract the top 'k' nearest neighbors\n    top_k_neighbors = sorted_data.iloc[:k][['Latitude', 'Longitude']].values.tolist()\n\n    return top_k_neighbors", "compilation_passed": true, "time": 0.0033240318298339844, "tests_passed": true, "error": null}
{"code": "# Check if k is a non-negative integer\n    if k < 0 or not isinstance(k, int):\n        raise ValueError(\"k must be a non-negative integer\")\n\n    # Calculate distance between all points in data and target point\n    data['Distance'] = np.sqrt(\n        (data['Latitude'] - target[0])**2 + (data['Longitude'] - target[1])**2)\n    # Sort data by distance and return k nearest neighbors\n    result = data.sort_values('Distance').head(k)[['Latitude', 'Longitude']].values.tolist()\n    return result", "compilation_passed": true, "time": 0.0021369457244873047, "tests_passed": false, "error": "TypeError"}
{"code": "if not isinstance(k, int) or k < 0:\n        raise ValueError(\"k must be a non-negative integer.\")\n\n    if k == 0:\n        return []\n\n    target = np.array(target)\n\n    distance = np.sqrt(np.sum((data - target)**2, axis=1))\n    sorted_indices = np.argsort(distance)\n    nearest_neighbors = data.iloc[sorted_indices[:k]]\n    return nearest_neighbors.values.tolist()", "compilation_passed": true, "time": 0.0023789405822753906, "tests_passed": true, "error": null}
{"code": "try:\n        radius_earth = 6371  # radius of earth is 6371 km\n\n        if k < 0:\n            raise ValueError(\"The value of k must be non-negative.\")\n        elif k % 1 != 0:\n            raise ValueError(\"The value of k must be a non-negative integer.\")\n\n        if isinstance(data, pd.DataFrame):\n            latitudes = np.deg2rad(data['Latitude'])\n            longitudes = np.deg2rad(data['Longitude'])\n\n            if len(target) == 2:\n                target_latitude = np.deg2rad(target[0])\n                target_longitude = np.deg2rad(target[1])\n                distances = np.array([math.acos(np.cos(target_latitude) * np.cos(target_longitude) * np.cos(\n                    latitudes) * np.cos(longitudes) + np.cos(target_latitude) * np.sin(latitudes) * np.cos(\n                    target", "compilation_passed": false, "time": 0.0002319812774658203, "tests_passed": false, "error": "SyntaxError"}
{"code": "# Check that k is a non-negative integer\n    if k < 0 or not isinstance(k, int):\n        raise ValueError(\"k must be a non-negative integer\")\n\n    # Convert coordinates to radians\n    data_rad = np.radians(data)\n    target_rad = np.radians(target)\n\n    # Calculate distance using Haversine formula\n    distances = 2 * np.arcsin(\n        np.sqrt(\n            np.sin(np.radians((data_rad['Latitude'] - target_rad[0])/2)) ** 2 +\n            np.cos(np.radians(target_rad[0])) *\n            np.cos(np.radians(data_rad['Latitude'])) *\n            np.sin(np.radians((data_rad['Longitude'] - target_rad[1])/2)) ** 2\n        )\n    )\n\n    # Sort distances in ascending order and get indices of the k closest neighbors\n    indices = np.argsort(distances)[:k]\n\n    # Extract the k closest neighbors and", "compilation_passed": true, "time": 0.001544952392578125, "tests_passed": true, "error": null}
{"code": "# check if k is a non-negative integer\n    if not isinstance(k, int) or k < 0:\n        raise ValueError(\"k must be a non-negative integer.\")\n\n    # convert latitude and longitude to radians\n    target_latitude, target_longitude = math.radians(target[0]), math.radians(target[1])\n    data_latitude = np.radians(data['Latitude'])\n    data_longitude = np.radians(data['Longitude'])\n\n    # calculate the great-circle distance between target and every other point\n    d_latitude, d_longitude = data_latitude - target_latitude, data_longitude - target_longitude\n    a = np.sin(d_latitude/2)**2 + np.cos(target_latitude) * np.cos(data_latitude) * np.sin(d_longitude/2)**2\n    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))\n    distances = 6371", "compilation_passed": true, "time": 0.001603841781616211, "tests_passed": true, "error": null}
{"code": "# Check if k is a non-negative integer\n    if k < 0:\n        raise ValueError(\"k must be a non-negative integer.\")\n\n    # Convert Latitude and Longitude to radians\n    lat_rad = math.radians(target[0])\n    lng_rad = math.radians(target[1])\n\n    # Calculate distances between target and each data point\n    distances = np.sqrt(np.square((math.radians(data['Latitude']) - lat_rad)) + np.square((math.radians(data['Longitude']) - lng_rad)))\n\n    # Find the indices of the k nearest neighbors\n    nearest_indices = np.argsort(distances)[:k]\n\n    # Extract the coordinates of the k nearest neighbors\n    nearest_data = data.iloc[nearest_indices]\n\n    # Convert back to degrees\n    nearest_data = nearest_data.apply(lambda x: [math.degrees(x[0]), math.degrees(x[1])], axis=1)\n\n    # Return", "compilation_passed": true, "time": 0.001026153564453125, "tests_passed": false, "error": "TypeError"}
{"code": "if isinstance(k, int) and k >= 0:\n        if len(data) < 2:\n            raise ValueError(\"Dataset must have at least two rows to calculate distances.\")\n        if not isinstance(data, pd.DataFrame):\n            raise TypeError(\"Dataset must be a pandas DataFrame.\")\n        if len(data.columns) != 2:\n            raise ValueError(\"Dataset must have exactly two columns 'Latitude' and 'Longitude'.\")\n        if not isinstance(target, list) or len(target) != 2:\n            raise ValueError(\"Target must be a list of two values [Latitude, Longitude].\")\n        if not (isinstance(target[0], (int, float)) and isinstance(target[1], (int, float))):\n            raise ValueError(\"Values in target must be numeric.\")\n\n        def haversine_distance(lat1, lon1, lat2, lon2):\n            # Haversine formula for distance calculation\n            # radius of earth is 6371 km\n            lat1", "compilation_passed": true, "time": 0.0009253025054931641, "tests_passed": true, "error": null}
{"code": "# Check that 'k' is a non-negative integer\n    if not isinstance(k, int) or k < 0:\n        raise ValueError(\"k must be a non-negative integer.\")\n\n    # Convert latitude and longitude to radians\n    data_rad = np.radians(data)\n    target_rad = np.radians(target)\n\n    # Calculate the Haversine distance\n    lat_distance = np.sin((data_rad[:, 0] - target_rad[0]) / 2)**2\n    lon_distance = np.sin((data_rad[:, 1] - target_rad[1]) / 2)**2\n    distance = 2 * 6371 * np.arcsin(np.sqrt(lat_distance +\n                                            np.cos(data_rad[:, 0]) * np.cos(target_rad[0]) * lon_distance))\n\n    # Sort the distances and get the indices of the nearest neighbors\n    indices = distance.argsort()[:k]\n\n    # Return the nearest neighbors\n    neighbors = data.iloc", "compilation_passed": true, "time": 0.00115203857421875, "tests_passed": false, "error": "pandas.errors.InvalidIndexError"}
{"code": "try:\n        assert all(isinstance(coord, (int, float)) for coord in target), \"target values must be int or float\"\n        assert isinstance(k, int) and k >= 0, \"k must be a non-negative integer\"\n        assert all(isinstance(coord, (int, float)) for coord in target), \"target values must be int or float\"\n        assert all(isinstance(coord, (int, float)) for coord in target), \"target values must be int or float\"\n\n        # convert latitude and longitude to radians\n        target_lat, target_lon = np.radians(target[0]), np.radians(target[1])\n\n        # convert latitude and longitude to radians for each data point\n        data[\"LatitudeRad\"] = np.radians(data[\"Latitude\"])\n        data[\"LongitudeRad\"] = np.radians(data[\"Longitude\"])\n\n        # calculate the distances between the target and each data point\n        data[\"Distance\"] = np.sin((data[\"LatitudeRad\"] -", "compilation_passed": false, "time": 0.00021600723266601562, "tests_passed": false, "error": "SyntaxError"}
{"code": "# Raise ValueError if 'k' is not an integer or is negative.\n    if not isinstance(k, int) or k < 0:\n        raise ValueError(\"k must be a non-negative integer\")\n\n    # Use the Haversine formula to calculate the distance in kilometers between each data point and the target.\n    rad_target_lat, rad_target_lon = math.radians(target[0]), math.radians(target[1])\n    dlat = data['Latitude'].apply(lambda x: math.radians(x) - rad_target_lat)\n    dlon = data['Longitude'].apply(lambda x: math.radians(x) - rad_target_lon)\n    a = np.sin(dlat / 2)**2 + np.cos(rad_target_lat) * np.cos(data['Latitude'].apply(math.radians)) * np.sin(dlon / 2)**2\n    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))\n    distances", "compilation_passed": true, "time": 0.0016210079193115234, "tests_passed": false, "error": "NameError"}
{"code": "if k < 0:\n        raise ValueError(\"k must be a non-negative integer.\")\n\n    if type(k) != int:\n        raise ValueError(\"k must be a non-negative integer.\")\n\n    # Calculate distances for all points in data from target\n    distances = np.array([\n        haversine_distance(target[0], target[1], point[0], point[1]) for point in data\n    ])\n\n    # Sort indices by distances\n    indices = np.argsort(distances)\n\n    # Extract k nearest neighbors\n    nearest = data[indices[:k]]\n\n    return nearest.tolist()", "compilation_passed": true, "time": 0.0009028911590576172, "tests_passed": false, "error": "NameError"}
{"code": "# check k\n    if k < 0 or not isinstance(k, int):\n        raise ValueError(\"'k' must be a non-negative integer\")\n\n    radius = 6371  # radius of Earth in km\n    lat1, lon1 = target\n    target_lat, target_lon = math.radians(lat1), math.radians(lon1)\n\n    # calculate distances between target and each point in the dataset\n    distances = []\n    for index, row in data.iterrows():\n        lat, lon = row['Latitude'], row['Longitude']\n        lat2, lon2 = math.radians(lat), math.radians(lon)\n        dLat = lat2 - target_lat\n        dLon = lon2 - target_lon\n        a = math.sin(dLat / 2) ** 2 + math.cos(lat1) * math.cos(lat) * math.sin(dLon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1", "compilation_passed": false, "time": 0.00021409988403320312, "tests_passed": false, "error": "SyntaxError"}
{"code": "if k < 0 or not isinstance(k, int):\n        raise ValueError(\"k must be a non-negative integer\")\n\n    # Initialize an empty list to store the distances of the target point from the other data points\n    distances = []\n\n    # Calculate the distance between the target point and each data point in the dataset\n    for i in range(len(data)):\n        d_lat = math.radians(data.iloc[i, 0] - target[0])\n        d_long = math.radians(data.iloc[i, 1] - target[1])\n        a = (math.sin(d_lat / 2) * math.sin(d_lat / 2) +\n             math.cos(math.radians(target[0])) * math.cos(math.radians(data.iloc[i, 0])) *\n             math.sin(d_long / 2) * math.sin(d_long / 2))\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))", "compilation_passed": true, "time": 0.001096963882446289, "tests_passed": true, "error": null}
{"code": "if not isinstance(k, int) or k < 0:\n        raise ValueError(\"k must be a non-negative integer\")\n\n    radius = 6371\n\n    # Calculate the distance from target to each point in data\n    data['distance'] = np.sqrt(np.sum((data[['Latitude', 'Longitude']] - target) ** 2, axis=1))\n\n    # Sort the data in ascending order of distances from target\n    sorted_data = data.sort_values('distance')\n\n    # Return the 'k' nearest neighbors\n    return sorted_data.head(k)[['Latitude', 'Longitude']].values.tolist()", "compilation_passed": true, "time": 0.0039048194885253906, "tests_passed": true, "error": null}
{"code": "if not isinstance(k, int) or k < 0:\n        raise ValueError(\"k must be a non-negative integer\")\n\n    if k == 0:\n        return []\n\n    target_lat, target_lon = target\n    radius = 6371\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        \"\"\"\n        Calculate the Haversine distance in km between two points on the Earth's surface.\n\n        Parameters:\n        lat1 (float): Latitude of point 1.\n        lon1 (float): Longitude of point 1.\n        lat2 (float): Latitude of point 2.\n        lon2 (float): Longitude of point 2.\n\n        Returns:\n        float: Distance in kilometers between the two points.\n        \"\"\"\n        dlat = math.radians(lat2 - lat1)\n        dlon = math.radians(lon2 - lon1)\n        a = math.sin(dlat / 2) ** 2 + math.cos(math.radians(lat", "compilation_passed": false, "time": 0.0001888275146484375, "tests_passed": false, "error": "SyntaxError"}
{"code": "if not isinstance(k, int) or k < 0:\n        raise ValueError(\"k must be a non-negative integer\")\n\n    # define the radius of earth in kilometers\n    RADIUS_KM = 6371\n\n    # calculate the distance between target and each point in the dataset using the Haversine formula\n    data['distance'] = data[['Latitude', 'Longitude']].apply(lambda x: distance(target[0], target[1], x['Latitude'], x['Longitude']), axis=1)\n\n    # sort the dataset by distance and return the top 'k' nearest neighbors\n    nearest_neighbors = data.nlargest(k, 'distance')[['Latitude', 'Longitude']].values.tolist()\n    return nearest_neighbors", "compilation_passed": true, "time": 0.0012400150299072266, "tests_passed": false, "error": "NameError"}
{"code": "# Check that k is a non-negative integer.\n    if not isinstance(k, int) or k < 0:\n        raise ValueError(\"'k' must be a non-negative integer.\")\n\n    # Calculate the distance between each point in the dataset and the target point.\n    # Define radius of the Earth (in km)\n    radius = 6371\n    distances = []\n\n    for point in data[['Latitude', 'Longitude']].values:\n        distance = np.radians(point[0] - target[0])\n        lat_diff = np.radians(point[0]) - np.radians(target[0])\n        lon_diff = np.radians(point[1]) - np.radians(target[1])\n\n        a = np.sin(lat_diff / 2) ** 2 + np.cos(np.radians(target[0])) * np.cos(np.radians(point[0])) * np.sin(lon_diff / 2) ** 2\n        c = 2 * np.arctan2", "compilation_passed": true, "time": 0.0011298656463623047, "tests_passed": false, "error": "TypeError"}
{"code": "# Validate input data\n    if not isinstance(k, int):\n        raise ValueError(\"'k' must be an integer\")\n    if k < 0:\n        raise ValueError(\"'k' must be a non-negative integer\")\n    # Define radius of Earth in kilometers (assuming spherical Earth)\n    radius = 6371.0\n    # Calculate distances between target point and all points in data\n    distances = []\n    for i in range(len(data)):\n        d = geodistance(target[0], target[1], data['Latitude'].iloc[i], data['Longitude'].iloc[i], radius)\n        distances.append(d)\n    # Sort points by distance from target point\n    distances = np.array(distances)\n    indices = np.argsort(distances)\n    # Return the 'k' closest points\n    k = min(k, len(indices))  # Handle case where 'k' is greater than the number of points in data\n    closest_points = []\n    for i in range(k", "compilation_passed": false, "time": 0.00020694732666015625, "tests_passed": false, "error": "SyntaxError"}
{"code": "if not isinstance(k, int) or k < 0:\n        raise ValueError(\"k must be a non-negative integer.\")\n\n    if k == 0:\n        return []\n\n    # constants\n    radius = 6371  # Radius of the Earth in kilometers\n\n    # Convert the latitude and longitude of the target point into radians\n    lat1, lon1 = math.radians(target[0]), math.radians(target[1])\n\n    # Calculate the distance from each data point to the target point\n    distances = np.zeros(len(data))\n    for i, (_, point) in enumerate(data.iterrows()):\n        lat2, lon2 = math.radians(point['Latitude']), math.radians(point['Longitude'])\n        distance = math.acos(math.sin(lat1) * math.sin(lat2) + math.cos(lat1) * math.cos(lat2) * math.cos(lon1 - lon2))\n        distances[i] = distance * radius\n\n    # Get the indices", "compilation_passed": true, "time": 0.0010519027709960938, "tests_passed": true, "error": null}
{"code": "# Validate input\n    if not isinstance(k, int) or k < 0:\n        raise ValueError(\"k must be a non-negative integer\")\n\n    # Calculate distances from target to all points in dataset\n    distances = [distance(target, point) for point in data[['Latitude', 'Longitude']].values]\n    data['distance'] = distances\n\n    # Sort dataset by distances and get the 'k' nearest neighbors\n    nearest_neighbors = data.nsmallest(k, 'distance')\n\n    # Return the 'k' nearest neighbors as list of lists\n    return nearest_neighbors[['Latitude', 'Longitude']].values.tolist()", "compilation_passed": true, "time": 0.0009980201721191406, "tests_passed": false, "error": "NameError"}
{"code": "try:\n        # Check if the 'k' value is a negative integer or not an integer.\n        if not isinstance(k, int) or k < 0:\n            raise ValueError(\"k should be a non-negative integer.\")\n\n        # Get the number of rows in the data set.\n        row_count = len(data)\n\n        # Calculate the distance between the target and each point in the dataset.\n        distances = np.zeros(row_count)\n        for i in range(row_count):\n            lat1, lon1 = data['Latitude'].iloc[i], data['Longitude'].iloc[i]\n            lat2, lon2 = target[0], target[1]\n            distance = calculate_distance(lat1, lon1, lat2, lon2)\n            distances[i] = distance\n\n        # Get the indices of the 'k' nearest neighbors.\n        nearest_indices = np.argsort(distances)[:k]\n\n        # Get the coordinates of the nearest neighbors and return them as a list.\n        nearest_coords =", "compilation_passed": false, "time": 0.00019502639770507812, "tests_passed": false, "error": "SyntaxError"}
{"code": "if k < 0:\n        raise ValueError(\"k must be a non-negative integer\")\n\n    if not isinstance(k, int):\n        raise ValueError(\"k must be an integer\")\n\n    radius_of_earth = 6371\n    lat, lon = target\n\n    def calculate_distance(lat1, lon1):\n        lat1, lon1 = map(math.radians, [lat1, lon1])\n        lat2, lon2 = map(math.radians, [lat, lon])\n\n        distance = (math.sin((lat2 - lat1) / 2) ** 2 +\n                    math.cos(lat1) * math.cos(lat2) *\n                    math.sin((lon2 - lon1) / 2) ** 2)\n\n        return radius_of_earth * 2 * math.atan2(math.sqrt(distance), math.sqrt(1 - distance))\n\n    data[\"distance\"] = data[['Latitude', 'Longitude']].apply(lambda x: calculate_distance(*x)", "compilation_passed": false, "time": 0.00022912025451660156, "tests_passed": false, "error": "SyntaxError"}
{"code": "# Check if k is a non-negative integer\n    if not isinstance(k, int) or k < 0:\n        raise ValueError(\"'k' must be a non-negative integer.\")\n\n    # Calculate the distance between each point in the dataset and the target point\n    data['distance'] = np.sqrt((data['Latitude'] - target[0]) ** 2 + (data['Longitude'] - target[1]) ** 2)\n\n    # Sort the data by distance in ascending order\n    data.sort_values('distance', inplace=True)\n\n    # Extract the coordinates for the k nearest neighbors\n    neighbors = data[['Latitude', 'Longitude']][:k]\n\n    return neighbors.values.tolist()", "compilation_passed": true, "time": 0.003229856491088867, "tests_passed": true, "error": null}
{"code": "if not isinstance(k, int) or k < 0:\n        raise ValueError(\"'k' must be a non-negative integer.\")\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        \"\"\"\n        Calculate the Haversine distance between two points on a sphere.\n\n        Parameters:\n        lat1 (float): Latitude of the first point.\n        lon1 (float): Longitude of the first point.\n        lat2 (float): Latitude of the second point.\n        lon2 (float): Longitude of the second point.\n\n        Returns:\n        float: Haversine distance in kilometers.\n\n        Constants:\n        radius of earth is 6371 km\n        \"\"\"\n        radius = 6371  # Radius of the Earth in kilometers\n\n        # Convert latitude and longitude to radians\n        lat1 = math.radians(lat1)\n        lon1 = math.radians(lon1)\n        lat2 = math.radians(lat2)\n        lon2 = math.radians(lon", "compilation_passed": false, "time": 0.00015997886657714844, "tests_passed": false, "error": "SyntaxError"}
{"code": "if not isinstance(k, int) or k < 0:\n        raise ValueError(\"k must be a non-negative integer.\")\n    distance_list = []\n    for i, item in enumerate(data.values):\n        # distance = math.sqrt((target[0] - item[0]) ** 2 + (target[1] - item[1]) ** 2)\n        distance = distance_func(target[0], target[1], item[0], item[1])\n        distance_list.append([distance, [item[0], item[1]]])\n\n    distance_list = sorted(distance_list, key=lambda x: x[0])[:k]\n\n    return [distance_list[j][1] for j in range(k)]", "compilation_passed": true, "time": 0.0009620189666748047, "tests_passed": false, "error": "NameError"}
{"code": "# Validate the input parameters\n    if k < 0:\n        raise ValueError(\"k must be a non-negative integer.\")\n    if not isinstance(k, int):\n        raise ValueError(\"k must be an integer.\")\n\n    # Calculate the Euclidean distance between each point in the dataset and the target point\n    distances = np.linalg.norm(data - np.array(target), axis=1)\n\n    # Find the 'k' indices of the nearest neighbors in the dataset\n    nearest_neighbors = np.argpartition(distances, k)[:k]\n\n    # Extract the coordinates of the nearest neighbors\n    nearest_neighbors_coords = data.iloc[nearest_neighbors][['Latitude', 'Longitude']].values.tolist()\n\n    # Sort the nearest neighbors based on their distances from the target point\n    nearest_neighbors_coords = sorted(nearest_neighbors_coords, key=lambda x: distances[nearest_neighbors_coords.index(x)])\n\n    return nearest_neighbors", "compilation_passed": true, "time": 0.001277923583984375, "tests_passed": false, "error": "ValueError"}
{"code": "# Validate the input values.\n    if not isinstance(k, int):\n        raise ValueError(\"k must be an integer\")\n    if k < 0:\n        raise ValueError(\"k must be non-negative\")\n\n    # Calculate the distance between the target and each data point.\n    radius = 6371  # Radius of the Earth in kilometers\n    target_lat, target_lon = math.radians(target[0]), math.radians(target[1])\n\n    # Calculate the latitude and longitude of each data point in radians.\n    data['rad_lat'] = data['Latitude'].apply(math.radians)\n    data['rad_lon'] = data['Longitude'].apply(math.radians)\n\n    # Calculate the distance using the Haversine formula.\n    data['distance'] = np.sqrt(np.square(np.sin((target_lat - data['rad_lat'])/2)) + np.cos(target_lat) * np.cos(data['rad_lat']) * np.square(np.sin((target_lon", "compilation_passed": false, "time": 0.0002028942108154297, "tests_passed": false, "error": "SyntaxError"}
{"code": "if not isinstance(k, int) or k < 0:\n        raise ValueError(\"'k' must be a non-negative integer.\")\n\n    if not isinstance(data['Latitude'], pd.Series) or not isinstance(data['Longitude'], pd.Series):\n        raise ValueError(\"'data' must contain columns 'Latitude' and 'Longitude' as series of geographical coordinates.\")\n\n    # Calculate distance from each point to the target\n    def distance(lat1, lon1, lat2, lon2):\n        \"\"\"\n        Calculates the distance between two points in geographic coordinates using the Haversine formula.\n\n        Parameters:\n        lat1 (float): Latitude of point 1 in decimal degrees.\n        lon1 (float): Longitude of point 1 in decimal degrees.\n        lat2 (float): Latitude of point 2 in decimal degrees.\n        lon2 (float): Longitude of point 2 in decimal degrees.\n\n        Returns:\n        float: Distance between the two points in kilometers.\n\n        \"\"\"\n        radius = 6371\n        ", "compilation_passed": true, "time": 0.0009169578552246094, "tests_passed": true, "error": null}
{"code": "if not isinstance(k, int) or k < 0:\n        raise ValueError(\"'k' must be a non-negative integer.\")\n    data = data.copy()\n    data['distance'] = np.sqrt((data['Latitude'] - target[0]) ** 2 + (data['Longitude'] - target[1]) ** 2)\n    neighbors = data.nsmallest(k, 'distance')\n    nearest_neighbors = neighbors[['Latitude', 'Longitude']].values.tolist()\n    return nearest_neighbors", "compilation_passed": true, "time": 0.004044771194458008, "tests_passed": true, "error": null}
