{"code": " [np.nanmean(data_list, axis=0)[i] for i in range(len(unzipped_data))]", "compilation_passed": true, "time": 0.030383825302124023, "tests_passed": false, "error": "TypeError"}
{"code": " [np.nanmean(row, dtype=float) for row in unzipped_data]", "compilation_passed": true, "time": 0.020684003829956055, "tests_passed": false, "error": "TypeError"}
{"code": " [np.mean(row[row[:] != 'nan']) for row in unzipped_data]", "compilation_passed": true, "time": 0.012408971786499023, "tests_passed": false, "error": "TypeError"}
{"code": " [np.nanmean([item for item in row if np.isreal(item)]) for row in unzipped_data]", "compilation_passed": true, "time": 0.002666950225830078, "tests_passed": true, "error": null}
{"code": " [np.nanmean(value_list) for value_list in unzipped_data if isinstance(value_list[0], (int, float))]", "compilation_passed": true, "time": 0.005742073059082031, "tests_passed": true, "error": null}
{"code": " np.nanmean(", "compilation_passed": false, "time": 0.00013375282287597656, "tests_passed": false, "error": "SyntaxError"}
{"code": " [np.nanmean(data) if np.issubdtype(type(data), np.number) else np.nan for data in unzipped_data]", "compilation_passed": true, "time": 0.004211902618408203, "tests_passed": true, "error": null}
{"code": " [np.mean(values) if all(map(lambda x: not np.isnan(x), row)) else np.nan for row in unzipped_data]", "compilation_passed": true, "time": 0.012225866317749023, "tests_passed": false, "error": "TypeError"}
{"code": " [np.nanmean([val for val in row if np.issubdtype(type(val), np.number)]) for row in unzipped_data]", "compilation_passed": true, "time": 0.0024330615997314453, "tests_passed": true, "error": null}
{"code": " [np.mean(values) if np.issubdtype(values.dtype, np.number) else np.nan for values in unzipped_data]", "compilation_passed": true, "time": 0.01036691665649414, "tests_passed": false, "error": "AttributeError"}
{"code": " [np.mean([float(val) for val in row if np.isreal(float(val))]) for row in unzipped_data]", "compilation_passed": true, "time": 0.014489889144897461, "tests_passed": false, "error": "ValueError"}
{"code": " [np.nanmean(values) for values in unzipped_data if np.isreal(values[0])]", "compilation_passed": true, "time": 0.004455089569091797, "tests_passed": true, "error": null}
{"code": " []", "compilation_passed": true, "time": 0.00413203239440918, "tests_passed": true, "error": null}
{"code": " [np.nanmean(values) for values in unzipped_data if np.issubdtype(type(values[0]), np.number)]", "compilation_passed": true, "time": 0.004480123519897461, "tests_passed": true, "error": null}
{"code": " [np.nanmean(unzipped_data[i]) for i in range(len(unzipped_data))]", "compilation_passed": true, "time": 0.013432025909423828, "tests_passed": false, "error": "TypeError"}
{"code": " np.ma.mean(np.array(unzipped_data), axis=0).tolist()", "compilation_passed": true, "time": 0.010694265365600586, "tests_passed": false, "error": "TypeError"}
{"code": " [np.nanmean(values) for values in unzipped_data if np.isnumeric(values[0])]", "compilation_passed": true, "time": 0.012691974639892578, "tests_passed": false, "error": "AttributeError"}
{"code": " [np.nanmean(np.array(entry)[:, np.isreal(entry)]) for entry in unzipped_data]", "compilation_passed": true, "time": 0.014228105545043945, "tests_passed": false, "error": "TypeError"}
{"code": " [np.nanmean([val for val in row if isinstance(val, (int, float))]) for row in unzipped_data]", "compilation_passed": true, "time": 0.0035448074340820312, "tests_passed": true, "error": null}
{"code": " [np.nanmean(values) for values in unzipped_data if not np.isnan(np.mean(values))]", "compilation_passed": true, "time": 0.01223134994506836, "tests_passed": false, "error": "TypeError"}
{"code": " [np.nanmean([float(v) for v in pos if v is not np.nan]) for pos in unzipped_data]", "compilation_passed": true, "time": 0.011367082595825195, "tests_passed": false, "error": "ValueError"}
{"code": " [np.nanmean(row) for row in unzipped_data]", "compilation_passed": true, "time": 0.013155221939086914, "tests_passed": false, "error": "TypeError"}
{"code": " [np.nanmean(value) if is_numeric(value) else np.nan for value in unzipped_data]", "compilation_passed": true, "time": 0.009129047393798828, "tests_passed": false, "error": "NameError"}
{"code": " np.nanmean(np.asarray(unzipped_data), axis=0)", "compilation_passed": true, "time": 0.010719776153564453, "tests_passed": false, "error": "TypeError"}
{"code": " [np.nanmean(vals) if any(np.issubdtype(t.dtype, np.number) for t in vals) else np.nan for vals in unzipped_data]", "compilation_passed": true, "time": 0.010540008544921875, "tests_passed": false, "error": "AttributeError"}
{"code": " [np.nanmean(x) for x in zip(*unzipped_data)]", "compilation_passed": true, "time": 0.012944936752319336, "tests_passed": false, "error": "TypeError"}
{"code": " [np.nanmean([value for value in row if np.isreal(value)], axis=0) for row in unzipped_data]", "compilation_passed": true, "time": 0.0025091171264648438, "tests_passed": true, "error": null}
{"code": " np.mean(unzipped_data, axis=0)", "compilation_passed": true, "time": 0.008722066879272461, "tests_passed": false, "error": "TypeError"}
