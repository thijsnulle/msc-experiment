{"code": "# Make sure the directory exists and is valid\n    if not os.path.isdir(directory):\n        print(\"Error: Directory '{}' does not exist or is invalid.\".format(directory))\n        return\n\n    # Combine the file_pattern and the suffix into a regular expression pattern\n    pattern = re.compile(file_pattern + suffix)\n\n    # Generate a list of matching files based on the given pattern\n    files = glob.glob(os.path.join(directory, file_pattern + suffix))\n\n    # Convert the file names to a list of MIME types using the mimetypes.guess_type() function\n    mime_types = {}\n    for filename in files:\n        mime_type = mimetypes.guess_type(filename)[0]\n        if mime_type:\n            mime_types[filename] = mime_type\n\n    return mime_types", "compilation_passed": true, "time": 0.0012559890747070312, "tests_passed": false, "error": "TypeError"}
{"code": "file_names = glob.glob(f\"{directory}/{file_pattern}.{suffix}\")\n    mime_dict = {}\n\n    for file_name in file_names:\n        # TODO: Remove this line when working locally\n        # mime_type = mimetypes.guess_type(file_name)[0]\n        mime_type = mimetypes.guess_type(file_name)[1]\n        mime_dict[file_name] = mime_type\n\n    return mime_dict", "compilation_passed": true, "time": 0.00115203857421875, "tests_passed": true, "error": null}
{"code": "try:\n        result = {}\n        for file_name in glob.glob(f\"{directory}/{file_pattern}\"):\n            with open(file_name, 'rb') as f:\n                result[file_name] = mimetypes.guess_type(file_name)[0]\n\n    except Exception:\n        print('An error occurred while scanning the file.')\n        exit(-1)\n    else:\n        return result", "compilation_passed": true, "time": 0.0011920928955078125, "tests_passed": false, "error": "SystemExit"}
{"code": "result = {}\n\n    for file in glob.glob(os.path.join(directory, file_pattern)):\n        file_name = os.path.basename(file)\n        if re.search(file_name, suffix):\n            file_type = mimetypes.guess_type(file)[0]\n            if file_type is not None:\n                result[file_name] = file_type\n\n    return result", "compilation_passed": true, "time": 0.0012230873107910156, "tests_passed": true, "error": null}
{"code": "file_types = dict()\n    # Convert file_pattern and suffix to regular expressions\n    pattern = re.compile(file_pattern)\n    suffix_regex = re.compile(f'.*{suffix}$')\n\n    # Check if directory exists\n    if not os.path.exists(directory):\n        print(f'Error: Directory {directory} does not exist.')\n        return file_types\n\n    for file_name in glob.glob(os.path.join(directory, f'*{pattern}')):\n        file = open(file_name)\n        file_type = mimetypes.guess_type(file.name)[0]\n        if file_type is not None and file_type.startswith(('text', 'application')):\n            file_types[file_name] = file_type\n        file.close()\n\n    return file_types", "compilation_passed": true, "time": 0.0017070770263671875, "tests_passed": false, "error": "re.error"}
{"code": "result = {}\n\n    for file in glob.glob(directory + '/*' + file_pattern):\n        if not os.path.isfile(file):  # if not a file, skip\n            continue\n        if not file.endswith(suffix):\n            continue\n        # this is the file that needs to be examined\n        # We want to know the file type by using mimetypes\n        # mimetypes.guess_type() takes a string and returns a tuple.\n        # This tuple contains the MIME type and a subtype.\n        # We take the first entry of the tuple and store it as the MIME type, then return it.\n        result[os.path.basename(file)] = mimetypes.guess_type(file)[0]\n\n    return result", "compilation_passed": true, "time": 0.0012478828430175781, "tests_passed": true, "error": null}
{"code": "file_list = glob.glob(os.path.join(directory, file_pattern))\n\n    mime_types = {}\n\n    for file_path in file_list:\n        if os.path.isfile(file_path):\n            with open(file_path, 'rb') as f:\n                try:\n                    mime_type = mimetypes.guess_type(file_path)[0]\n                    mime_types[os.path.basename(file_path)] = mime_type\n                except (IOError, ValueError):\n                    # If there's an error reading the file or parsing its MIME type, don't add it to the dictionary\n                    continue\n\n    return mime_types", "compilation_passed": true, "time": 0.001190185546875, "tests_passed": true, "error": null}
{"code": "file_pattern = rf'**/{file_pattern}' if '/' not in file_pattern else file_pattern\n    matches = glob.glob(os.path.join(directory, file_pattern), recursive=True)\n    matching_files = [x for x in matches if x.endswith(suffix) and os.path.isfile(x)]\n    mime_types = {os.path.basename(f): mimetypes.guess_type(f) for f in matching_files}\n    return mime_types", "compilation_passed": true, "time": 0.0011830329895019531, "tests_passed": true, "error": null}
{"code": "# TODO: Implement the function task_func\n\n    return {}", "compilation_passed": true, "time": 0.001024007797241211, "tests_passed": true, "error": null}
{"code": "pattern = file_pattern\n    suffix = suffix\n    mime_dict = {}\n\n    for filename in glob.glob(os.path.join(directory, pattern)):\n        if filename.endswith(suffix):\n            mime_dict[filename] = mimetypes.guess_type(filename)[0]\n\n    return mime_dict", "compilation_passed": true, "time": 0.0013091564178466797, "tests_passed": true, "error": null}
{"code": "file_names = glob.glob(directory + \"/\" + file_pattern)\n    file_types = {}\n    for file_name in file_names:\n        if os.path.isfile(file_name) and file_name.endswith(suffix):\n            file_type = mimetypes.guess_type(file_name)[0]\n            file_types[file_name] = file_type\n    return file_types", "compilation_passed": true, "time": 0.0010998249053955078, "tests_passed": true, "error": null}
{"code": "result = {}\n    file_list = glob.glob(os.path.join(directory, file_pattern))\n    for file in file_list:\n        result[file] = mimetypes.guess_type(file)[0]\n    result = {\n        key: value for key, value in result.items() if key.endswith(suffix)\n    }\n    return result", "compilation_passed": true, "time": 0.0011281967163085938, "tests_passed": true, "error": null}
{"code": "files = glob.glob(f'{directory}/{file_pattern}')\n    mimetype_dict = {}\n    for file in files:\n        if file.endswith(suffix):\n            mimetype_dict[file] = mimetypes.guess_type(file)[0]\n    return mimetype_dict", "compilation_passed": true, "time": 0.0010979175567626953, "tests_passed": true, "error": null}
{"code": "# Convert the suffix argument into a regular expression object\n    suffix_re = re.compile(suffix)\n    # Find all files in the specified directory matching the given pattern\n    files = glob.glob(directory + '\\\\' + file_pattern)\n    # Filter out any files that don't match the given suffix\n    files = [f for f in files if suffix_re.search(os.path.basename(f))]\n    # Return a dictionary of file names to their MIME types\n    return {f: mimetypes.guess_type(f)[0] for f in files}", "compilation_passed": true, "time": 0.0023641586303710938, "tests_passed": true, "error": null}
{"code": "results = {}\n    for filename in glob.iglob(os.path.join(directory, file_pattern)):\n        if suffix and filename.endswith(suffix):\n            with open(filename, 'rb') as f:\n                results[filename] = mimetypes.guess_type(filename)[0]\n        else:\n            with open(filename, 'rb') as f:\n                results[filename] = mimetypes.guess_type(filename)[0]\n    return results", "compilation_passed": true, "time": 0.0011830329895019531, "tests_passed": true, "error": null}
{"code": "mime_types_dict = {}\n    file_pattern = r'/'.join(\n        [\n            r'.*\\.',\n            f'^{file_pattern}$',\n            r'_',\n            f'$^{suffix}$',\n        ]\n    )\n    for path in glob.glob(os.path.join(directory, file_pattern)):\n        if os.path.isfile(path):\n            mime_types_dict[os.path.basename(path)] = mimetypes.guess_type(path)[0]\n    return mime_types_dict", "compilation_passed": true, "time": 0.0011258125305175781, "tests_passed": true, "error": null}
{"code": "return {filename: mimetypes.guess_type(filename)[0] for filename in glob.glob(os.path.join(directory, file_pattern)) if filename.endswith(suffix)}", "compilation_passed": true, "time": 0.0010600090026855469, "tests_passed": true, "error": null}
{"code": "mime_dict = {}\n    for file_name in glob.glob(os.path.join(directory, file_pattern)):\n        if file_name.endswith(suffix):\n            file_type = mimetypes.guess_type(file_name)[0]\n            if file_type:\n                mime_dict[file_name] = file_type\n    return mime_dict", "compilation_passed": true, "time": 0.0010700225830078125, "tests_passed": true, "error": null}
{"code": "files = glob.glob(os.path.join(directory, file_pattern))\n    mime_dict = dict()\n    for file_path in files:\n        if file_path.endswith(suffix):\n            file_name = file_path.split('\\\\')[-1]\n            mime_dict[file_name] = mimetypes.guess_type(file_path)[0]\n    return mime_dict", "compilation_passed": true, "time": 0.0012431144714355469, "tests_passed": true, "error": null}
{"code": "files = glob.glob(os.path.join(directory, file_pattern))\n    result = {}\n    for file_path in files:\n        file_name = os.path.basename(file_path)\n        if file_name.endswith(suffix):\n            mime_type = mimetypes.guess_type(file_path)\n            result[file_name] = mime_type[0]\n    return result", "compilation_passed": true, "time": 0.00127410888671875, "tests_passed": true, "error": null}
{"code": "try:\n        if os.path.isdir(directory):\n            files = glob.glob(os.path.join(directory, file_pattern))\n\n            file_types = {}\n            for file in files:\n                if file.endswith(suffix):\n                    mime_type = mimetypes.guess_type(file)[0]\n                    if mime_type:\n                        file_types[os.path.basename(file)] = mime_type\n\n            return file_types\n        else:\n            raise Exception(f\"The specified path '{directory}' is not a directory or does not exist.\")\n\n    except Exception as e:\n        raise Exception(f\"Error: {e}\")", "compilation_passed": true, "time": 0.0012297630310058594, "tests_passed": false, "error": "Exception"}
{"code": "file_type_dict = {}\n    for file_name in glob.glob(f'{directory}/{file_pattern}'):\n        if file_name.endswith(suffix):\n            file_type_dict[file_name] = mimetypes.guess_type(file_name)[0]\n    return file_type_dict", "compilation_passed": true, "time": 0.0011250972747802734, "tests_passed": true, "error": null}
{"code": "file_names = glob.glob(directory + file_pattern)\n    mime_types = dict()\n    for name in file_names:\n        if os.path.isfile(name):\n            if suffix not in name:\n                continue\n            mime_types[name] = mimetypes.guess_type(name)[0]\n\n    return mime_types", "compilation_passed": true, "time": 0.001110076904296875, "tests_passed": true, "error": null}
{"code": "try:\n        files = glob.glob(os.path.join(directory, file_pattern))\n    except TypeError as exc:\n        raise Exception(f\"Something went wrong while scanning the directory: {exc}\")\n    mimetypes.init()\n    filetypes_dict = {}\n    for fname in files:\n        fname = os.path.basename(fname)\n        if fname.endswith(suffix):\n            filetypes_dict[fname] = mimetypes.guess_type(fname)[0]\n    return filetypes_dict", "compilation_passed": true, "time": 0.0023109912872314453, "tests_passed": true, "error": null}
{"code": "mime_mapping = {}\n\n    file_paths = glob.glob(directory + file_pattern + '.' + suffix)\n    for path in file_paths:\n        if not os.path.exists(path):\n            continue\n        mime_mapping[path] = mimetypes.guess_type(path)[0]\n\n    return mime_mapping", "compilation_passed": true, "time": 0.0011398792266845703, "tests_passed": true, "error": null}
{"code": "file_pattern = f'**/{file_pattern}'\n\n    mime_types_dict = {}\n    for root, _, files in os.walk(directory):\n        for file in files:\n            file_path = os.path.join(root, file)\n            if file_path.endswith(suffix):\n                mime_type = mimetypes.guess_type(file_path)[0]\n                mime_types_dict[file] = mime_type\n    return mime_types_dict", "compilation_passed": true, "time": 0.0011310577392578125, "tests_passed": true, "error": null}
{"code": "file_paths = glob.glob(f\"{directory}{file_pattern}\")\n\n    mime_dict = {}\n\n    for file in file_paths:\n        mime = mimetypes.guess_type(file)[0]\n        mime = mime.split('/')[0] if mime else None\n        if mime == 'text':\n            mime = 'application/x-python'\n\n        if mime:\n            mime_dict[file] = mime\n\n    return mime_dict", "compilation_passed": true, "time": 0.0011310577392578125, "tests_passed": true, "error": null}
{"code": "mime_types = dict()\n    for file_name in glob.glob(os.path.join(directory, file_pattern)):\n        if file_name.endswith(suffix):\n            mime_type = mimetypes.guess_type(file_name)\n            mime_types[file_name] = mime_type[0]\n    return mime_types", "compilation_passed": true, "time": 0.0011882781982421875, "tests_passed": true, "error": null}
{"code": "result = {}\n    for filename in glob.glob(os.path.join(directory, file_pattern)):\n        if os.path.isfile(filename) and filename.endswith(suffix):\n            try:\n                with open(filename, 'rb') as f:\n                    content = f.read()\n            except OSError:\n                continue\n            result[filename] = mimetypes.guess_type(filename)[0]\n    return result", "compilation_passed": true, "time": 0.0011599063873291016, "tests_passed": true, "error": null}
{"code": "matching_files = glob.glob(os.path.join(directory, file_pattern))\n    return {file: mimetypes.guess_type(file, True) for file in matching_files if file.endswith(suffix)}", "compilation_passed": true, "time": 0.0010960102081298828, "tests_passed": true, "error": null}
