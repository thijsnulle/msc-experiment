{"code": "try:\n        if req_data == None:\n            return 'Invalid Data'\n\n        if isinstance(req_data, str) or isinstance(req_data, int) or isinstance(req_data, float):\n            return str(req_data)\n\n        if isinstance(req_data, dict):\n            # Sort the keys of the dictionary alphabetically\n            sorted_keys = sorted(req_data.keys())\n\n            # Create a string that consists of sorted keys and values joined by '&'\n            string_to_sign = '&'.join([str(key) + '=' + str(req_data[key]) for key in sorted_keys])\n            print(string_to_sign)\n\n            # Generate the HMAC signature using HMAC with the secret key and SHA256\n            signature = hmac.new(secret_key.encode(), string_to_sign.encode(), hashlib.sha256).hexdigest()\n\n            # Encode the signature\n            encoded_signature = urllib.parse.quote(signature, safe='', encoding='utf-8')\n", "compilation_passed": false, "time": 0.00021195411682128906, "tests_passed": false, "error": "SyntaxError"}
{"code": "if isinstance(req_data, dict):\n        signature = hmac.new(\n            secret_key.encode(),\n            (json.dumps(req_data, sort_keys=True)).encode(),\n            hashlib.sha256,\n        )\n        encoded = urllib.parse.quote(signature.hexdigest())\n        return encoded\n\n    raise TypeError(f\"req_data must be a dict, not {type(req_data)}\")", "compilation_passed": true, "time": 0.0009770393371582031, "tests_passed": true, "error": null}
{"code": "if isinstance(req_data, dict):\n        # Construct the URL encoded string to be signed\n        encoded_data = ''.join(f\"{key}:{req_data[key]}\" for key in sorted(req_data))\n\n        # Use HMAC to generate the signature\n        hmac_hash = hmac.new(secret_key.encode(), encoded_data.encode(), hashlib.sha256)\n        signature = hmac_hash.hexdigest()\n\n        # URL encode the signature and replace spaces with '+'\n        url_encoded = urllib.parse.quote(signature).replace(' ', '+')\n\n        # Return the result\n        return url_encoded\n    else:\n        raise TypeError(\"req_data must be a dictionary.\")", "compilation_passed": true, "time": 0.0010809898376464844, "tests_passed": true, "error": null}
{"code": "if not isinstance(req_data, dict):\n        raise TypeError(\"The request data should be a dictionary.\")\n\n    url_encoded_req_data = urllib.parse.urlencode(req_data)\n    hmac_signature = hmac.new(secret_key.encode(), url_encoded_req_data.encode(), hashlib.sha256).hexdigest()\n    return urllib.parse.quote(hmac_signature.replace(' ', '+'))", "compilation_passed": true, "time": 0.000965118408203125, "tests_passed": true, "error": null}
{"code": "if not isinstance(req_data, dict):\n        raise TypeError('req_data must be a dictionary')\n    sorted_keys = sorted(req_data)\n    urlencoded = '&'.join([f'{key}={req_data[key]}' for key in sorted_keys])\n    encoded_data = urlencoded.encode('utf-8')\n    encoded_signature = hmac.new(secret_key.encode('utf-8'), msg=encoded_data, digestmod=hashlib.sha256).digest()\n    url_encoded = urllib.parse.quote(encoded_signature)\n    return url_encoded", "compilation_passed": true, "time": 0.0010008811950683594, "tests_passed": true, "error": null}
{"code": "if not isinstance(req_data, dict):\n        raise TypeError('req_data must be a dictionary')\n\n    json_data = json.dumps(req_data).encode()\n    hashed = hmac.new(secret_key.encode(), json_data, hashlib.sha256).hexdigest()\n    return urllib.parse.quote(hashed.replace(' ', '+'))", "compilation_passed": true, "time": 0.000926971435546875, "tests_passed": true, "error": null}
{"code": "if not isinstance(req_data, dict):\n        raise TypeError(\"The request data must be a dictionary\")\n    hashed = hmac.new(secret_key.encode(),\n                      json.dumps(req_data, sort_keys=True).encode(),\n                      hashlib.sha256).hexdigest()\n    signature = urllib.parse.quote_plus(hashed)\n    return signature", "compilation_passed": true, "time": 0.0009489059448242188, "tests_passed": true, "error": null}
{"code": "if not isinstance(req_data, dict):\n        raise TypeError('req_data should be dict')\n    signature = hmac.new(\n        secret_key.encode(),\n        msg=json.dumps(req_data, sort_keys=True).encode('utf-8'),\n        digestmod=hashlib.sha256,\n    ).hexdigest()\n    return urllib.parse.quote(signature, safe='~')", "compilation_passed": true, "time": 0.0009539127349853516, "tests_passed": true, "error": null}
{"code": "if not isinstance(req_data, dict):\n        raise TypeError(\"req_data must be a dictionary\")\n\n    # Create a dictionary from the request data with only the necessary keys\n    req_dict = {'method': req_data['method'],\n                'url': urllib.parse.urlunsplit(req_data['url'].split(' ')[1]),\n                'headers': req_data['headers'],\n                'body': req_data['body'],\n                'version': req_data['version'],\n                }\n\n    # Create a HMAC signature using the secret key and the request data dictionary\n    signing_key = hmac.new(secret_key.encode(), '').digest()\n    req_data_bytes = json.dumps(req_dict).encode()\n    hmac_digest = hmac.new(signing_key, req_data_bytes, hashlib.sha256).digest()\n    signature = base64.b64encode(hmac_digest).decode().replace(' ', '+')\n", "compilation_passed": true, "time": 0.00102996826171875, "tests_passed": false, "error": "KeyError"}
{"code": "# Ensure `req_data` is a dictionary\n    if not isinstance(req_data, dict):\n        raise TypeError(\"`req_data` should be a dictionary\")\n\n    # Convert the request data to a string\n    req_data_str = json.dumps(req_data, sort_keys=True)\n\n    # Generate the HMAC signature using SHA256\n    hmac_obj = hmac.new(secret_key.encode(), req_data_str.encode(), hashlib.sha256)\n    hmac_str = hmac_obj.hexdigest()\n\n    # Replace spaces in the HMAC string with '+'\n    hmac_str = urllib.parse.quote_plus(hmac_str)\n\n    # Return the HMAC string\n    return hmac_str", "compilation_passed": true, "time": 0.0009748935699462891, "tests_passed": true, "error": null}
{"code": "req_data = json.dumps(req_data)\n    signed = hmac.new(\n        secret_key.encode(),\n        req_data.encode(),\n        hashlib.sha256\n    ).digest()\n    return urllib.parse.quote(signed.replace(b' ', b'+'))", "compilation_passed": true, "time": 0.0009291172027587891, "tests_passed": true, "error": null}
{"code": "if not isinstance(req_data, dict):\n        raise TypeError(\"`req_data` should be a dict\")\n\n    signing_input = [\n        f\"{key}={urllib.parse.quote_plus(str(value))}\" for key, value in req_data.items()\n    ]\n    signing_input.sort()\n    signing_input.append(f\"secret_key={secret_key}\")\n\n    hmac_value = hmac.new(\n        secret_key.encode(),\n        digestmod=hashlib.sha256\n    )\n\n    hmac_value.update(\"&\".join(signing_input).encode())\n\n    signature = hmac_value.hexdigest()\n    signature = signature.replace(\"=\", \"\").replace(\" \", \"+\")\n    return signature", "compilation_passed": true, "time": 0.0011377334594726562, "tests_passed": true, "error": null}
{"code": "if not isinstance(req_data, dict):\n        raise TypeError(\"req_data must be a dictionary\")\n\n    signed = json.dumps(req_data, sort_keys=True).encode()\n\n    return urllib.parse.quote_plus(\n        hmac.new(secret_key.encode(), signed, hashlib.sha256).hexdigest().encode()\n    )", "compilation_passed": true, "time": 0.0009479522705078125, "tests_passed": true, "error": null}
{"code": "if not isinstance(req_data, dict):\n        raise TypeError('req_data must be a dictionary')\n    signing_input = ''.join(\n        key + str(value) for key, value in req_data.items()\n    )\n    hmac_signature = hmac.new(\n        secret_key.encode(),\n        signing_input.encode(),\n        hashlib.sha256\n    ).hexdigest()\n    return urllib.parse.urlencode(req_data).replace(' ', '+') + '&signature=' + hmac_signature", "compilation_passed": true, "time": 0.0009899139404296875, "tests_passed": true, "error": null}
{"code": "if not isinstance(req_data, dict):\n        raise TypeError(\"'req_data' should be a dictionary.\")\n\n    # convert req_data to a string and urlencode it\n    urlencoded_data = urllib.parse.urlencode(req_data)\n\n    # create the signature\n    signature = hmac.new(\n        secret_key.encode(), urlencoded_data.encode(), hashlib.sha256\n    ).hexdigest()\n\n    # encode signature and replace spaces with '+'\n    encoded_signature = signature.replace(' ', '+')\n\n    return encoded_signature", "compilation_passed": true, "time": 0.0009319782257080078, "tests_passed": true, "error": null}
{"code": "if isinstance(req_data, dict):\n        data = json.dumps(req_data).encode()\n        signature = hmac.new(\n            secret_key.encode(), data, hashlib.sha256\n        ).hexdigest()\n        return urllib.parse.quote_plus(signature.replace(' ', '+'))", "compilation_passed": true, "time": 0.0009176731109619141, "tests_passed": true, "error": null}
{"code": "# Check if the 'req_data' parameter is a dictionary\n    if not isinstance(req_data, dict):\n        raise TypeError(\"req_data must be a dictionary\")\n\n    # Sort the keys in the 'req_data' dictionary by natural ordering, then join them together into a string\n    data_str = '&'.join(\n        f'{key}={urllib.parse.quote_plus(str(req_data[key]))}' for key in sorted(req_data.keys())\n    )\n\n    # Calculate the HMAC signature\n    signature = hmac.new(secret_key.encode(), data_str.encode(), hashlib.sha256).hexdigest()\n\n    # URL encode the signature\n    encoded_signature = urllib.parse.quote_plus(signature).replace(' ', '+')\n\n    return encoded_signature", "compilation_passed": true, "time": 0.0009589195251464844, "tests_passed": true, "error": null}
{"code": "if not isinstance(req_data, dict):\n        raise TypeError('req_data should be a dictionary')\n\n    # Convert JSON-serializable request data to string\n    data_string = json.dumps(req_data, sort_keys=True)\n\n    # Sign the request data\n    signature = hmac.new(\n        secret_key.encode('utf-8'),\n        data_string.encode('utf-8'),\n        hashlib.sha256\n    ).hexdigest()\n\n    # URL-encode the signature\n    encoded_signature = urllib.parse.quote(signature)\n\n    # Replace spaces in the signature with '+'s\n    encoded_signature = encoded_signature.replace(' ', '+')\n\n    return encoded_signature", "compilation_passed": true, "time": 0.0009317398071289062, "tests_passed": true, "error": null}
{"code": "if not isinstance(req_data, dict):\n        raise TypeError(\"req_data should be a dictionary, but received {}\".format(type(req_data)))\n\n    req_data.update({'timestamp': str(int(time.time()))})\n\n    hmac_digest = hmac.new(secret_key.encode(), str(req_data).encode(), hashlib.sha256).digest()\n    signed = base64.urlsafe_b64encode(hmac_digest).decode().replace('=', '').replace('+', '-')\n    return urllib.parse.quote(signed)", "compilation_passed": true, "time": 0.0008950233459472656, "tests_passed": false, "error": "NameError"}
{"code": "if not isinstance(req_data, dict):\n        raise TypeError(\"req_data is not a dictionary\")\n\n    # Get the encoded string, sort keys, and then encode\n    encoded_string = json.dumps(req_data, sort_keys=True)\n    encoded_string = urllib.parse.quote(encoded_string, safe=\"\").replace(\" \", \"+\")\n    hashed = hmac.new(secret_key.encode(), encoded_string.encode(), hashlib.sha256).digest()\n    encoded_signature = urllib.parse.quote_plus(hashed.decode())\n    return encoded_signature", "compilation_passed": true, "time": 0.0009059906005859375, "tests_passed": false, "error": "UnicodeDecodeError"}
{"code": "if not isinstance(req_data, dict):\n        raise TypeError(\"req_data must be a dictionary\")\n    sorted_req_data = {k: req_data[k] for k in sorted(req_data.keys())}\n    json_req_data = json.dumps(sorted_req_data)\n    hmac_value = hmac.new(secret_key.encode(), json_req_data.encode(), hashlib.sha256).digest()\n    encoded_hmac_value = urllib.parse.quote(hmac_value.hex())\n    return encoded_hmac_value", "compilation_passed": true, "time": 0.0009679794311523438, "tests_passed": true, "error": null}
{"code": "if not isinstance(req_data, dict):\n        raise TypeError(\"req_data must be a dictionary\")\n\n    h_str = json.dumps(req_data).encode('utf-8')\n\n    digest = hmac.new(secret_key.encode('utf-8'), h_str, hashlib.sha256).hexdigest()\n    return urllib.parse.quote(digest.replace(\" \", \"+\"), safe=\"\")", "compilation_passed": true, "time": 0.0009129047393798828, "tests_passed": true, "error": null}
{"code": "try:\n        req_data = json.dumps(req_data).encode('utf-8')\n        req_signature = hmac.new(secret_key.encode('utf-8'), req_data, hashlib.sha256).hexdigest().upper()\n    except (TypeError, UnicodeDecodeError) as err:\n        raise TypeError(f\"Error occurred while signing request: {err}\")\n    req_signature = urllib.parse.quote(req_signature.replace(\" \", \"+\"))\n    return req_signature", "compilation_passed": true, "time": 0.0009229183197021484, "tests_passed": true, "error": null}
{"code": "if not isinstance(req_data, dict):\n        raise TypeError(\"req_data should be a dictionary\")\n\n    encoded_string = json.dumps(req_data, sort_keys=True)\n\n    encoded_string_with_spaces = encoded_string.replace(\" \", \"%20\")\n    signature = hmac.new(secret_key.encode(), encoded_string_with_spaces.encode(), hashlib.sha256).hexdigest()\n    url_encoded = urllib.parse.quote_plus(signature, safe='')\n    return url_encoded", "compilation_passed": true, "time": 0.0009849071502685547, "tests_passed": true, "error": null}
{"code": "if not isinstance(req_data, dict):\n        raise TypeError(\"req_data must be a dictionary\")\n    encoded_req_data = urllib.parse.urlencode(req_data).encode(\"utf-8\")\n    encoded_secret_key = secret_key.encode(\"utf-8\")\n    encoded_hmac_data = hmac.new(encoded_secret_key, encoded_req_data, hashlib.sha256).digest()\n    signature = urllib.parse.quote(encoded_hmac_data.decode(\"utf-8\").replace(\"+\", \" \"))\n    return signature", "compilation_passed": true, "time": 0.0008990764617919922, "tests_passed": false, "error": "UnicodeDecodeError"}
{"code": "if not isinstance(req_data, dict):\n        raise TypeError(\"req_data must be a dictionary\")\n\n    # Sign the request data using HMAC SHA256\n    req_data.update({'secretKey': secret_key})\n    hmac_digest = hmac.new(secret_key.encode('utf-8'), json.dumps(req_data, sort_keys=True).encode('utf-8'), hashlib.sha256).hexdigest()\n\n    # Encode the signature using URL encoding and replace spaces with '+'\n    encoded_signature = urllib.parse.quote(hmac_digest, safe='').replace(' ', '+')\n\n    return encoded_signature", "compilation_passed": true, "time": 0.001068115234375, "tests_passed": true, "error": null}
{"code": "try:\n        json.dumps(req_data)\n    except TypeError:\n        raise TypeError('req_data must be a dictionary')\n\n    sorted_data = sorted(req_data.items())\n    url_encoded_data = urllib.parse.urlencode(sorted_data)\n\n    signed_data = hmac.new(secret_key.encode(), url_encoded_data, hashlib.sha256).hexdigest()\n    return url_encoded_data.replace(\" \", \"+\")", "compilation_passed": true, "time": 0.001068115234375, "tests_passed": false, "error": "TypeError"}
{"code": "if not isinstance(req_data, dict):\n        raise TypeError(f\"req_data must be a dictionary, not {type(req_data)}\")\n    sorted_keys = list(req_data.keys())\n    sorted_keys.sort()\n    # Construct a sorted string containing the sorted keys and values\n    data_str = '&'.join([f\"{k}={urllib.parse.quote_plus(str(req_data[k]))}\" for k in sorted_keys])\n    # Construct the signature as a HMAC-SHA256 digest using the secret key\n    signature = hmac.new(secret_key.encode('utf-8'), data_str.encode('utf-8'), hashlib.sha256).hexdigest()\n    return urllib.parse.quote_plus(signature).replace(' ', '+')", "compilation_passed": true, "time": 0.0009911060333251953, "tests_passed": true, "error": null}
{"code": "if not isinstance(req_data, dict):\n        raise TypeError(\"req_data is not a dictionary\")\n    hmac_sig = hmac.new(\n        secret_key.encode('utf-8'),\n        str(req_data).encode('utf-8'),\n        hashlib.sha256\n    ).hexdigest()\n    hmac_encoded = urllib.parse.quote(hmac_sig.replace(\"+\", \"%20\").replace(\"/\", \"%2F\"))\n    return hmac_encoded", "compilation_passed": true, "time": 0.0009059906005859375, "tests_passed": true, "error": null}
{"code": "if isinstance(req_data, dict):\n        urlencoded_data = urllib.parse.urlencode(req_data)\n        signed_data = hmac.new(\n            secret_key.encode(), urlencoded_data, hashlib.sha256).hexdigest()\n        return '+'.join(signed_data.split('+'))", "compilation_passed": true, "time": 0.0009238719940185547, "tests_passed": false, "error": "TypeError"}
