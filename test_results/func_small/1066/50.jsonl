{"code": "data = np.random.normal(0, 1, num_samples)\n    ax = plt.hist(data, bins=10, density=True)\n    if num_outliers > 0:\n        outliers = np.random.uniform(-10, 10, size=num_outliers)\n        data = np.concatenate([data, outliers])\n        ax.set_title(\"Both normal and outlier data\")\n        ax.set_ylabel(\"Probability density\")\n        ax.set_xlabel(\"X\")\n    else:\n        ax.set_title(\"Only outlier data\")\n    return data, outliers_detected, ax", "compilation_passed": true, "time": 0.0032629966735839844, "tests_passed": false, "error": "AttributeError"}
{"code": "# Draw normally distributed data and add some outliers\n    data = np.random.normal(size=num_samples)\n    if num_outliers:\n        outliers = np.random.uniform(-10, 10, size=num_outliers)\n        data = np.concatenate([data, outliers])\n\n    # Sort the data\n    data.sort()\n\n    # Compute the IQR\n    Q1 = np.quantile(data, 0.25)\n    Q3 = np.quantile(data, 0.75)\n    IQR = Q3 - Q1\n\n    # Detect outliers using the IQR method\n    threshold = 1.5 * IQR\n    outliers_detected = np.where(np.abs(data) > threshold)\n\n    # Plot the histogram of the combined data\n    ax = plt.subplots(figsize=(8, 8))[1]\n    ax.hist(data, bins=20)\n\n    return data, outliers_detected, ax", "compilation_passed": true, "time": 0.016093015670776367, "tests_passed": true, "error": null}
{"code": "if num_samples <= 0:\n        data = np.array([])\n    else:\n        # Draw normally distributed data\n        data = np.random.normal(size=num_samples)\n\n    # Draw the outliers\n    if num_outliers == 0:\n        outliers_detected = np.array([])\n    else:\n        outliers_detected = np.random.uniform(-10, 10, num_outliers)\n\n    # Plot the histogram\n    ax = plt.subplot()\n    ax.hist(data)\n    ax.axvline(0, linewidth=1, color='gray', linestyle='--')\n    plt.hist(outliers_detected, color='r', alpha=0.5)\n    plt.show()\n\n    return data, outliers_detected, ax", "compilation_passed": true, "time": 0.015945911407470703, "tests_passed": true, "error": null}
{"code": "# ********************************************************************\n    # TODO: generate a dataset comprising both normal data and artificially\n    # introduced outliers, and plot a histogram of the combined data.\n    # The function detects outliers in the dataset using the Interquartile\n    # Range (IQR) method, but it only considers the normally distributed\n    # portion of the data for outlier detection.\n    # The outliers detected and the artificially introduced outliers might\n    # not always coincide.\n\n    # ********************************************************************\n    # TODO:\n    # Use numpy to generate a dataset comprising both normal data and\n    # artificially introduced outliers, and plot a histogram of the\n    # combined dataset. The function detects outliers in the dataset using\n    # the Interquartile Range (IQR) method, but it only considers the\n    # normally distributed portion of the data for outlier detection.\n    # The outliers detected and the artificially introduced outliers\n    # might not always coincide.\n\n    # ********************************************************************\n    # TODO:\n    # Use matplotlib to plot a histogram of the combined dataset, including\n    # both normally distributed data and the artificially introduced outliers.\n\n    # ****************", "compilation_passed": true, "time": 0.0009088516235351562, "tests_passed": false, "error": "TypeError"}
{"code": "if num_samples <= 0:\n        normal_data = []\n    else:\n        normal_data = np.random.normal(0, 1, size=num_samples)\n\n    if num_outliers <= 0:\n        artificial_outliers = []\n    else:\n        artificial_outliers = np.random.uniform(low=-10, high=10, size=num_outliers)\n\n    artificial_outliers = np.concatenate((artificial_outliers, normal_data))\n    outliers_detected = np.sort(artificial_outliers)[\n        NUM_SAMPLES - NUM_OUTLIERS:NUM_SAMPLES]\n\n    data = np.concatenate((normal_data, artificial_outliers))\n\n    # Create a histogram plot of the data using Matplotlib's histogram function\n    ax = plt.hist(data, bins=10, color='blue')[2]\n\n    return data, outliers_detected, ax", "compilation_passed": true, "time": 0.013822078704833984, "tests_passed": true, "error": null}
{"code": "# Generate normally distributed data\n    if num_samples <= 0:\n        # If no normal data, just generate the outliers\n        data = np.random.randint(-10, 11, (num_outliers, ))\n        # Create a histogram plot\n        fig, ax = plt.subplots()\n        ax.hist(data)\n        return data, np.array(data), ax\n    else:\n        # Generate normally distributed data\n        x = np.random.normal(0, 1, (num_samples, ))\n\n        # Create a histogram plot\n        fig, ax = plt.subplots()\n        ax.hist(x)\n\n        # Find the interquartile range (IQR)\n        q1 = np.quantile(x, 0.25)\n        q3 = np.quantile(x, 0.75)\n        iqr = q3 - q1\n\n        # Calculate the upper and lower thresholds\n        upper_bound = q3 + 1.5 * iqr\n        lower_bound = q1 - 1.5 * iqr\n\n", "compilation_passed": true, "time": 0.1748828887939453, "tests_passed": false, "error": "TypeError"}
{"code": "# TODO: Implement this function!\n    # raise Exception(\"You haven't implemented this function yet!\")\n    # Initialize variables\n    data = []\n    outliers_detected = []\n    iqr = None\n    lower_limit = None\n    upper_limit = None\n    # Draw normally distributed data\n    if num_samples > 0:\n        x = np.random.normal(0, 1, size=num_samples)\n        # Add normally distributed data to the data list\n        data.extend(x)\n        # Set the upper and lower limits\n        upper_limit = np.max(x)\n        lower_limit = np.min(x)\n\n    # Draw outlier points\n    if num_outliers > 0:\n        # Draw the randomly generated outlier points between -10 and 10\n        x_outliers = np.random.uniform(low=-10, high=10, size=num_outliers)\n\n        # Add the outlier points to the data list\n        data.extend(x_outliers)\n        # Set the upper and lower limits\n", "compilation_passed": true, "time": 0.0010640621185302734, "tests_passed": false, "error": "TypeError"}
{"code": "# Draw the normally distributed normal_data\n    normal_data = np.random.normal(scale=5, size=num_samples)\n\n    # Draw the randomly distributed outlier_data\n    outlier_data = np.random.uniform(low=-10, high=10, size=num_outliers)\n\n    # Concatenate both arrays\n    data = np.concatenate((normal_data, outlier_data))\n\n    # Sort the data in ascending order\n    sorted_data = np.sort(data)\n\n    # Calculate IQR for normal_data\n    q1, q3 = np.percentile(sorted_data, [25, 75])\n    iqr = q3 - q1\n\n    # Calculate outliers_detected for normal_data\n    outliers_detected = []\n    for i, point in enumerate(sorted_data):\n        if sorted_data[i] < q1 - 1.5 * iqr or sorted_data[i] > q3 + 1.5 * iqr:\n            outliers_detected.append(", "compilation_passed": false, "time": 0.0002231597900390625, "tests_passed": false, "error": "SyntaxError"}
{"code": "# Generate normally distributed data\n    normal_data = np.random.normal(0, 1, (num_samples, 2))\n    normal_data[:num_outliers] = np.random.uniform(-10, 10, (num_outliers, 2))\n\n    # Find the quartile ranges of the data and the IQR\n    quartile_ranges = np.percentile(normal_data, [25, 50, 75], axis=0)\n    iqr = quartile_ranges[2] - quartile_ranges[0]\n    lower_bound = quartile_ranges[0] - 1.5 * iqr\n    upper_bound = quartile_ranges[2] + 1.5 * iqr\n\n    # Calculate outliers\n    outliers_detected = normal_data[(lower_bound < normal_data) & (normal_data < upper_bound)]\n\n    # Plot histogram of combined data\n    fig, ax = plt.subplots()\n    ax.hist(normal_data, bins=20)\n    ax.ax", "compilation_passed": true, "time": 0.02177882194519043, "tests_passed": false, "error": "AttributeError"}
{"code": "np.random.seed(0)\n\n    # Create a dataset comprising both normally distributed data and artificially introduced outliers\n    if num_samples > 0:\n        # Generate normally distributed data\n        data = np.random.normal(loc=0, scale=1, size=num_samples)\n\n    # Create a dataset comprising both normally distributed data and artificially introduced outliers\n    if num_samples > 0 and num_outliers > 0:\n        # Add outliers randomly\n        outliers = np.random.uniform(-10, 10, size=num_outliers)\n\n        # Add outliers randomly\n        data = np.concatenate([data, outliers])\n\n    # Plot a histogram of the combined dataset\n    fig, ax = plt.subplots()\n    ax.hist(data, bins=NUM_SAMPLES)\n    ax.set_title('Dataset Histogram')\n    return data, outliers_detected, ax", "compilation_passed": true, "time": 0.029004812240600586, "tests_passed": false, "error": "NameError"}
{"code": "if num_samples <= 0:\n        raise Exception(\"Number of samples must be positive.\")\n\n    # Generate normal data and uniformly-distributed outliers\n    data = np.random.randn(num_samples) * 10\n    outliers_detected = np.random.randn(num_outliers) * 10\n    data[10:20] += outliers_detected\n\n    # Create a histogram plot of the combined dataset\n    fig, ax = plt.subplots()\n    ax.hist(data, bins=10)\n    ax.set_title(\"Histogram Plot of Combined Dataset\")\n    return data, outliers_detected, ax", "compilation_passed": true, "time": 0.013655900955200195, "tests_passed": true, "error": null}
{"code": "# Create a dataset with both normally distributed data and outliers\n    data = np.random.normal(size=num_samples + num_outliers)\n\n    # Add outliers to the dataset\n    for i in range(num_outliers):\n        data[i] = np.random.uniform(-10, 10)\n\n    # Calculate the IQR for the normally distributed data\n    q1, q3 = np.percentile(data, [25, 75])\n    iqr = q3 - q1\n\n    # Detect outliers in the normally distributed data\n    outliers_detected = data[np.abs(data - q1) > iqr]\n\n    # Plot a histogram of the combined dataset\n    fig, ax = plt.subplots()\n    ax.hist(data)\n    return data, outliers_detected, ax", "compilation_passed": true, "time": 0.013113260269165039, "tests_passed": true, "error": null}
{"code": "if num_samples <= 0:\n        outliers = np.random.uniform(low=-10, high=10, size=num_outliers)\n        outliers_detected = outliers\n    else:\n        # Generate normally distributed data\n        data = np.random.normal(loc=0, scale=10, size=num_samples)\n\n        # Introduce outliers\n        # Generate random indices\n        indices = np.random.choice(num_samples, size=num_outliers, replace=False)\n\n        # Generate random outliers\n        outliers = np.random.uniform(low=-10, high=10, size=num_outliers)\n\n        # Assign outliers to indices\n        outliers_detected = outliers[np.sort(indices)]\n        data[indices] = outliers_detected\n\n    # Plot histogram of combined dataset\n    fig, ax = plt.subplots()\n    ax.hist(data, bins=10, density=True)\n    ax.set_xlabel(\"x\")\n    ax.set_ylabel(\"PDF\")\n    ax.set", "compilation_passed": true, "time": 0.0010731220245361328, "tests_passed": false, "error": "IndexError"}
{"code": "# Generate normally distributed data\n    np.random.seed(0)\n    normal_data = np.random.normal(0.0, 1.0, num_samples)\n\n    # Generate outlier data\n    np.random.seed(0)\n    outlier_data = np.random.uniform(-10, 10, num_outliers)\n\n    # Merge the data into one list\n    data = normal_data + outlier_data\n\n    # Sort the data in ascending order\n    data.sort()\n\n    # Compute the Interquartile range (IQR)\n    q1, q3 = np.percentile(data, [25, 75])\n    iqr = q3 - q1\n\n    # Find the outliers\n    outliers_detected = np.empty(0)\n    for i in range(1, len(data) - 1):\n        if data[i] < q1 - 1.5 * iqr or data[i] > q3 + 1.5 * iqr:\n            outliers_detected = np.append(outliers", "compilation_passed": false, "time": 0.00022077560424804688, "tests_passed": false, "error": "SyntaxError"}
{"code": "# Normal distribution\n    if num_samples > 0:\n        # Generate samples from normal distribution\n        x = np.random.normal(0, 1, (num_samples,))\n\n        # Identify outliers using IQR method\n        iqr_x = np.percentile(x, [75, 25])\n        threshold = 1.5 * (iqr_x[1] - iqr_x[0])\n        outliers_detected = np.where(np.abs(x) > threshold)[0]\n    else:\n        # Generate artificial outliers\n        outliers_detected = np.random.uniform(low=-10, high=10, size=NUM_OUTLIERS)\n\n    # Create histogram\n    plt.figure()\n    plt.hist(x, density=True)\n    ax = plt.gca()\n    ax.set_xlabel('x')\n    ax.set_ylabel('Probability')\n    ax.set_title('Histogram of data')\n\n    data = x + outliers_detected\n    return data, outliers_detected, ax\n", "compilation_passed": true, "time": 0.01331782341003418, "tests_passed": true, "error": null}
{"code": "# Generate normally distributed data\n    normal_data = np.random.normal(scale=2, size=num_samples)\n\n    # Generate the number of outliers\n    uniform_sample = np.random.uniform(-10, 10, num_outliers)\n    outliers_detected = normal_data[num_samples:] + uniform_sample\n\n    # Plot a histogram\n    if num_samples == 0:\n        # If no normal data is generated, do not generate outliers\n        data = outliers_detected\n        ax = plt.axes()\n        ax.set_title('Generated dataset')\n        ax.set_xlabel('x')\n        ax.set_ylabel('Frequency')\n        ax.hist(outliers_detected, bins=10)\n    else:\n        # If normal data is generated, generate both data and outliers\n        data = np.concatenate((normal_data[:num_samples], outliers_detected))\n        ax = plt.subplots()[1]\n        ax.set_title('Generated dataset')\n        ax.set_xlabel('x')\n        ax.set_", "compilation_passed": true, "time": 0.0010480880737304688, "tests_passed": false, "error": "ValueError"}
{"code": "# Generate normal data\n    normal_data = np.random.normal(scale=1, size=num_samples)\n\n    # Generate randomly-generated outliers\n    outlier_data = np.random.uniform(low=-10, high=10, size=num_outliers)\n\n    # Concatenate the normal data and outliers\n    data = np.concatenate((normal_data, outlier_data))\n\n    # Plot the histogram of the combined data\n    _, ax = plt.subplots()\n    ax.hist(data, bins=50, density=True, label='combined data')\n\n    # Detect outliers using the IQR method\n    iqr = np.quantile(normal_data, 0.75) - np.quantile(normal_data, 0.25)\n    outliers_detected = data[np.abs(data - np.median(normal_data)) > iqr * 1.5]\n\n    return data, outliers_detected, ax", "compilation_passed": true, "time": 0.01926398277282715, "tests_passed": true, "error": null}
{"code": "# Generate normal data\n    if num_samples:\n        data = np.random.normal(0.0, 1.0, num_samples)\n        print(f\"Generated normal data with mean=0 and std=1.0.\\n\")\n    # Add outliers to the data\n    else:\n        data = np.zeros(num_samples)\n        print(\"Generated data with only outliers.\\n\")\n\n    # Get the IQR (Interquartile Range) of the data\n    q1 = np.percentile(data, 25)\n    q3 = np.percentile(data, 75)\n    iqr = q3 - q1\n\n    # Generate the outliers\n    outliers = np.random.uniform(q1 - (1.5 * iqr), q3 + (1.5 * iqr), size=num_outliers)\n\n    # Update the data with the outliers\n    data[np.random.choice(range(len(data)), num_outliers, replace=False)] = outliers\n\n    # Create an Axes object for the histogram\n", "compilation_passed": true, "time": 0.0020101070404052734, "tests_passed": false, "error": "TypeError"}
{"code": "# Generate normally distributed data\n    data = np.random.normal(size=num_samples)\n\n    # Draw outliers\n    outliers_detected = np.random.uniform(-10, 10, size=num_outliers)\n\n    # Plot the histogram\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.set_title('Normal data (100), outliers (5)')\n    ax.set_xlim(-10, 10)\n    ax.set_ylim(-1, 1)\n    ax.hist(data, bins=15)\n    ax.hist(outliers_detected, color='red', alpha=0.5)\n    ax.hist(np.sort(data), alpha=0.2)\n    return data, outliers_detected, ax", "compilation_passed": true, "time": 0.018777132034301758, "tests_passed": true, "error": null}
{"code": "data = np.random.rand(num_samples) * 20 - 10\n    if num_outliers > 0:\n        outliers = np.random.uniform(-10, 10, size=num_outliers)\n        data[num_samples:] = outliers\n\n    if num_samples > 0:\n        quartiles = np.quantile(data, (0.25, 0.75), interpolation='midpoint')\n        iqr = quartiles[1] - quartiles[0]\n        lower_outlier = quartiles[0] - 1.5 * iqr\n        upper_outlier = quartiles[1] + 1.5 * iqr\n        outliers = [\n            outlier\n            for outlier in outliers\n            if not (lower_outlier < outlier < upper_outlier)\n        ]\n\n        data = np.concatenate((data, np.array(outliers)))\n\n    ax = plt.hist(data, bins='auto', color='red', alpha=0.5, density=True)\n\n    return", "compilation_passed": true, "time": 0.0010962486267089844, "tests_passed": false, "error": "ValueError"}
{"code": "# Draw normally distributed data\n    if num_samples > 0:\n        x = np.random.normal(size=num_samples)\n    else:\n        x = np.array([])\n    # Add randomly distributed outliers\n    if num_outliers > 0:\n        y = np.random.rand(num_outliers) * 20 - 10\n        x = np.concatenate([x, y])\n    # Sort the dataset and detect outliers using the IQR method\n    x.sort()\n    num_samples = len(x)\n    quartile1 = np.percentile(x, 25)\n    quartile3 = np.percentile(x, 75)\n    iqr = quartile3 - quartile1\n    outliers = x[\n        (x > quartile3 + 1.5 * iqr) | (x < quartile1 - 1.5 * iqr)\n    ]\n    # Plot the histogram of the combined dataset\n    num_bins = 15\n    ax = plt.subplots()[1]\n    ax.hist(x,", "compilation_passed": false, "time": 0.0002391338348388672, "tests_passed": false, "error": "SyntaxError"}
{"code": "data = np.random.normal(loc=0.0, scale=1.0, size=num_samples + num_outliers)\n    if num_outliers > 0:\n        data[NUM_SAMPLES:] = np.random.uniform(-10, 10, size=num_outliers)\n    data = np.sort(data)\n\n    ax = plt.plot(data)\n    outliers_detected = np.zeros(NUM_SAMPLES + num_outliers)\n    return data, outliers_detected, ax", "compilation_passed": true, "time": 0.0008728504180908203, "tests_passed": false, "error": "ValueError"}
{"code": "# Create normally distributed data\n    x = np.random.normal(size=num_samples)\n\n    # Create uniformly distributed outliers\n    y = np.random.uniform(-10, 10, num_outliers)\n\n    # Combine the data into a single array\n    data = np.concatenate([x, y])\n\n    # Sort the combined data\n    data = np.sort(data)\n\n    # Calculate the interquartile range of the normally distributed data\n    q1 = np.quantile(data, 0.25)\n    q3 = np.quantile(data, 0.75)\n    iqr = q3 - q1\n\n    # Calculate the outliers using the IQR method\n    outliers = []\n    for i in range(NUM_SAMPLES - 1):\n        if data[i] < q1 - 1.5 * iqr or data[i] > q3 + 1.5 * iqr:\n            outliers.append(data[i])\n\n    outliers_detected = outliers\n\n    # Generate an axes object for the", "compilation_passed": true, "time": 0.00102996826171875, "tests_passed": false, "error": "IndexError"}
{"code": "data = np.random.normal(0.0, 1.0, num_samples)\n    if num_outliers > 0:\n        outliers = np.random.uniform(-10.0, 10.0, (num_outliers,))\n        data = np.concatenate((data, outliers))\n\n    # sort the data in ascending order and keep only the normal data points\n    sorted_data = np.sort(data)\n    normal_data_length = len(sorted_data)\n    if num_samples != 0:\n        normal_data_length = min(num_samples, normal_data_length)\n    data = sorted_data[:normal_data_length]\n\n    # calculate the IQR for the normal data\n    q1 = np.percentile(data, 25)\n    q3 = np.percentile(data, 75)\n    iqr = q3 - q1\n    print(\"IQR: %.3f\" % iqr)\n    # find the indices of the outliers\n    outliers_indices = np.flat", "compilation_passed": true, "time": 0.0011551380157470703, "tests_passed": false, "error": "AttributeError"}
{"code": "# Generate normally distributed data with mean 0 and standard deviation 1\n    normal_data = np.random.normal(0, 1, num_samples)\n    # Generate uniformly distributed outliers\n    outliers = np.random.uniform(-10, 10, num_outliers)\n\n    # Combine the data into a single array\n    data = np.concatenate([normal_data, outliers])\n\n    # Sort the data in ascending order\n    data.sort()\n\n    # Define the bin edges for the histogram\n    # 11 bins in [0, 20] for normal data and outliers\n    # 5 bins in [-20, -2.5] for normal data and outliers\n    # 3 bins in [-3.5, 0] for normal data and outliers\n    # 1 bins in [0.5, 2.5] for normal data and outliers\n    # 1 bins in [2.5, 3.5] for normal data and outliers\n    # 2 bins in [3.5, 4.5] for normal data and outliers\n    # 3 bins in [4.", "compilation_passed": true, "time": 0.0008063316345214844, "tests_passed": false, "error": "TypeError"}
{"code": "# Draw the normal data samples\n    if num_samples == 0:\n        return None\n\n    # Generate the normal data\n    x = np.random.normal(0, 1, num_samples)\n    x_norm_only = np.copy(x)\n\n    # Draw the artificially generated outliers\n    if num_outliers == 0:\n        return None, np.array([]), None\n\n    outliers = np.random.uniform(-10, 10, num_outliers)\n\n    # Add the outliers to the dataset\n    x = np.concatenate([x, outliers])\n\n    # Plot the data histogram\n    ax = plt.subplot()\n    ax.hist(x, bins=50)\n    return x, outliers, ax", "compilation_passed": true, "time": 0.019669055938720703, "tests_passed": true, "error": null}
{"code": "# Step 1: Generate normally distributed data\n    if num_samples > 0:\n        data = np.random.normal(size=(num_samples, 3))\n\n        # Step 2: Compute the IQR for the normally distributed data\n        data_size = data.shape[0]\n        q1 = np.percentile(data, 25, axis=0)\n        q3 = np.percentile(data, 75, axis=0)\n        iqr = q3 - q1\n\n        # Step 3: Generate normally distributed outliers\n        outliers = np.random.normal(\n            loc=q1 - 1.5 * iqr,\n            scale=iqr,\n            size=NUM_OUTLIERS\n        )\n        # Step 4: Merge normally distributed data and outliers\n        data = np.concatenate((data, outliers), axis=0)\n\n    # Step 5: Plot histogram\n    outliers_detected = None\n    if data.size > 0:\n        _, ax = plt.subplots()\n\n        # Plot histogram of the normally", "compilation_passed": true, "time": 0.0012140274047851562, "tests_passed": false, "error": "ValueError"}
{"code": "# Generate normally distributed normal_data\n    normal_data = np.random.normal(size=num_samples)\n    # If num_outliers is zero or negative, do not introduce outliers\n    if num_outliers < 1:\n        return normal_data, np.array([]), ax\n    # Generate the artificial outliers\n    outliers = np.random.uniform(-10, 10, num_outliers)\n    # Concatenate normally distributed normal_data with outliers\n    data = np.concatenate([normal_data, outliers])\n\n    # Sort data\n    data.sort()\n\n    # Initialize figure\n    fig, ax = plt.subplots()\n    # Plot data\n    ax.hist(data, bins=40, ec=\"k\", alpha=0.75)\n\n    # Generate the outliers detected by the IQR method\n    lower_q1, lower_q2, upper_q1, upper_q2 = np.percentile(data, [25, 50, 75, 100])\n    iqr = upper_q2 -", "compilation_passed": false, "time": 0.00021982192993164062, "tests_passed": false, "error": "SyntaxError"}
{"code": "# Normal data generation\n    if num_samples <= 0:\n        normal_data = None\n    else:\n        normal_data = np.random.normal(loc=0, scale=1, size=num_samples)\n\n    # Outliers generation\n    outliers = np.random.uniform(-10, 10, size=num_outliers)\n\n    # Combining data\n    data = np.concatenate([normal_data, outliers])\n\n    # IQR-based detection of outliers\n    quartiles = np.percentile(data, [25, 75])\n    iqr = quartiles[1] - quartiles[0]\n    cutoff = iqr * 1.5\n    outliers_detected = data[(data < quartiles[0] - cutoff) | (data > quartiles[1] + cutoff)]\n\n    # Plotting\n    ax = plt.hist(data, bins=50, density=True, alpha=0.5)\n\n    return data, outliers_detected, ax", "compilation_passed": true, "time": 0.02078986167907715, "tests_passed": true, "error": null}
{"code": "# Generate normally distributed data\n    if num_samples > 0:\n        data = np.random.normal(0, 1, num_samples)\n    else:\n        data = []\n\n    # Generate uniformly distributed outliers\n    if num_outliers > 0:\n        data = np.concatenate([data, np.random.uniform(-10, 10, num_outliers)])\n\n    # Plot histogram of the combined data\n    ax = plt.hist(data, bins=30, density=True, label='Data')\n    ax.set(xlabel='Data', ylabel='Frequency', title='Histogram of Data')\n    ax.legend(loc='best', frameon=False)\n\n    return data, outliers_detected, ax", "compilation_passed": true, "time": 0.025155067443847656, "tests_passed": false, "error": "AttributeError"}
