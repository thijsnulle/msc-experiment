{"code": "# Replace None with your code\n\n    principalDf = PCA().fit_transform(df.fillna(df.mean()).select_dtypes(include=[np.number]).values)\n    ax = sns.scatterplot(data=principalDf, x=\"principal component 1\", y=\"principal component 2\")\n    ax.set(xlabel=\"principal component 1\", ylabel=\"principal component 2\")\n    return principalDf, ax", "compilation_passed": true, "time": 0.0021278858184814453, "tests_passed": false, "error": "TypeError"}
{"code": "df = df.copy()\n    cols = list(df.columns)\n    for i in range(len(cols)):\n        if not df[cols[i]].dtypes == \"float64\":\n            df[cols[i]] = df[cols[i]].fillna(df[cols[i]].mean())\n        df[cols[i]] = df[cols[i]].fillna(df[cols[i]].mean())\n\n    pca = PCA()\n    pca.fit(df)\n    principalDf = pd.DataFrame(pca.components_, columns=[\"Component 1\", \"Component 2\"])\n    principalDf[cols] = df[cols]\n\n    ax = sns.scatterplot(x=\"Component 1\", y=\"Component 2\", hue=cols, data=principalDf)\n    return principalDf, ax", "compilation_passed": true, "time": 0.002424001693725586, "tests_passed": false, "error": "ValueError"}
{"code": "# Task 1\n    pca = PCA(n_components=2)\n    df_pca = pca.fit_transform(df)\n    return df_pca, plt.scatter(x=df_pca[:,0],y=df_pca[:,1])", "compilation_passed": true, "time": 0.0018589496612548828, "tests_passed": false, "error": "PCA does not accept missing values encoded as NaN natively. For supervised learning, you might want to consider sklearn.ensemble.HistGradientBoostingClassifier and Regressor which accept missing values encoded as NaNs natively. Alternatively, it is possible to preprocess the data, for instance by using an imputer transformer in a pipeline or drop samples with missing values. See https"}
{"code": "# Replace missing values with their mean\n    df = df.fillna(df.mean())\n    # Perform PCA\n    pca = PCA(n_components=2, svd_solver='full')\n    principalDf = pd.DataFrame(pca.fit_transform(df), columns=['principal component 1','principal component 2'])\n    # Create a scatter plot\n    sns.scatterplot(x=\"principal component 1\", y=\"principal component 2\", data=principalDf)\n\n    return principalDf, ax", "compilation_passed": true, "time": 0.006978034973144531, "tests_passed": false, "error": "NameError"}
{"code": "pca = PCA()\n    pca.fit(df.fillna(df.mean()))\n\n    principalDf = pd.DataFrame(pca.components_, columns=['Component 1', 'Component 2'])\n    plt.scatter(x='Component 1', y='Component 2', data=principalDf)\n\n    return principalDf, ax", "compilation_passed": true, "time": 0.002335071563720703, "tests_passed": false, "error": "ValueError"}
{"code": "# Replace `None` values with column's average\n    df.fillna(df.mean(axis=0), inplace=True)\n\n    # Create a new DataFrame with only numeric columns\n    numeric_df = df.select_dtypes(include=['int', 'float'])\n\n    # Perform PCA\n    pca = PCA(n_components=2)\n    pca_df = pca.fit_transform(numeric_df.values)\n\n    # Create a DataFrame with the first two principal components\n    principal_df = pd.DataFrame(pca_df, columns=['Component 1', 'Component 2'])\n\n    # Create a scatter plot with the first two principal components\n    ax = sns.scatterplot(data=principal_df)\n\n    return principal_df, ax", "compilation_passed": true, "time": 0.009552001953125, "tests_passed": true, "error": null}
{"code": "# Replace the code below with your code.\n\n    return", "compilation_passed": true, "time": 0.0012068748474121094, "tests_passed": false, "error": "TypeError"}
{"code": "df.fillna(df.mean(),inplace=True)\n    pca = PCA(n_components=2).fit(df)\n\n    principalDf = pd.DataFrame(pca.components_, columns=[\"Component 1\", \"Component 2\"])\n    principalDf = pd.melt(principalDf, id_vars=\"Component\")\n\n    principalDf = principalDf.merge(df, left_on=\"variable\", right_on=\"c3\")\n\n    ax = sns.scatterplot(x=\"principal component 1\",\n                         y=\"principal component 2\",\n                         data=principalDf,\n                         color=\"Component 1\")\n\n    plt.xlabel(\"principal component\")\n    plt.ylabel(\"principal component 2\")\n\n    return principalDf, ax", "compilation_passed": true, "time": 0.002521038055419922, "tests_passed": false, "error": "ValueError"}
{"code": "df = df.copy()\n    df[\"c1\"] = df[\"c1\"].fillna(df[\"c1\"].mean())\n    df[\"c2\"] = df[\"c2\"].fillna(df[\"c2\"].mean())\n    df[\"c3\"] = df[\"c3\"].fillna(df[\"c3\"].mean())\n\n    pca = PCA(n_components=2)\n    pca.fit(df[['c1', 'c2', 'c3']])\n\n    principalDf = pd.DataFrame(pca.transform(df[['c1', 'c2', 'c3']]),\n                               columns=['Component 1', 'Component 2'],\n                               index=df.index)\n\n    return principalDf, plt.scatter(principalDf['Component 1'],\n                                   principalDf['Component 2'],\n                                   marker='.')", "compilation_passed": true, "time": 0.003554105758666992, "tests_passed": false, "error": "AttributeError"}
{"code": "cols = []\n    for col in df.columns:\n        if df[col].dtype == 'int' or df[col].dtype == 'float':\n            cols.append(col)\n\n    df = df[cols].fillna(df[cols].mean())\n    pca = PCA(n_components=2)\n    pca_df = pca.fit_transform(df)\n\n    x, y = pca_df[:, 0], pca_df[:, 1]\n    fig, ax = plt.subplots()\n    ax.scatter(x, y, alpha=0.5)\n    ax.grid()\n    ax.set_xlabel('principal component 1')\n    ax.set_ylabel('principal component 2')\n\n    return pca_df, ax", "compilation_passed": true, "time": 0.01991105079650879, "tests_passed": false, "error": "AttributeError"}
{"code": "pass\n    df.fillna(df.mean(), inplace=True)\n    df = df.select_dtypes(include=['number'])\n    df = df[['c1', 'c2']]\n    pca = PCA(n_components=2)\n    principalDf = pd.DataFrame(pca.fit_transform(df), columns = ['Component 1', 'Component 2'])\n    ax = sns.scatterplot(x=\"Component 1\", y=\"Component 2\", data=principalDf)\n    plt.show()", "compilation_passed": true, "time": 0.006276130676269531, "tests_passed": false, "error": "TypeError"}
{"code": "columns = df.columns.values\n    df_copy = df.copy()\n    if type(columns[0]) == np.float64:\n        df_copy[columns[0]] = df_copy[columns[0]].fillna(df_copy[columns[0]].mean())\n        df_copy[columns[1]] = df_copy[columns[1]].fillna(df_copy[columns[1]].mean())\n    else:\n        for i in range(len(columns)):\n            if type(df[columns[i]].iloc[0]) == np.float64:\n                df_copy[columns[i]] = df_copy[columns[i]].fillna(df_copy[columns[i]].mean())\n    pca = PCA(n_components=2, random_state=42)\n    pca.fit(df_copy)\n    principal_components = pd.DataFrame(pca.components_, columns=[\"Component 1\", \"Component 2\"])\n    principal_df = pd.concat([df_copy, principal_components]", "compilation_passed": false, "time": 0.0003399848937988281, "tests_passed": false, "error": "SyntaxError"}
{"code": "# Replace np.nan by column's average\n    df[df.isna()] = df.mean(axis=0)\n    pca = PCA(n_components=2)\n    pca.fit(df)\n    principalDf = pd.DataFrame(pca.components_, columns = [\"principal component 1\", \"principal component 2\"])\n    ax = sns.scatterplot(x=\"principal component 1\", y=\"principal component 2\", data=principalDf)\n    ax.set(xlabel=\"principal component 1\", ylabel=\"principal component 2\")\n    return principalDf, ax", "compilation_passed": true, "time": 0.001766204833984375, "tests_passed": false, "error": "ValueError"}
{"code": "principal_df = pd.DataFrame()\n    for column_name in df.select_dtypes(np.number).columns:\n        df[column_name].fillna(df[column_name].mean())\n        pca = PCA(n_components=2)\n        pca_result = pca.fit(df[column_name])\n        principal_df[column_name] = pd.DataFrame(pca_result.components_, columns=['principal component 1', 'principal component 2'])\n    principal_df.plot.scatter(x='principal component 1', y='principal component 2', c='black')\n    return principal_df, plt.gca()", "compilation_passed": true, "time": 0.0017910003662109375, "tests_passed": false, "error": "ValueError"}
{"code": "# replace missing values by column average\n    df = df.fillna(df.mean())\n\n    # select only numeric columns\n    df = df.select_dtypes(include=[\"float\", \"int\"])\n\n    # perform PCA\n    pca = PCA(n_components=2)\n    principalDf = pd.DataFrame(pca.fit_transform(df))\n\n    # plot components\n    principalDf.columns = [\"Component 1\", \"Component 2\"]\n    ax = sns.scatterplot(x=\"Component 1\", y=\"Component 2\", data=principalDf)\n    ax.set(xlabel=\"Component 1\", ylabel=\"Component 2\")\n\n    return principalDf, ax", "compilation_passed": true, "time": 0.007025957107543945, "tests_passed": false, "error": "TypeError"}
{"code": "# Replace ... with your code\n    cols = df.columns.to_numpy()\n    num_cols = 0\n\n    for col in cols:\n        if not pd.isnull(df[col].mean()):\n            df[col] = df[col].fillna(df[col].mean())\n        else:\n            num_cols += 1\n\n    df = df.dropna().iloc[:, 0:num_cols]\n    pca = PCA(n_components=2)\n    principalDf = pd.DataFrame(pca.fit_transform(df), columns = ['Component 1','Component 2'])\n    plt.figure(figsize=(8, 6))\n    sns.scatterplot(x=\"Component 1\", y=\"Component 2\", data=principalDf)\n    plt.xlabel(\"Component 1\")\n    plt.ylabel(\"Component 2\")\n\n    return principalDf, plt.gcf()", "compilation_passed": true, "time": 0.002418994903564453, "tests_passed": false, "error": "ValueError"}
{"code": "# Replace the code below with your code\n    df = df.dropna().fillna(df[df.columns].mean())\n    pca = PCA(n_components=2)\n    pca.fit(df)\n    components = pca.transform(df)\n    return pd.DataFrame(components, columns=[\"principal component 1\", \"principal component 2\"]), plt.scatter(components[:, 0], components[:, 1])\n    pass", "compilation_passed": true, "time": 0.0034389495849609375, "tests_passed": true, "error": null}
{"code": "# Replace missing values with column's average\n    df.fillna(df.mean(), inplace=True)\n\n    # Perform PCA on the numeric columns\n    pca = PCA(n_components=2)\n    principal_components = pca.fit_transform(df)\n\n    # Create the DataFrame with the principal components\n    principal_df = pd.DataFrame(principal_components,\n                                columns=['Component 1', 'Component 2'])\n    ax = plt.subplots()\n    plt.scatter(principal_df['Component 1'], principal_df['Component 2'], marker='x')\n    ax.set_xlabel('principal component')\n    ax.set_ylabel('principal component 2')\n\n    return principal_df, ax", "compilation_passed": true, "time": 0.01774883270263672, "tests_passed": false, "error": "AttributeError"}
{"code": "# Your code here\n    return", "compilation_passed": true, "time": 0.0013308525085449219, "tests_passed": false, "error": "TypeError"}
{"code": "# Replace this line with your code\n    pass", "compilation_passed": true, "time": 0.0010929107666015625, "tests_passed": false, "error": "TypeError"}
{"code": "# Replace the line below with your code\n    df = df.fillna(df.mean())\n    pca = PCA(n_components=2)\n    principalDf = pca.fit_transform(df)\n    return principalDf, None", "compilation_passed": true, "time": 0.0020737648010253906, "tests_passed": false, "error": "AttributeError"}
{"code": "# Fill in code\n    n_comp=len(df.columns)-1\n    df.fillna(df.mean(),inplace=True)\n    pca=PCA(n_components=n_comp)\n    principalDf=pd.DataFrame(pca.fit_transform(df),columns=['principal component 1','principal component 2'],index=df.index)\n    ax=sns.scatterplot(x='principal component 1',y='principal component 2',data=principalDf)\n    return principalDf,ax", "compilation_passed": true, "time": 0.009861230850219727, "tests_passed": true, "error": null}
{"code": "principalDf = pd.DataFrame()\n\n    for c in df.columns:\n        if pd.api.types.is_numeric_dtype(df[c]):\n            df[c].fillna(df[c].mean(), inplace=True)\n            principalDf[c] = PCA(n_components=1).fit_transform(df[c].values.reshape(-1, 1)).flatten()\n        else:\n            continue\n\n    pca = PCA(n_components=2)\n    pca.fit(df)\n    principalComponents_vector = pca.components_\n\n    principalComponents = pd.DataFrame(\n        pca.transform(principalComponents_vector),\n        columns=[f\"Component {i+1}\" for i in range(2)]\n    )\n    principalDf = pd.concat((principalComponents, df[[c for c in df.columns if c in principalComponents]]), axis=1)\n\n    ax = sns.scatterplot(\n        x=principalDf[\"Component 1\"", "compilation_passed": false, "time": 0.00032901763916015625, "tests_passed": false, "error": "SyntaxError"}
{"code": "# Replace this code with your own solution.\n    pca = PCA(n_components=2, svd_solver='full', random_state=42)\n    pca.fit(df.fillna(df.mean()))\n    principalDf = pd.DataFrame(pca.components_, columns=[\"Component 1\", \"Component 2\"])\n\n    principalDf.iloc[1, 0] = 1\n\n    return principalDf, ax", "compilation_passed": true, "time": 0.002540111541748047, "tests_passed": false, "error": "ValueError"}
{"code": "# Replace this\n    df1 = df.replace('nan','0',regex=True)\n    df1 = df1.astype(float)\n    df_mean = df1.mean(axis=0)\n    df1 = df1.fillna(df_mean)\n    df_std = df1.std()\n    df1 = df1.divide(df_std,axis=0)\n    pca_model = PCA(n_components=2, random_state=1).fit(df1)\n    components = pca_model.components_\n    pca_df = pd.DataFrame(components, columns=['Component 1','Component 2'])\n    ax = sns.scatterplot(data=pca_df)\n    return pca_df, ax", "compilation_passed": true, "time": 0.0030388832092285156, "tests_passed": false, "error": "PCA does not accept missing values encoded as NaN natively. For supervised learning, you might want to consider sklearn.ensemble.HistGradientBoostingClassifier and Regressor which accept missing values encoded as NaNs natively. Alternatively, it is possible to preprocess the data, for instance by using an imputer transformer in a pipeline or drop samples with missing values. See https"}
{"code": "df = df.fillna(df.mean())\n    df = df.loc[:, ~df.columns.isin(['c1', 'c2', 'c3'])]\n\n    pca = PCA(n_components=2, random_state=42)\n    principalDf = pd.DataFrame(pca.fit_transform(df))\n    principalDf.columns = ['principal component 1', 'principal component 2']\n\n    ax = sns.scatterplot(x='principal component 1', y='principal component 2', data=principalDf)\n    return principalDf, ax", "compilation_passed": true, "time": 0.002054929733276367, "tests_passed": false, "error": "ValueError"}
{"code": "# TODO: Implement me\n    return None, None", "compilation_passed": true, "time": 0.0011332035064697266, "tests_passed": false, "error": "AttributeError"}
{"code": "numeric_columns = [column for column in df.columns if df[column].dtype != np.object_]\n    pca = PCA(n_components=2)\n    pca.fit(df[numeric_columns])\n    df_principal = pca.components_\n    df_principal.columns = ['principal component 1', 'principal component 2']\n    return df_principal, ax\n    \"\"\"\n    Write your code here.\n    \"\"\"", "compilation_passed": true, "time": 0.0022809505462646484, "tests_passed": false, "error": "PCA does not accept missing values encoded as NaN natively. For supervised learning, you might want to consider sklearn.ensemble.HistGradientBoostingClassifier and Regressor which accept missing values encoded as NaNs natively. Alternatively, it is possible to preprocess the data, for instance by using an imputer transformer in a pipeline or drop samples with missing values. See https"}
{"code": "pca = PCA(n_components=2)\n    pca.fit(df)\n\n    principalDf = pd.DataFrame(pca.transform(df))\n    principalDf.columns = ['principal component 1', 'principal component 2']\n\n    fig, ax = plt.subplots()\n\n    sns.scatterplot(x=principalDf.iloc[:, 0], y=principalDf.iloc[:, 1], hue=principalDf.iloc[:, 1], hue_order=[-1, 1], ax=ax)\n    ax.set_xlabel('principal component 1')\n    ax.set_ylabel('principal component 2')\n    ax.set_title('Scatter plot of PCA components')\n    return principalDf, ax", "compilation_passed": true, "time": 0.0019178390502929688, "tests_passed": false, "error": "PCA does not accept missing values encoded as NaN natively. For supervised learning, you might want to consider sklearn.ensemble.HistGradientBoostingClassifier and Regressor which accept missing values encoded as NaNs natively. Alternatively, it is possible to preprocess the data, for instance by using an imputer transformer in a pipeline or drop samples with missing values. See https"}
{"code": "df = df.fillna(df.mean())\n    df = df.astype(float)\n    pca = PCA(n_components=2)\n    pca.fit(df)\n    pc = pca.components_\n    principalDf = pd.DataFrame(columns=[\"Component 1\", \"Component 2\"])\n    principalDf[\"Component 1\"] = pc[0]\n    principalDf[\"Component 2\"] = pc[1]\n    ax = sns.scatterplot(x=\"Component 1\", y=\"Component 2\", data=principalDf)\n    ax.set_xlabel(\"principal component\")\n    ax.set_ylabel(\"principal component 2\")\n    return principalDf, ax", "compilation_passed": true, "time": 0.006030082702636719, "tests_passed": true, "error": null}
