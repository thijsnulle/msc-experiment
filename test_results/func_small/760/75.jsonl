{"code": "if not pd.Series(start_year).isin([1980, 1990, 2000, 2010, 2020, 2030, 2040, 2050, 2060, 2070, 2080, 2090, 2100]).all():\n        raise ValueError(\"Invalid 'start_year'. Must be one of: 1980, 1990, 2000, 2010, 2020, 2030, 2040, 2050, 2060, 2070, 2080, 2090, 2100.\")\n    if not pd.Series(end_year).isin([1980, 1990, 2000, 2010, 2020, 2030, 2040, 2050, 2", "compilation_passed": false, "time": 0.00023818016052246094, "tests_passed": false, "error": "SyntaxError"}
{"code": "if start_year > end_year:\n        raise Exception('Start year must be earlier than end year!')\n    else:\n        start_date = datetime.date(start_year, 1, 1)\n        end_date = datetime.date(end_year, 12, 31)\n\n        if rng_seed is None:\n            rng = np.random\n        else:\n            rng = np.random.RandomState(rng_seed)\n\n        data = {}\n        for col_name, col_list in {'ID': np.arange(1, 101),\n                                   'Name': rng.choice(latin_names + other_names, 100),\n                                   'Date of Birth': rng.choice(\n                                       pd.date_range(start=start_date, end=end_date, freq='Y').tolist(), 100)}:\n            data[col_name] = col_list\n\n        df = pd.DataFrame(data)\n        df['Email'] = df['Name']", "compilation_passed": true, "time": 0.001455068588256836, "tests_passed": false, "error": "ValueError"}
{"code": "rng = np.random.default_rng(seed=rng_seed)\n\n    names_list = [other_names, latin_names]\n    df = pd.DataFrame(\n        columns=['ID', 'Name', 'Date of Birth', 'Email'])\n\n    for i in range(1, 101):\n        df['Name'].iloc[i-1] = names_list[rng.integers(0, 2)].pop(rng.integers(0, len(names_list[0])))\n\n        birth_year = rng.integers(start_year, end_year)\n        birth_date = datetime.date(birth_year, rng.integers(1, 12), rng.integers(1, 28))\n        df['Date of Birth'].iloc[i-1] = birth_date\n\n        email_address = '{}_{}{}@{}_'.format(df['Name'].iloc[i-1].strip('.'),\n                                            birth_year,\n                                            ", "compilation_passed": false, "time": 0.00031304359436035156, "tests_passed": false, "error": "SyntaxError"}
{"code": "np.random.seed(rng_seed)\n\n    names = latin_names + other_names\n\n    # generate dates and random names\n    df_temp = pd.DataFrame(columns=['ID', 'Name', 'Birth', 'Email'])\n    df_temp['Name'] = np.random.choice(names, 100)\n    df_temp['Birth'] = pd.to_datetime(df_temp.apply(lambda x: x['Name'].replace(x['Name'].rstrip('s'),\n                                                                                  x['Name'].rstrip('es'),1), axis=1)) + \\\n                      np.random.randint(0, 24) * pd.Timedelta('1h') - 86400 * np.random.randint(0, 6)\n    df_temp['Email'] = df_temp['Birth'].map(lambda x: \"{name}@{year}@{domain}\".format(name=x.rstrip('s'), year=x.year, domain=email_domain))\n", "compilation_passed": true, "time": 0.004115104675292969, "tests_passed": false, "error": "pandas._libs.tslibs.parsing.DateParseError"}
{"code": "rng = np.random.default_rng(rng_seed)\n    df = pd.DataFrame(\n        index=range(1,101),\n        columns=['ID', 'Name', 'Date of Birth', 'Email'],\n    )\n    df.loc[:, 'ID'] = df.index\n    df.loc[:, 'Name'] = rng.choice(latin_names+other_names, size=100, replace=False)\n    df.loc[:, 'Date of Birth'] = pd.to_datetime(\n        rng.randint(start_year, end_year, size=100),\n        year=True, month=True, day=True\n    )\n    df.loc[:, 'Email'] = df.loc[:, 'Name'] + '1' + df.loc[:, 'Date of Birth'].dt.strftime(\"%Y-%m-%d\").str.lower() + '@' + email_domain\n    return df.applymap(lambda s: re.sub(r\"\\b([a-zA-Z", "compilation_passed": false, "time": 0.00014710426330566406, "tests_passed": false, "error": "SyntaxError"}
{"code": "import pandas as pd\n    import numpy as np\n    import codecs\n    import re\n    import datetime\n\n    np.random.seed(rng_seed)\n    start_year = 1980 if start_year is None else start_year\n    end_year = 2000 if end_year is None else end_year\n    email_domain = 'example.com' if email_domain is None else email_domain\n    latin_names = ['Sopet\u00f3n', 'M\u00e9ndez', 'G\u00f3mez', 'P\u00e9rez', 'Mu\u00f1oz'] if latin_names is None else latin_names\n    other_names = ['Smith', 'Johnson', 'Williams', 'Brown', 'Jones'] if other_names is None else other_names\n\n    df = pd.DataFrame(\n        columns=['ID', 'Name', 'Date of Birth', 'Email']\n    )\n\n    for i in range(1, 100 + 1):\n        birth_year = start_year + np.random.randint(end", "compilation_passed": false, "time": 0.000270843505859375, "tests_passed": false, "error": "SyntaxError"}
{"code": "rng = np.random.default_rng(seed=rng_seed)\n    names = (latin_names + other_names) * 2\n\n    # Generate random dates between 1980 and 2000\n    random_dates = pd.date_range(start=pd.Timestamp('1980-01-01'),\n                                 end=pd.Timestamp('2000-12-31'), freq='YS')\n\n    df = pd.DataFrame({'ID': range(1, 101),\n                       'Name': rng.choice(names, 100, replace=False),\n                       'Date of Birth': random_dates,\n                       'Email': ['{}_{}'.format(name, year)\n                                for name, year in zip(df['Name'], df['Date of Birth'].dt.year)]})\n\n    # Fix improperly encoded characters in names\n    df.loc[df['Name'].str.contains('[A-Z]'), 'Name'] = df['Name'].str.", "compilation_passed": false, "time": 0.00026297569274902344, "tests_passed": false, "error": "SyntaxError"}
{"code": "rng = np.random.default_rng(rng_seed)\n    df = pd.DataFrame(columns=['ID', 'Name', 'Date of Birth', 'Email'])\n    df['Name'] = other_names.copy()\n    df['Date of Birth'] = [\n        datetime.date(start_year + rng.integers(0, 100), rng.choice(12), rng.integers(1, 31))\n        for _ in range(100)]\n    df.index = np.arange(1, len(df) + 1)\n    for idx, row in df.iterrows():\n        name = row['Name']\n        try:\n            name_split = name.split(' ')\n        except AttributeError:\n            # If there is no space in name, there is no space in name either\n            if re.match(r\"^[a-zA-Z\u00f1\u00d1]+$\", name):\n                name_split = [name]\n            else:\n                name_split = []\n        latin_name =", "compilation_passed": false, "time": 0.00028824806213378906, "tests_passed": false, "error": "SyntaxError"}
{"code": "# Seed the random number generator\n    if rng_seed is not None:\n        np.random.seed(rng_seed)\n        pd.options.mode.chained_assignment = None\n\n    # Define some strings to be used in the generation\n    latin_name_patterns = ['[A-Za-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00e0\u00e8\u00ec\u00f2\u00f9\u00e4\u00eb\u00ef\u00f6\u00fc\u00f1\u00e7]+\\.?',\n                          '[A-Za-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00e0\u00e8\u00ec\u00f2\u00f9\u00e4\u00eb\u00ef\u00f6\u00fc\u00f1\u00e7]+\\.[A-Za-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00e0\u00e8\u00ec\u00f2\u00f9\u00e4\u00eb\u00ef\u00f6\u00fc\u00f1\u00e7]*',\n                          '[A-Za-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00e0\u00e8\u00ec\u00f2\u00f9\u00e4\u00eb\u00ef\u00f6\u00fc\u00f1\u00e7]*',\n                          '[A-Za-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00e0\u00e8\u00ec\u00f2\u00f9\u00e4\u00eb\u00ef\u00f6\u00fc\u00f1\u00e7]+\\.[A-Za-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00e0\u00e8\u00ec\u00f2\u00f9\u00e4\u00eb\u00ef", "compilation_passed": false, "time": 9.012222290039062e-05, "tests_passed": false, "error": "SyntaxError"}
{"code": "if rng_seed:\n        np.random.seed(rng_seed)\n        random.seed(rng_seed)\n\n    # 1) Get names, dates and emails\n    # Generate a list of tuples representing names and dates for the specified year range\n    names = [random.choice(latin_names + other_names) for _ in range(100)]\n    dates = [\n        datetime.datetime(year, np.random.randint(1, 13),\n                          np.random.randint(1, 28), 0, 0, 0).strftime('%Y-%m-%d')\n        for _ in range(100)\n    ]\n\n    # Fix incorrect characters in Latin names\n    correct_names = []\n    for name in names:\n        fixed_name = re.sub(r'[^\\x00-\\x7f]', '', name)\n        if len(fixed_name) != len(name):\n            print('Name \"{}\" has been fixed.'.format(name))\n        correct", "compilation_passed": true, "time": 0.001093149185180664, "tests_passed": false, "error": "NameError"}
{"code": "rng = np.random.default_rng(seed=rng_seed)\n\n    # Create an empty DataFrame\n    df = pd.DataFrame({\n        'ID': range(1, 101),\n        'Name': [],\n        'Date of Birth': [],\n        'Email': []\n    })\n\n    # Loop through the range and fill in the data\n    for i in range(1, 101):\n        name = rng.choice(latin_names + other_names)\n        name = re.sub(r'(\\w)\\.(\\w)\\.(\\w)\\.(\\w)', r'\\1.\\2.\\3.\\4', name)\n        name = re.sub(r'(\\w)(\\w)\\.(\\w)\\.(\\w)', r'\\1.\\2.\\3.\\4', name)\n        name = re.sub(r'(\\w)\\.(\\w)(\\w)\\.(\\w)', r'\\1.\\2.\\3.\\4', name)\n        name = re.sub(r'(\\", "compilation_passed": false, "time": 0.00011777877807617188, "tests_passed": false, "error": "SyntaxError"}
{"code": "if not (isinstance(latin_names, list) and\n            all(isinstance(name, str) for name in latin_names)):\n        raise TypeError('latin_names must be a list of strings')\n    if not (isinstance(other_names, list) and\n            all(isinstance(name, str) for name in other_names)):\n        raise TypeError('other_names must be a list of strings')\n    if not isinstance(start_year, (int, np.integer)) or \\\n       start_year < 0 or start_year > 10000:\n        raise TypeError('start_year must be an integer in the range [0, 10000]')\n    if not isinstance(end_year, (int, np.integer)) or \\\n       end_year < 0 or end_year > 10000:\n        raise TypeError('end_year must be an integer in the range [0, 10000]')\n    if not isinstance(rng_seed, (int, np.integer)):\n        raise Type", "compilation_passed": true, "time": 0.0010170936584472656, "tests_passed": false, "error": "TypeError"}
{"code": "# seed random generator\n    np.random.seed(rng_seed)\n\n    # generate IDs\n    id_df = pd.DataFrame({'ID': pd.arange(1, 101, dtype=int)})\n\n    # generate names\n    # generate other names\n    if latin_names:\n        latin_name_df = pd.DataFrame({'Latin_Name': latin_names})\n    else:\n        latin_name_df = pd.DataFrame({'Latin_Name': [None] * 100})\n\n    if other_names:\n        other_name_df = pd.DataFrame({'Other_Name': other_names})\n    else:\n        other_name_df = pd.DataFrame({'Other_Name': [None] * 100})\n\n    # generate date of births\n    years = pd.arange(start_year, end_year+1, dtype=int)\n    random.shuffle(years)\n    year_df = pd.DataFrame({'Year': years})\n    date_of_birth_df = pd.concat([", "compilation_passed": false, "time": 0.0002830028533935547, "tests_passed": false, "error": "SyntaxError"}
{"code": "if rng_seed is not None:\n        np.random.seed(rng_seed)\n        random.seed(rng_seed)\n        pd.set_option('mode.column_stack_max', 50000)\n        pd.set_option('display.max_columns', 50000)\n\n    latin_names = [str.title(n) for n in latin_names]\n    other_names = [str.title(n) for n in other_names]\n    name_choices = latin_names + other_names\n\n    # Generate random dates and emails\n    dates = [pd.to_datetime(random.choice(range(start_year, end_year + 1)),\n                            year_format='%Y') for i in range(100)]\n    emails = [f\"{random.choice(name_choices)}@{email_domain}\" for i in range(100)]\n\n    # Fix incorrectly encoded Latin characters in names\n    for i in range(100):\n        name = emails[i]", "compilation_passed": true, "time": 0.0010488033294677734, "tests_passed": false, "error": "NameError"}
{"code": "if rng_seed is not None:\n        np.random.seed(rng_seed)\n    # df = pd.DataFrame(\n    #     {\n    #         'ID': np.random.randint(1, 101, 100),\n    #         'Name': np.random.choice(latin_names + other_names, 100),\n    #         'Date of Birth': np.random.choice(\n    #             pd.date_range(\n    #                 datetime.datetime(start_year, 1, 1),\n    #                 datetime.datetime(end_year, 12, 31),\n    #                 freq='M'\n    #             ).date,\n    #             100\n    #         )\n    #     }\n    # )\n\n    # df[f'Email'] = df.apply(\n    #     lambda row: f'{row[\"Name\"]}@example.com',\n    #     axis=1\n    # )\n    df = pd.DataFrame(\n        {\n            'ID", "compilation_passed": false, "time": 7.82012939453125e-05, "tests_passed": false, "error": "SyntaxError"}
{"code": "if start_year < 1900 or end_year > 2030:\n        raise ValueError(\"years must be between 1900 and 2030\")\n    rng = np.random.default_rng(rng_seed)\n\n    df = pd.DataFrame(index=np.arange(1, 101))\n    df['ID'] = df.index\n\n    names = latin_names + other_names\n    df['Name'] = df['ID'].apply(lambda x: rng.choice(names))\n\n    year_rng = pd.date_range(start=datetime.datetime.now().year,\n                                    end=end_year,\n                                    periods=end_year - start_year + 1)\n    year_rng = year_rng.map(str).astype(str)\n    year_rng = year_rng[np.random.permutation(len(year_rng))]\n\n    # Correct improperly encoded Latin characters\n    for name in df['Name']", "compilation_passed": false, "time": 0.0002617835998535156, "tests_passed": false, "error": "SyntaxError"}
{"code": "if rng_seed is None:\n        np.random.seed()\n    else:\n        np.random.seed(rng_seed)\n\n    def fix_names(name):\n        name = name.strip()\n\n        if '.' in name:\n            parts = name.split('.')\n\n            for i, part in enumerate(parts):\n                if len(part) > 3:\n                    parts[i] = part[0:3] + part[-3:]\n                    break\n\n            return '.'.join(parts)\n        else:\n            return name\n\n    if isinstance(latin_names, str):\n        latin_names = [latin_names]\n\n    if isinstance(other_names, str):\n        other_names = [other_names]\n\n    names = [' '.join([latin_names[np.random.randint(0, len(latin_names))],\n                       other_names[np.random.randint(0, len(other_names))]]) for _ in range(100)]\n\n    l", "compilation_passed": true, "time": 0.0014452934265136719, "tests_passed": false, "error": "NameError"}
{"code": "if rng_seed is not None:\n        np.random.seed(rng_seed)\n        pd.set_option('mode.chained_assignment', 'warn')\n    rng = np.random.default_rng()\n\n    df = pd.DataFrame(index=range(100))\n    df.reset_index(inplace=True)\n\n    for i in range(len(df)):\n        df.loc[i, 'ID'] = i + 1\n\n    df.loc[df['ID'].isin([1, 2, 3, 4, 5]), 'Name'] = latin_names\n    df.loc[df['ID'].isin([1, 2, 3, 4, 5]), 'Name'] = other_names\n    df.loc[df['ID'].isin([1, 2, 3, 4, 5]), 'Date of Birth'] = (\n        rng.choice(range(start_year, end_year), len(df['Name'])).astype(\n            str) + '", "compilation_passed": false, "time": 0.0001518726348876953, "tests_passed": false, "error": "SyntaxError"}
{"code": "import datetime\n    if rng_seed:\n        np.random.seed(rng_seed)\n    latin_names = [s.lower() for s in latin_names]\n    other_names = [s.lower() for s in other_names]\n    random_df = pd.DataFrame()\n    random_df['ID'] = pd.Series(range(1,101))\n    random_df.set_index('ID', drop=True)\n    year_range = range(start_year, end_year)\n    random_df['Year of Birth'] = np.random.choice(year_range, 100)\n    random_df['Year of Birth'] = pd.to_datetime(random_df['Year of Birth'], format='%Y')\n    random_df['Year of Birth'] = random_df['Year of Birth'].dt.year\n    random_df['Name'] = np.random.choice(latin_names + other_names, 100).astype(str).lower()\n    for row in random_df.index:\n        ", "compilation_passed": false, "time": 0.00030112266540527344, "tests_passed": false, "error": "IndentationError"}
{"code": "if rng_seed is not None:\n        np.random.seed(rng_seed)\n        random.seed(rng_seed)\n\n    df = pd.DataFrame(columns=['ID', 'Name', 'Date of Birth', 'Email'])\n\n    latin_name_dict = {name.lower(): name for name in latin_names}\n    other_name_dict = {name.lower(): name for name in other_names}\n\n    for i in range(1, 101):\n        name = random.choice(latin_names + other_names)\n        date = np.random.randint(1, 2000)\n        year = datetime.date(year=date).strftime('%Y')\n        month = datetime.date(year=date).strftime('%m')\n        day = datetime.date(year=date).strftime('%d')\n        date_of_birth = '-'.join([year, month, day])\n        date_of_birth = datetime.datetime.strptime(date_of_birth, '%Y", "compilation_passed": false, "time": 0.00013399124145507812, "tests_passed": false, "error": "SyntaxError"}
{"code": "# ==============================================================================\n\n    # 1) Initialize the RNG and set the seed if provided\n    if rng_seed:\n        np.random.seed(rng_seed)\n    rng = np.random.default_rng()\n\n    # 2) Initialize the names and date_of_birth lists\n    names, date_of_birth = [], []\n\n    # 3) Fill the lists with Latin names and randomly generated birth dates\n    for i in range(100):\n        # 3.1) Choose randomly from latin_names if it exists, otherwise from other_names\n        name = latin_names[rng.integers(0, len(latin_names))] \\\n            if latin_names else other_names[rng.integers(0, len(other_names))]\n\n        # 3.2) Fill the list with the randomly generated date\n        date_of_birth.append(datetime.date(year=rng.integers(1980, 2000),\n                                           month=rng.", "compilation_passed": false, "time": 0.0002288818359375, "tests_passed": false, "error": "SyntaxError"}
{"code": "if start_year > end_year:\n        raise Exception('start year should be lesser or equal than end year')\n\n    if rng_seed:\n        rng = np.random.RandomState(rng_seed)\n    else:\n        rng = np.random.RandomState()\n\n    year = rng.randint(start_year, end_year + 1, size=100)\n    month = rng.randint(1, 13, size=100)\n    day = rng.randint(1, 29, size=100)\n    name = rng.choice(latin_names + other_names, size=100)\n\n    def fix_latin_name(name):\n        \"\"\"\n        Auxiliar function that checks if a string contains the latin name.\n        If so, the string is corrected and returned.\n        \"\"\"\n        for latin_name in latin_names:\n            if latin_name.lower() in name.lower():\n                name = re.sub(f'(?i){", "compilation_passed": false, "time": 0.00011277198791503906, "tests_passed": false, "error": "SyntaxError"}
{"code": "rng = np.random.default_rng(rng_seed)\n\n    latin_names_df = pd.DataFrame(latin_names, columns=['Name'])\n\n    other_names_df = pd.DataFrame(other_names, columns=['Name'])\n\n    df = (\n        pd.concat([latin_names_df, other_names_df], axis=0, copy=False)\n    ).reset_index().rename(columns={0:'Name'})\n\n    df['Name'] = df['Name'].apply(_correct_name)\n\n    df['Date of Birth'] = pd.to_datetime(\n        rng.integers(\n            low=datetime.datetime.min.replace(year=start_year).date(),\n            high=datetime.datetime.min.replace(year=end_year).date(),\n            size=len(df),\n        ),\n        format='%Y-%m-%d',\n        )\n\n    df['ID'] = rng.integers(low=1, high=101, size=len(df", "compilation_passed": false, "time": 0.00031304359436035156, "tests_passed": false, "error": "SyntaxError"}
{"code": "if rng_seed:\n        np.random.seed(rng_seed)\n\n    df = pd.DataFrame({'ID': range(1, 101),\n                       'Name': ['' for _ in range(100)],\n                       'Date of Birth': [datetime.datetime.min for _ in range(100)],\n                       'Email': ['' for _ in range(100)]})\n\n    df.loc[df.ID < 100, 'Name'] = pd.Series(\n        [random_name(latin_names + other_names) for _ in range(df[df.ID < 100].shape[0])])\n    df.loc[df.ID < 100, 'Name'] = df.loc[df.ID < 100, 'Name'].str.lower()\n\n    df.loc[df.ID < 100, 'Name'] = df.loc[df.ID < 100, 'Name'].replace(' ', '', regex=True, inplace=False)", "compilation_passed": true, "time": 0.001672983169555664, "tests_passed": false, "error": "NameError"}
{"code": "latin_names = [name.strip('\"').replace(\" \", \"_\") for name in latin_names]\n    other_names = [name.strip('\"').replace(\" \", \"_\") for name in other_names]\n\n    df = pd.DataFrame({'ID': np.random.randint(1, 100, 100)})\n    df.loc[:, 'Name'] = np.random.choice(latin_names + other_names, size=100, p=[0.8, 0.2])\n    df.loc[:, 'Date of Birth'] = pd.to_datetime('1980-01-01', unit='D')\n    df.loc[:, 'Date of Birth'] += pd.to_timedelta(np.random.randint(-9999, 9999, 100), unit='D')\n    df.loc[:, 'Email'] = df.apply(\n        lambda row: re.sub(\n            r'[a-zA-Z0-9", "compilation_passed": false, "time": 0.0001461505889892578, "tests_passed": false, "error": "SyntaxError"}
{"code": "if rng_seed is None:\n        np.random.seed()\n        np.random.shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n    else:\n        np.random.seed(rng_seed)\n        np.random.shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n\n    rng = np.random.default_rng(np.random.RandomState())\n    rng.shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n    d = ['name', 'date of birth', 'email']\n    d_str = ['name', 'date of birth', 'email']\n    names = [latin_names, other_names, rng.choice(other_names)]\n    ids = list(range(1, 101", "compilation_passed": false, "time": 0.0003046989440917969, "tests_passed": false, "error": "SyntaxError"}
{"code": "if rng_seed:\n        np.random.seed(rng_seed)\n        pd.options.mode.chained_assignment = None  # default: 'warn'\n        pd.set_option('display.max_columns', 1000)\n        pd.set_option('display.width', 1000)\n        pd.set_option('display.max_colwidth', 1000)\n        pd.set_option('display.expand_frame_repr', False)\n        pd.set_option('display.max_rows', 1000)\n    else:\n        pd.options.mode.chained_assignment = 'warn'\n        pd.set_option('display.max_columns', 1000)\n        pd.set_option('display.width', 1000)\n        pd.set_option('display.max_colwidth', 1000)\n        pd.set_option('display.expand_frame_repr', False)\n        pd.set_option('display", "compilation_passed": false, "time": 0.00010800361633300781, "tests_passed": false, "error": "SyntaxError"}
{"code": "# RNG seed\n    if rng_seed is not None:\n        np.random.seed(rng_seed)\n\n    # Generates a random number for each user's ID.\n    # Adds 1 to the ID to make it 1-indexed.\n    IDs = pd.Series(np.random.randint(1, 101, 100)).astype(int) + 1\n\n    # Generates a random name for each user.\n    # The first option is always 'John' and the second is always 'Jane'.\n    names = pd.Series(['John', 'Jane']).sample(100, replace=True)\n    names.iloc[0:2] = 'Smith'\n\n    # Generates a random name for each user.\n    # The first option is always 'John' and the second is always 'Jane'.\n    other_names = pd.Series(['John', 'Jane']).sample(100, replace=True)\n    other_names.iloc[0:2] = 'Smith'\n\n    ", "compilation_passed": true, "time": 0.0012688636779785156, "tests_passed": false, "error": "TypeError"}
{"code": "df_raw = pd.DataFrame({'ID':range(1,101),\n                          'Name':[random_name(names) for names in [latin_names, other_names]],\n                          'Date of Birth':[random_date_of_birth(start_year, end_year) for _ in range(100)],\n                          'Email':[random_email(name, year, email_domain) for name, year in zip(\n                                                        [latin_names, other_names],\n                                                        [[0], [1]])]\n                          })\n\n    # replace non-latin characters\n    df_raw['Name'] = df_raw['Name'].apply(correct_names)\n\n    return df_raw.set_index('ID')", "compilation_passed": true, "time": 0.0009791851043701172, "tests_passed": false, "error": "NameError"}
{"code": "rng = np.random.default_rng(seed=rng_seed)\n    # Get list of dates\n    date_range = pd.date_range(\n        start=pd.datetime(start_year, 1, 1), end=pd.datetime(end_year, 12, 31), freq=\"M\")\n\n    # Get list of latin_names\n    latin_names_dict = {i: x for i, x in enumerate(latin_names, start=1)}\n    other_names_dict = {i: x for i, x in enumerate(other_names, start=1)}\n\n    # Generate data\n    data = []\n    for _ in range(100):\n        # Generate random index\n        idx = rng.integers(1, 101)\n\n        # Generate random ID\n        id_ = idx\n\n        # Generate random name\n        if idx in latin_names_dict:\n            name = latin_names_dict[idx]\n        elif idx in other_names_dict:\n            name = other", "compilation_passed": true, "time": 0.001262664794921875, "tests_passed": false, "error": "AttributeError"}
