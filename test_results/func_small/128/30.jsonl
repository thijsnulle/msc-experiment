{"code": "fig = plt.figure()\n\n    x = []\n    y = []\n    for i in range(POINTS):\n        # The choice() method returns a randomly selected element from\n        # the specified sequence, and the random() method return a\n        # random float number in the range 0 to 1\n        dir_x = randint(0, 1)  # dir_x = 0 or 1\n        dir_y = randint(0, 1)  # dir_y = 0 or 1\n        if dir_x == 0:\n            x.append(x[-1] + 1)\n        else:\n            x.append(x[-1] - 1)\n        if dir_y == 0:\n            y.append(y[-1] + 1)\n        else:\n            y.append(y[-1] - 1)\n    plt.plot(x, y, \"+\")\n    plt.title(\"Random walk\")\n    return fig", "compilation_passed": true, "time": 0.001474142074584961, "tests_passed": true, "error": null}
{"code": "# Generate random numbers in the range of (-100,100)\n    x = [randint(-100,100) for _ in range(POINTS)]\n    y = [randint(-100,100) for _ in range(POINTS)]\n\n    # Plot points\n    plt.plot(x, y, 'o')\n    plt.show()\n\n    return fig", "compilation_passed": true, "time": 0.004817008972167969, "tests_passed": true, "error": null}
{"code": "x, y = np.random.random(POINTS), np.random.random(POINTS)\n\n    for i in range(POINTS):\n        if randint(1, 4) == 1:\n            x[i] += np.random.random()\n        elif randint(1, 4) == 2:\n            x[i] -= np.random.random()\n        elif randint(1, 4) == 3:\n            y[i] += np.random.random()\n        elif randint(1, 4) == 4:\n            y[i] -= np.random.random()\n    return plt.plot(x, y, \"bo\")", "compilation_passed": true, "time": 0.0018510818481445312, "tests_passed": true, "error": null}
{"code": "x = np.zeros(POINTS)\n    y = np.zeros(POINTS)\n    for i in range(POINTS):\n        r = randint(1, 4)\n        if r == 1:\n            x[i] = x[i - 1] + 1\n            y[i] = y[i - 1]\n        elif r == 2:\n            x[i] = x[i - 1]\n            y[i] = y[i - 1] + 1\n        elif r == 3:\n            x[i] = x[i - 1] - 1\n            y[i] = y[i - 1]\n        else:\n            x[i] = x[i - 1]\n            y[i] = y[i - 1] - 1\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n    ax.set_xlim(0, 100)\n    ax.set_ylim(0, 100)", "compilation_passed": true, "time": 0.007441997528076172, "tests_passed": true, "error": null}
{"code": "x_list = [0]\n    y_list = [0]\n\n    for i in range(POINTS):\n        dir1 = randint(1, 4)\n        x_list.append(x_list[i] + step_x(dir1))\n        y_list.append(y_list[i] + step_y(dir1))\n\n    plt.plot(x_list, y_list)\n    plt.show()\n    return plt.gcf()", "compilation_passed": true, "time": 0.0011851787567138672, "tests_passed": true, "error": null}
{"code": "# Generating two numpy arrays representing x and y coordinates\n    x = np.zeros(POINTS, dtype=int)\n    y = np.zeros(POINTS, dtype=int)\n\n    for i in range(POINTS):\n        # Generating random directions\n        dx = randint(-1, 1)\n        dy = randint(-1, 1)\n\n        # Updating x and y coordinates based on the chosen direction\n        x[i] = x[i - 1] + dx\n        y[i] = y[i - 1] + dy\n\n    # Plotting the path of the walk\n    fig, ax = plt.subplots()\n    plt.scatter(x, y)\n    plt.title(f\"Random walk with {POINTS} steps\")\n    plt.show()\n    return fig", "compilation_passed": true, "time": 0.009905815124511719, "tests_passed": false, "error": "TypeError"}
{"code": "x = [0]\n    y = [0]\n    # TODO: Define random walk simulation using numpy arrays and matplotlib.\n    for step in range(POINTS):\n        x.append(x[step] + randint(-1, 1))\n        y.append(y[step] + randint(-1, 1))\n    fig, ax = plt.subplots(figsize=(4, 4))\n    ax.grid()\n    ax.plot(x, y, linewidth=.25, color='#133091')\n    ax.set_xlim(-POINTS * 0.5, POINTS * 0.5)\n    ax.set_ylim(-POINTS * 0.5, POINTS * 0.5)\n    return fig", "compilation_passed": true, "time": 0.008698225021362305, "tests_passed": true, "error": null}
{"code": "fig, ax = plt.subplots(figsize=(9, 6))\n    ax.set_xlim(0, 200)\n    ax.set_ylim(0, 200)\n    ax.set_aspect('equal')\n\n    # The random walk is generated by randomly choosing directions at each step\n    # The random walk is done 100 times\n    for _ in range(POINTS):\n        # Generating random direction by using random.randint function.\n        x = np.random.randint(0, 200)\n        y = np.random.randint(0, 200)\n\n        # Draw a line in the matplotlib.pyplot\n        plt.plot(x, y, marker='o')\n\n    return plt.gcf()", "compilation_passed": true, "time": 0.02831101417541504, "tests_passed": true, "error": null}
{"code": "x_pos = np.zeros(POINTS)\n    y_pos = np.zeros(POINTS)\n    for i in range(POINTS):\n        x_pos[i] = x_pos[i - 1] + randint(1, 6)  # Generates a random number between 1 and 6\n        y_pos[i] = y_pos[i - 1] + randint(1, 6)  # Generates a random number between 1 and 6\n        plt.scatter(x_pos[i], y_pos[i], color='b')  # Plots the current point in blue color\n    plt.show()\n    return plt.gcf()", "compilation_passed": true, "time": 0.10863590240478516, "tests_passed": false, "error": "TypeError"}
{"code": "x_points = np.zeros(POINTS)\n    y_points = np.zeros(POINTS)\n    for i in range(1, POINTS):\n        x_points[i] = x_points[i-1] + randint(-1, 1)\n        y_points[i] = y_points[i-1] + randint(-1, 1)\n    fig = plt.figure()\n    plt.plot(x_points, y_points, 'o-')\n    plt.show()\n    return fig", "compilation_passed": true, "time": 0.011315345764160156, "tests_passed": false, "error": "TypeError"}
{"code": "x = []\n    y = []\n    i = 0\n    while i < POINTS:\n        dx = randint(0, 1)\n        dy = randint(0, 1)\n        x.append(i)\n        y.append(i)\n        i += math.sqrt(dx * dx + dy * dy)\n\n    fig, ax = plt.subplots()\n    ax.plot(x, y, '.')\n    return fig", "compilation_passed": true, "time": 0.008002042770385742, "tests_passed": true, "error": null}
{"code": "# Generates a random walk based on a random number of points and directions.\n    steps = POINTS\n    dir = np.empty(steps, dtype=int)\n    for i in range(0, steps):\n        if randint(0, 1) == 0:\n            dir[i] = -1\n        else:\n            dir[i] = 1\n    x, y = np.empty(steps), np.empty(steps)\n    # Calculates the distance of each step.\n    for i in range(steps):\n        x[i] = i * dir[i]\n        y[i] = np.sqrt(steps - np.abs(x[i]))\n    # Plots the points\n    fig, ax = plt.subplots()\n    ax.scatter(x, y, label='Points')\n    ax.plot(x, y)\n    ax.grid()\n    ax.set_title('Random walk in 2D space')\n    ax.legend()\n    return fig", "compilation_passed": true, "time": 0.009965896606445312, "tests_passed": true, "error": null}
{"code": "points = POINTS\n    x = np.zeros(points, dtype=int)\n    y = np.zeros(points, dtype=int)\n    x[0], y[0] = randint(-10, 10), randint(-10, 10)\n    for i in range(1, points):\n        directions = np.random.randint(0, 4)\n        if directions == 0:\n            y[i] = y[i - 1] + 1\n            x[i] = x[i - 1]\n        elif directions == 1:\n            y[i] = y[i - 1] - 1\n            x[i] = x[i - 1]\n        elif directions == 2:\n            y[i] = y[i - 1]\n            x[i] = x[i - 1] + 1\n        else:\n            y[i] = y[i - 1]\n            x[i] = x[i - 1] - 1\n\n    fig = plt.figure(fig", "compilation_passed": false, "time": 0.0002770423889160156, "tests_passed": false, "error": "SyntaxError"}
{"code": "x_coords = []\n    y_coords = []\n    for i in range(POINTS):\n        new_x = x_coords[-1] if i > 0 else 0  # Initialize x to the last coordinate if not the first iteration\n        new_y = y_coords[-1] if i > 0 else 0  # Initialize y to the last coordinate if not the first iteration\n\n        # Choose a random direction and distance for the next step\n        direction = randint(0, 1)\n        distance = randint(1, 10)\n\n        if direction == 0:\n            new_x += distance\n        else:\n            new_y += distance\n\n        x_coords.append(new_x)\n        y_coords.append(new_y)\n\n    fig, ax = plt.subplots()\n    ax.plot(x_coords, y_coords)\n    ax.grid()\n\n    return fig", "compilation_passed": true, "time": 0.007644176483154297, "tests_passed": true, "error": null}
{"code": "x = []\n    y = []\n    for _ in range(POINTS):\n        dx = 2*randint(0, 1) - 1\n        dy = 2*randint(0, 1) - 1\n        x.append(dx)\n        y.append(dy)\n    fig = plt.figure()\n    plt.plot(x, y)\n    return fig", "compilation_passed": true, "time": 0.00785374641418457, "tests_passed": true, "error": null}
{"code": "steps = np.zeros([POINTS, 2])\n    steps[0, :] = np.array([randint(-10, 10), randint(-10, 10)])\n    for i in range(1, POINTS):\n        if (steps[i - 1, 0] + randint(-10, 10) == 0) and (steps[i - 1, 1] + randint(-10, 10) == 0):\n            steps[i, 0] = steps[i - 1, 0]\n        else:\n            steps[i, 0] = steps[i - 1, 0] + randint(-10, 10)\n        if (steps[i - 1, 1] + randint(-10, 10) == 0) and (steps[i - 1, 0] + randint(-10, 10) == 0):\n            steps[i, 1] = steps[i - 1, 1]\n        else:\n            steps[", "compilation_passed": false, "time": 0.0002791881561279297, "tests_passed": false, "error": "SyntaxError"}
{"code": "x_steps = np.zeros(POINTS)\n    y_steps = np.zeros(POINTS)\n    for i in range(POINTS):\n        x_steps[i] = randint(-10, 10)\n        y_steps[i] = randint(-10, 10)\n    fig, ax = plt.subplots()\n    ax.scatter(x_steps, y_steps)\n    plt.show()\n    return fig", "compilation_passed": true, "time": 0.009325981140136719, "tests_passed": false, "error": "TypeError"}
{"code": "# ---------------------------------------------------------------------------------------------------------- #\n\n    # Task_1.1\n    # \u0417\u0430\u0434\u0430\u0447\u0430 1.1\n    #\n    # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043c\u0430\u0441\u0441\u0438\u0432\u044b x \u0438 y, \u043d\u0430 \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0431\u0443\u0434\u0443\u0442 \u043f\u043e\u043c\u0435\u0449\u0430\u0442\u044c\u0441\u044f \u0434\u0430\u043d\u043d\u044b\u0435 \u043f\u043e \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430\u043c \u0434\u043b\u044f \u0440\u0438\u0441\u043e\u0432\u0430\u043d\u0438\u044f \u043a\u0440\u0438\u0432\u043e\u0439\n    #\n    # \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c np.array \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u043f\u0443\u0441\u0442\u043e\u0439 \u043c\u0430\u0441\u0441\u0438\u0432\u043e\u0432, \u0437\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u0432 \u043d\u0438\u0445 \u043f\u0435\u0440\u0432\u044b\u0439 \u0438 \u0432\u0442\u043e\u0440\u043e\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442, \u0442.\u043a. \u043c\u044b \u0431\u0443\u0434\u0435\u043c \u0438\u0442\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u043f\u043e \u043d\u0438\u043c\n    #\n    # \u0414\u043e\u0431\u0430\u0432\u0438\u043c \u043c\u0435\u0442\u043e\u0434 append, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u0443\u0434\u0435\u0442 \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043a \u043c\u0430\u0441\u0441\u0438\u0432\u0443.\n    #\n    # \u0412\u044b\u0437\u043e\u0432\u0435\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u044e randint \u0438 \u043f\u0435\u0440\u0435\u0434\u0430\u0434\u0438\u043c \u0435\u0439 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043f\u043e \u0441\u043f\u0440\u0430\u0432\u0430 \u0438 \u0441", "compilation_passed": true, "time": 0.0011749267578125, "tests_passed": true, "error": null}
{"code": "# Create two arrays: x, y coordinates.\n    x = np.array([0] * POINTS)\n    y = np.array([0] * POINTS)\n\n    for i in range(POINTS):  # Iterate POINTS times.\n        # Randomly select a direction and a length for the step.\n        dir_ = randint(0, 1)  # Select 0 or 1.\n        len_ = randint(1, 5)  # Select an integer from 1 to 5.\n\n        if dir_ == 0:  # If direction is 0, set the step length to positive.\n            x[i] += len_\n        else:  # If direction is 1, set the step length to negative.\n            x[i] -= len_\n\n        dir_ = randint(0, 1)  # Select 0 or 1.\n        len_ = randint(1, 5)  # Select an integer from 1 to 5.\n\n        if dir_ == 0:  # If direction is 0, set the step length to", "compilation_passed": false, "time": 0.00017976760864257812, "tests_passed": false, "error": "IndentationError"}
{"code": "x = np.zeros(POINTS)\n    y = np.zeros(POINTS)\n    x[0] = randint(0, 1000)\n    y[0] = randint(0, 700)\n\n    for i in range(1, POINTS):\n        r = np.random.randint(0, 100)\n        if r < 50:\n            x[i] = x[i-1] + randint(0, 25)\n            y[i] = y[i-1] + randint(0, 50)\n        else:\n            x[i] = x[i-1] - randint(0, 25)\n            y[i] = y[i-1] - randint(0, 50)\n\n    plt.plot(x, y)\n    plt.show()\n\n    return plt.gcf()  # Returns the matplotlib figure object", "compilation_passed": true, "time": 0.0029599666595458984, "tests_passed": false, "error": "TypeError"}
{"code": "import matplotlib.pyplot as plt\n    from random import randint\n    from math import sqrt\n\n    # Initialization\n    x_array = np.zeros(POINTS, dtype=int)\n    y_array = np.zeros(POINTS, dtype=int)\n\n    # Coordinates of first step\n    x_array[0] = 0\n    y_array[0] = 0\n\n    # Random walk\n    for i in range(1, POINTS):\n        r = randint(1, 4)\n\n        # Calculate next coordinates\n        x = x_array[i - 1] + r - 2 * (r % 2)\n        y = y_array[i - 1] + 2 - r % 2\n\n        # Update coordinate arrays\n        x_array[i] = x\n        y_array[i] = y\n\n    # Plotting\n    plt.title(f'Random Walk with {POINTS} points')\n    plt.plot(x_array, y_array, '.')\n    plt.show()", "compilation_passed": true, "time": 0.002727985382080078, "tests_passed": false, "error": "TypeError"}
{"code": "fig = plt.figure(figsize=(12,12))\n    ax = fig.add_subplot()\n    points = [(0,0)]\n    for _ in range(POINTS):\n        new_x = points[-1][0] + randint(-1,1)\n        new_y = points[-1][1] + randint(-1,1)\n        points.append((new_x,new_y))\n    x,y = zip(*points)\n    ax.plot(x,y)\n    return fig", "compilation_passed": true, "time": 0.008025169372558594, "tests_passed": true, "error": null}
{"code": "# Generate two arrays representing the x and y coordinates of each step\n    x = [0] * POINTS\n    y = [0] * POINTS\n    # Simulate random walk until the distance from the origin to the last point is greater than 100\n    while min(x) < 100 or max(x) < 100:\n        # Pick a random direction (either left, right, up, or down)\n        direction = randint(1, 4)\n        # Update x and y arrays according to the chosen direction\n        if direction == 1:\n            x.append(x[-1] - 1)\n            y.append(y[-1])\n        elif direction == 2:\n            x.append(x[-1])\n            y.append(y[-1] + 1)\n        elif direction == 3:\n            x.append(x[-1] + 1)\n            y.append(y[-1])\n        else:\n            x.append(x[-1])\n            y.append(y[-1] - 1)\n    # Plot the points using", "compilation_passed": true, "time": 1.0036098957061768, "tests_passed": true, "error": null}
{"code": "x_arr = [0.0]\n    y_arr = [0.0]\n    for i in range(POINTS):\n        r = randint(0, 1)\n        if r == 0:\n            x_arr.append(x_arr[-1] + 0.5 * math.sqrt(1 - y_arr[-1] ** 2))\n            y_arr.append(y_arr[-1])\n        else:\n            y_arr.append(y_arr[-1] + 0.5 * math.sqrt(1 - x_arr[-1] ** 2))\n            x_arr.append(x_arr[-1])\n\n    fig = plt.figure(figsize=(10, 5))\n    plt.plot(x_arr, y_arr)\n    plt.show()\n    return fig", "compilation_passed": true, "time": 0.0019481182098388672, "tests_passed": true, "error": null}
{"code": "# Generate random steps\n    xs = np.zeros(POINTS)\n    ys = np.zeros(POINTS)\n\n    # Simulate random walk\n    for i in range(1, POINTS):\n        xs[i] = xs[i - 1] + randint(-1, 1)\n        ys[i] = ys[i - 1] + randint(-1, 1)\n\n    # Plot the points\n    fig = plt.figure()\n    fig.add_subplot(111)\n    plt.plot(xs, ys, color=\"orange\")\n\n    # Draw axes\n    plt.xlim(-2, 2)\n    plt.ylim(-2, 2)\n    plt.grid(True)\n\n    return fig", "compilation_passed": true, "time": 0.008433818817138672, "tests_passed": true, "error": null}
{"code": "# Set the number of steps\n    steps = POINTS\n    # Generate random walk points\n    x = [0] * steps\n    y = [0] * steps\n    for i in range(steps):\n        r = randint(0, 1)\n        if r:  # Choose horizontal direction\n            x[i] = x[i - 1] + 1\n        else:  # Choose vertical direction\n            y[i] = y[i - 1] + 1\n    # Plot the points as red circles\n    plt.plot(x, y, 'ro')\n    # Display the plot\n    return plt.show()", "compilation_passed": true, "time": 0.0024302005767822266, "tests_passed": false, "error": "TypeError"}
{"code": "fig = plt.figure(figsize=(10, 10), dpi=150)\n\n    # set limits for x and y axes\n    fig.set_xlim([0, 1000])\n    fig.set_ylim([0, 1000])\n\n    # create x and y arrays for the points in the path\n    x, y = 500, 500\n    x_points = []\n    y_points = []\n\n    for i in range(POINTS):\n        # choose a random direction and distance for the next step\n        dirn = randint(0, 2)\n        dist = randint(0, 20)\n\n        if dirn == 0:\n            x -= dist\n        elif dirn == 1:\n            y -= dist\n        else:\n            x += dist\n        x_points.append(x)\n        y_points.append(y)\n\n        # choose a random color for the next step\n        color = (randint(0, 255), randint(0, ", "compilation_passed": false, "time": 0.00023984909057617188, "tests_passed": false, "error": "SyntaxError"}
{"code": "x_list = [0] * POINTS\n    y_list = [0] * POINTS\n    direction = 0\n    x = y = 0\n    for _ in range(POINTS):\n        direction = randint(0, 1000) % 4\n        if direction == 0:\n            y += 1\n        elif direction == 1:\n            x -= 1\n        elif direction == 2:\n            y -= 1\n        else:\n            x += 1\n        x_list.append(x)\n        y_list.append(y)\n\n    fig, ax = plt.subplots()\n    ax.scatter(x_list, y_list)\n    ax.plot(x_list, y_list)\n    ax.grid(True)\n    fig.show()\n    return fig", "compilation_passed": true, "time": 0.009467840194702148, "tests_passed": true, "error": null}
{"code": "x_vals = []\n    y_vals = []\n    x_vals.append(0)\n    y_vals.append(0)\n    for _ in range(POINTS):\n        x = x_vals[-1]\n        y = y_vals[-1]\n        d = randint(1,4)\n        if d == 1:\n            x += 1\n        elif d == 2:\n            x -= 1\n        elif d == 3:\n            y -= 1\n        elif d == 4:\n            y += 1\n        else:\n            print(\"No valid direction!\")\n        x_vals.append(x)\n        y_vals.append(y)\n    plt.plot(x_vals, y_vals)\n    plt.show()\n    return plt.figure()", "compilation_passed": true, "time": 0.008920907974243164, "tests_passed": false, "error": "TypeError"}
{"code": "x_points = [0]\n    y_points = [0]\n    for _ in range(POINTS):\n        x, y = 0, 0\n        while x == 0 and y == 0:\n            x_direction = randint(1, 4)\n            y_direction = randint(1, 4)\n            x = x + [1, 0, -1, 0][x_direction]\n            y = y + [1, 0, -1, 0][y_direction]\n\n        x_points.append(x)\n        y_points.append(y)\n    plt.plot(x_points, y_points, '.')\n    plt.show()\n    return plt.gcf()", "compilation_passed": true, "time": 0.0013091564178466797, "tests_passed": true, "error": null}
