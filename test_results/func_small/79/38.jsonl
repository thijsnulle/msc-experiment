{"code": "# Create a Python zipfile.ZipFile object to contain the ZIP contents\n    zipfile = zipfile.ZipFile(io.BytesIO())\n\n    for file_path in file_paths:\n        # If the file_path is a string, open it as a file-like object. Otherwise, assume it's already a file-like object\n        if isinstance(file_path, str):\n            file = open(file_path, 'rb')\n        else:\n            file = file_path\n\n        # Add the file contents to the zipfile\n        zipfile.write(file, arcname=os.path.basename(file.name))\n\n    return FileResponse(zipfile, as_attachment=True, filename='files.zip')", "compilation_passed": true, "time": 0.0008399486541748047, "tests_passed": false, "error": "UnboundLocalError"}
{"code": "response = FileResponse(content_type='application/zip')\n    response['Content-Disposition'] = f'attachment; filename=\"files.zip\"'\n    zip_buffer = io.BytesIO()\n    zip_file = zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED)\n    for path in file_paths:\n        if isinstance(path, str):\n            path = os.path.realpath(os.path.expanduser(path))\n            zip_file.write(path, os.path.basename(path))\n        elif isinstance(path, io.BytesIO):\n            zip_file.writestr('test.zip', path.getvalue())\n    zip_file.close()\n    response.content = zip_buffer.getvalue()\n    return response", "compilation_passed": true, "time": 0.0008189678192138672, "tests_passed": false, "error": "NameError"}
{"code": "if len(file_paths) < 1:\n        return FileResponse(b'')  # No need to create a zip\n\n    request = HttpRequest() if request is None else request\n    zip_file = io.BytesIO()\n    with zipfile.ZipFile(zip_file, 'w') as myZip:\n        for file_path in file_paths:\n            if isinstance(file_path, str):\n                try:\n                    with open(file_path, 'rb') as file:\n                        myZip.writestr(os.path.basename(file_path), file.read())\n                except FileNotFoundError:\n                    continue\n            else:\n                myZip.writestr(os.path.basename(file_path), file_path.read())\n\n    zip_file.seek(0)\n    return FileResponse(zip_file, as_attachment=True, filename='files.zip')", "compilation_passed": true, "time": 0.0020449161529541016, "tests_passed": true, "error": null}
{"code": "files_to_zip = []\n    for file_path in file_paths:\n        if isinstance(file_path, str):\n            try:\n                with open(file_path, 'rb') as f:\n                    files_to_zip.append(io.BytesIO(f.read()))\n            except FileNotFoundError:\n                print(f\"File {file_path} not found.\")\n        else:\n            files_to_zip.append(file_path)\n    response = FileResponse(io.BytesIO(zipfile.ZipFile(io.BytesIO(zipfile.ZipFile(files_to_zip).read())).read()))\n    response['Content-Type'] = 'application/zip'\n    response['Content-Disposition'] = 'attachment; filename=\"files.zip\"'\n    return response", "compilation_passed": true, "time": 0.0011267662048339844, "tests_passed": false, "error": "AttributeError"}
{"code": "zip_buffer = io.BytesIO()\n    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:\n        for file_path in file_paths:\n            if os.path.isfile(file_path):\n                zip_file.write(file_path, os.path.basename(file_path))\n            else:\n                zip_file.writestr(os.path.basename(file_path), file_path)\n    zip_buffer.seek(0)\n\n    response = FileResponse(zip_buffer, as_attachment=True)\n    response['Content-Disposition'] = f'attachment; filename=\"files.zip\"'\n    return response", "compilation_passed": true, "time": 0.0007369518280029297, "tests_passed": false, "error": "NameError"}
{"code": "response = FileResponse()\n    response['Content-Type'] = 'application/zip'\n    response['Content-Disposition']\n    response['Content-Disposition']\n    with zipfile.ZipFile(io.BytesIO()) as zip_buffer:\n        for file_path in file_paths:\n            if isinstance(file_path, str):\n                zip_buffer.write(file_path, arcname=os.path.basename(file_path))\n            else:\n                zip_buffer.writestr(os.path.basename(file_path.name), file_path.read())\n    response.content = zip_buffer.getbuffer()\n    return response", "compilation_passed": true, "time": 0.0014450550079345703, "tests_passed": false, "error": "KeyError"}
{"code": "with ZipFile(io.BytesIO()) as zipfile:\n        for file_path in file_paths:\n            if hasattr(file_path, 'read'):\n                zipfile.writestr(os.path.basename(file_path.name), file_path.read())\n            else:\n                zipfile.write(file_path, os.path.basename(file_path))\n\n    response = FileResponse(zipfile.open())\n    response['Content-Type'] = 'application/zip'\n    if hasattr(settings, 'DOWNLOAD_FILENAME'):\n        response['Content-Disposition'] = f'attachment; filename=\"{settings.DOWNLOAD_FILENAME}\"'\n    return response", "compilation_passed": true, "time": 0.0008149147033691406, "tests_passed": false, "error": "NameError"}
{"code": "if file_paths == []:\n        return FileResponse()\n    if len(file_paths) == 1:\n        if file_paths[0].endswith(\".zip\"):\n            return FileResponse(\n                File(\n                    io.StringIO(\n                        zipfile.ZipFile(file_paths[0]).read(file_paths[0].name).decode(\"utf-8\")\n                    ),\n                    as_attachment=True,\n                    content_type=\"application/zip\",\n                )\n            )\n\n    response = FileResponse(\n        io.StringIO(\n            zipfile.ZipFile(io.BytesIO(b''.join(file_paths))).read(file_paths[0].name).decode(\"utf-8\")\n        ),\n        as_attachment=True,\n        content_type=\"application/zip\",\n    )\n    response[\"Content-Disposition\"] = \"attachment; filename=\" + (\n        request.POST[\"filename\"] if \"filename\"", "compilation_passed": false, "time": 0.00021195411682128906, "tests_passed": false, "error": "SyntaxError"}
{"code": "zip_bytes = io.BytesIO()\n    with zipfile.ZipFile(zip_bytes, 'w') as zip_file:\n        for file_path in file_paths:\n            if isinstance(file_path, str):\n                with open(file_path, 'rb') as f:\n                    zip_file.writestr(file_path, f.read())\n            else:\n                zip_file.writestr(file_path.name, file_path.read())\n    zip_bytes = zip_bytes.getvalue()\n    response = FileResponse(zip_bytes, filename='files.zip')\n    response['Content-Disposition'] = 'attachment; filename=\"files.zip\"'\n    return response", "compilation_passed": true, "time": 0.0008211135864257812, "tests_passed": false, "error": "FileNotFoundError"}
{"code": "response = FileResponse()\n    try:\n        # Create an in-memory file-like object for the ZIP file\n        buffer = io.BytesIO()\n        # Create a new ZIP file with compression level 9 (maximum compression)\n        with zipfile.ZipFile(buffer, mode='w', compression=zipfile.ZIP_DEFLATED, compresslevel=9) as zip_file:\n            for file_path in file_paths:\n                # If the file path is not a string, assume it's a file-like object\n                if not isinstance(file_path, str):\n                    if hasattr(file_path, 'read'):\n                        file_path.seek(0)\n                        zip_file.writestr(str(uuid.uuid4()), file_path.read())\n                        continue\n                    else:\n                        raise ValueError(\n                            f\"Invalid file path: {file_path}. File paths must be strings or file-like objects.\")\n                # If the file path is a string, open it as a file object\n                with open(file_", "compilation_passed": false, "time": 0.00020074844360351562, "tests_passed": false, "error": "SyntaxError"}
{"code": "zip_buffer = io.BytesIO()\n    with ZipFile(zip_buffer, 'w') as zip_file:\n        for file_path in file_paths:\n            if isinstance(file_path, str):\n                zip_file.write(file_path)\n            elif isinstance(file_path, io.BytesIO):\n                zip_file.writestr(file_path.name, file_path.getvalue())\n\n    response = FileResponse(zip_buffer)\n    response['Content-Type'] = 'application/zip'\n    response['Content-Disposition'] = 'attachment; filename=files.zip'\n\n    return response", "compilation_passed": true, "time": 0.0007150173187255859, "tests_passed": false, "error": "NameError"}
{"code": "response = FileResponse()\n    response.set_file(\n        io.BytesIO(\n            zipfile.ZipFile(\n                io.BytesIO(), 'wb', compression=zipfile.ZIP_DEFLATED\n            ).writestr(\n                'files.zip', b''\n            ).getbuffer()\n        )\n    )\n    response['Content-Type'] = 'application/zip'\n    response['Content-Disposition']\n    response['Content-Disposition'] = \"attachment; filename=files.zip\"\n    files_list = []\n\n    for file_path in file_paths:\n        try:\n            if file_path.startswith(\"http://\") or file_path.startswith(\"https://\"):\n                response.set_file(\n                    io.BytesIO(\n                        request_urlopen(url=file_path).read()\n                    )\n                )\n            elif file_path.startswith(\"/\") or file_path.startswith(\"\\\\\"):\n                with open(file_path,", "compilation_passed": false, "time": 0.00019979476928710938, "tests_passed": false, "error": "SyntaxError"}
{"code": "zip_output = io.BytesIO()\n    zip_file = zipfile.ZipFile(zip_output, 'w')\n\n    for file_path in file_paths:\n        if isinstance(file_path, str):\n            zip_file.write(file_path, file_path)\n        else:\n            zip_file.writestr(file_path.name, file_path.read())\n\n    zip_file.close()\n\n    response = FileResponse(zip_output)\n    response['Content-Type'] = 'application/zip'  # Specify the MIME type for ZIP files\n\n    # Set the appropriate Content-Disposition header based on the request\n    response['Content-Disposition'] = 'attachment; filename=\"{filename}.zip\"'.format(filename=settings.APP_NAME)\n\n    return response", "compilation_passed": true, "time": 0.0008261203765869141, "tests_passed": false, "error": "FileNotFoundError"}
{"code": "zip_buffer = io.BytesIO()\n    zip_file = zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED)\n\n    for file_path in file_paths:\n        if isinstance(file_path, str):\n            zip_file.write(file_path)\n        else:\n            zip_file.writestr(zipfile.ZipInfo(os.path.basename(file_path)), file_path)\n\n    zip_buffer.seek(0)\n\n    return FileResponse(zip_buffer)", "compilation_passed": true, "time": 0.0007219314575195312, "tests_passed": false, "error": "FileNotFoundError"}
{"code": "response = FileResponse(FileWrapper(ZipFile(io.BytesIO(compress_files(file_paths)))))\n    response['Content-Type'] = 'application/zip'\n    response['Content-Disposition'] = f'attachment; filename=\"{response.filename}\"'\n    return response", "compilation_passed": true, "time": 0.0006189346313476562, "tests_passed": false, "error": "NameError"}
{"code": "response = HttpResponse(content_type='application/zip')\n    response['Content-Disposition'] = 'attachment; filename=\"files.zip\"'\n    zip_buffer = io.BytesIO()\n    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:\n        for file_path in file_paths:\n            if isinstance(file_path, str):\n                with io.open(file_path, 'rb') as f:\n                    zip_file.writestr(os.path.basename(file_path), f.read())\n            elif isinstance(file_path, io.IOBase):\n                zip_file.writestr(os.path.basename(file_path.name), file_path.read())\n    response.streaming = True\n    response.set_content(zip_buffer.getvalue())\n    return response", "compilation_passed": true, "time": 0.0008051395416259766, "tests_passed": false, "error": "NameError"}
{"code": "# Create an in-memory file to hold the zip contents\n    zip_file = io.BytesIO()\n    zip_writer = zipfile.ZipFile(zip_file, 'w')\n\n    # Add each file to the zip\n    for file_path in file_paths:\n        if isinstance(file_path, str) and os.path.exists(file_path):\n            zip_writer.write(file_path, os.path.basename(file_path))\n        elif isinstance(file_path, (io.BytesIO, io.StringIO)):\n            zip_writer.writestr(os.path.basename(file_path.name), file_path.read())\n        else:\n            raise TypeError(\"file_path must be a string or file-like object\")\n\n    zip_writer.close()\n    zip_file.seek(0)  # Move file pointer to the start of the ZIP file\n\n    # Create a FileResponse object for the ZIP file and return it\n    response = FileResponse(\n        zip_file,\n        content_type='application/", "compilation_passed": false, "time": 8.606910705566406e-05, "tests_passed": false, "error": "SyntaxError"}
{"code": "response = FileResponse()\n    response.set_content_disposition('attachment')\n    response.set_content_type('application/zip')\n    with ZipFile(io.BytesIO(), mode='w') as zip_file:\n        for file_path in file_paths:\n            with io.open(file_path, mode='rb') as file:\n                zip_file.writestr(os.path.basename(file_path), file.read())\n    response['Content-Disposition'] = response.content_disposition.replace('attachment', 'inline')\n    response.file.seek(0)\n    return response", "compilation_passed": true, "time": 0.0007052421569824219, "tests_passed": false, "error": "AttributeError"}
{"code": "response = FileResponse()  # Create an empty FileResponse object\n    response['Content-Type'] = 'application/zip'  # Set the Content-Type to 'application/zip'\n\n    # Determine whether the response needs to be returned immediately or is instead set to the client via a view\n    response.headers['Content-Disposition'] = 'attachment; filename=\"files.zip\"'\n    response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, max-age=0'\n    response.headers['Pragma'] = 'no-cache'\n    response._headers['Content-Length'] = 0  # Set the Content-Length to 0 to avoid triggering caching\n    # response.headers['Expires'] = 'Thu, 01 Jan 1970 00:00:00 GMT'  # Set the Expires header to zero to prevent caching\n\n    with ZipFile(io.BytesIO(), 'w') as zip_file:  # Create a ZipFile object and open it in write mode\n        for path in file_paths:\n            if os.path", "compilation_passed": false, "time": 0.00012493133544921875, "tests_passed": false, "error": "SyntaxError"}
{"code": "response = FileResponse()\n    zip_buffer = io.BytesIO()\n    zip_writer = zipfile.ZipFile(zip_buffer, 'w', compression=zipfile.ZIP_DEFLATED, compresslevel=6)\n    for file in file_paths:\n        if isinstance(file, (str, pathlib.PurePosixPath)):\n            zip_writer.write(file.as_posix())\n        else:\n            zip_writer.writestr(file.name, file.read())\n    zip_writer.close()\n    zip_buffer.seek(0)\n    response.content = zip_buffer.read()\n    return response", "compilation_passed": true, "time": 0.0007750988006591797, "tests_passed": false, "error": "NameError"}
{"code": "files = []\n\n    for file_path in file_paths:\n        try:\n            with open(file_path, 'rb') as f:\n                content = f.read()\n                if file_path.endswith(\".json\"):\n                    file_content = json.dumps(content)\n                else:\n                    file_content = content\n                files.append((file_path, io.BytesIO(file_content)))\n        except (FileNotFoundError, OSError) as e:\n            print(\"ERROR: {}\".format(e))\n\n    zipped_file = io.BytesIO()\n    with zipfile.ZipFile(zipped_file, 'w') as zf:\n        for filename, content in files:\n            zf.writestr(filename, content)\n\n    response = FileResponse(zipped_file)\n    response['Content-Type'] = 'application/zip'\n    response['Content-Disposition'] = 'attachment; filename=\"{}\"'.format(\"files.zip\")\n\n    return response", "compilation_passed": true, "time": 0.0016367435455322266, "tests_passed": true, "error": null}
{"code": "response = FileResponse()\n\n    # Open zip file in binary mode and create the zip file from the input data.\n    zip_file = io.BytesIO()\n    with zipfile.ZipFile(zip_file, 'w', compression=zipfile.ZIP_DEFLATED) as myzip:\n        for path in file_paths:\n            if isinstance(path, str):\n                # Check if the path is a file or a directory and add it to the zip.\n                if os.path.isdir(path):\n                    myzip.write(path)\n                    myzip.namelist()[-1]\n                else:\n                    myzip.write(path)\n            else:\n                # Check if the path is an in-memory buffer and add it to the zip.\n                if hasattr(path, \"seekable\") and path.seekable() and path.tell():\n                    myzip.write(path)\n\n    zip_file.seek(0)  # Go to the start of the zip file.\n    response.set_content(zip_file)  # Set the response content as the", "compilation_passed": true, "time": 0.0007750988006591797, "tests_passed": false, "error": "NameError"}
{"code": "file_paths = [\n        file_path for file_path in file_paths if os.path.exists(file_path)\n    ]\n\n    if not file_paths:\n        return FileResponse(b'No files found.', content_type='text/plain', status=404)\n\n    with ZipFile(io.BytesIO(), 'w', ZIP_DEFLATED) as archive:\n        for file_path in file_paths:\n            archive.write(file_path, arcname=os.path.basename(file_path))\n\n        response = FileResponse(archive.getbuffer())\n\n    response['Content-Disposition'] = f\"attachment; filename=\\\"{response['filename']}\\\";\"\n    response['Content-Type'] = 'application/zip'\n    return response", "compilation_passed": true, "time": 0.0007801055908203125, "tests_passed": false, "error": "NameError"}
{"code": "zip_file = io.BytesIO()\n    zip_file.write(zipfile.ZIP_STORED)  # We want the ZIP file stored in memory\n\n    # Create a ZIP archive with the specified files\n    archive_iter = (\n        zipfile.ZipInfo.from_file(file_path)\n        for file_path in file_paths\n    )\n    archive = zipfile.ZipFile(zip_file, \"w\")\n    for zipinfo in archive_iter:\n        archive.writestr(zipinfo, io.BytesIO(file_paths[zipinfo]))\n    zip_file.seek(0)  # Reset the buffer pointer to the beginning of the ZIP file\n\n    return FileResponse(zip_file, as_attachment=True, filename=\"files.zip\")", "compilation_passed": true, "time": 0.0007078647613525391, "tests_passed": false, "error": "TypeError"}
{"code": "with ZipFile(io.BytesIO(), mode='w') as output_zip:\n        for file in file_paths:\n            if os.path.isfile(file):\n                # Extract file to zip\n                output_zip.write(file)\n            else:\n                # Extract file content\n                output_zip.writestr(file.name, file.read())\n    response = FileResponse(output_zip, as_attachment=True, filename=\"files.zip\")\n    response['Content-Type'] = \"application/zip\"\n    response['Content-Disposition'] = \"attachment; filename=files.zip\"\n    response['Content-Encoding'] = \"identity\"\n    response['Access-Control-Allow-Origin'] = '*'\n    response.header['Cache-Control'] = 'no-cache, no-store, must-revalidate, max-age=0'\n    return response", "compilation_passed": true, "time": 0.0007579326629638672, "tests_passed": false, "error": "NameError"}
{"code": "zf = zipfile.ZipFile(io.BytesIO(), 'w', compression=zipfile.ZIP_DEFLATED, compresslevel=6)\n    for path in file_paths:\n        if os.path.exists(path):\n            zf.write(path, os.path.basename(path), zipfile.ZIP_DEFLATED)\n    response = FileResponse(zf)\n    response['Content-Type'] = 'application/zip'\n    response['Content-Disposition'] = 'attachment; filename=\"{}.zip\"'.format(os.path.splitext(os.path.basename(file_paths[0]))[0])\n    return response", "compilation_passed": true, "time": 0.0006909370422363281, "tests_passed": false, "error": "NameError"}
{"code": "# Create a list to store file paths and contents, in the order that they should appear in the zip file\n    file_paths_and_contents = []\n\n    # Iterate through each file path and get the contents if it exists as a file.\n    # Otherwise, it should just be an uploaded file so use a temp file for it\n    for file_path in file_paths:\n        if os.path.isfile(file_path):\n            with open(file_path, 'rb') as f:\n                file_paths_and_contents.append((file_path, f.read()))\n        else:\n            with open(io.BytesIO(file_path)) as f:\n                file_paths_and_contents.append((file_path, f.read()))\n\n    # Create a ZipFile instance using the BytesIO buffer, which allows for direct streaming of data to the client.\n    # Add each file path and contents pair to the zip file as a new archive member, along with its associated path and data.\n    zip_buffer = io.BytesIO()\n    with zipfile.ZipFile(zip_buffer, mode='", "compilation_passed": false, "time": 7.605552673339844e-05, "tests_passed": false, "error": "SyntaxError"}
{"code": "zip_file = io.BytesIO()\n    with ZipFile(zip_file, 'w', compression=zipfile.ZIP_DEFLATED) as zipf:\n        for path in file_paths:\n            zipf.write(path)\n    zip_file.seek(0)\n    return FileResponse(zip_file, as_attachment=True)", "compilation_passed": true, "time": 0.0007002353668212891, "tests_passed": false, "error": "NameError"}
{"code": "if isinstance(file_paths, list):\n        paths = file_paths\n    else:\n        paths = [file_paths]\n    zip_file = io.BytesIO()\n    zip_archive = zipfile.ZipFile(zip_file, 'w', compression=zipfile.ZIP_DEFLATED)\n    for file_path in paths:\n        if hasattr(file_path, 'seek'):\n            file_path.seek(0)\n            file_content = file_path.read()\n        else:\n            with open(file_path, 'rb') as file:\n                file_content = file.read()\n        zip_archive.writestr(os.path.basename(file_path), file_content)\n    zip_archive.close()\n    zip_file.seek(0)\n    response = FileResponse(zip_file)\n    response['Content-Disposition'] = 'attachment; filename=\"{}\"'.format(\n        os.path.basename(os.path.join(settings.MEDIA_ROOT, paths[0])))\n    response", "compilation_passed": true, "time": 0.0008392333984375, "tests_passed": false, "error": "FileNotFoundError"}
{"code": "response = FileResponse()\n    file_response = io.BytesIO()\n    with ZipFile(file_response, 'w') as zip_file:\n        for file_path in file_paths:\n            zip_file.write(file_path)\n    response.content = file_response.getvalue()\n    response['Content-Type'] = 'application/zip'\n    response['Content-Disposition'] = f'attachment; filename=\"files.zip\"'\n    response.file_name = 'files.zip'\n    return response", "compilation_passed": true, "time": 0.0006699562072753906, "tests_passed": false, "error": "NameError"}
