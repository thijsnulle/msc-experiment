{"code": "matches = {}\n\n    try:\n        # os.walk returns the three tuples: dirpath, dirs, files.\n        for (dirpath, dirs, files) in os.walk(directory_path):\n            # Loop over files and open each file to read.\n            for file in files:\n                # Filter out non-text files.\n                if not file.endswith('.txt'):\n                    continue\n\n                file_path = os.path.join(dirpath, file)\n\n                # Try to read the text file. If it cannot be opened, continue to next file.\n                try:\n                    with open(file_path, 'r') as f:\n                        text = f.read()\n                except:\n                    continue\n\n                # Extract matches using regex and store them in the dictionary.\n                matches[Path(file).stem] = re.findall(regex_pattern, text)\n\n    except:\n        pass\n\n    return matches", "compilation_passed": true, "time": 0.0019729137420654297, "tests_passed": true, "error": null}
{"code": "# Checking input arguments\n    if not directory_path:\n        raise ValueError('Directory path must not be empty.')\n    if regex_pattern is None:\n        regex_pattern = REGEX_PATTERN\n\n    # Processing arguments\n    directory_path = Path(directory_path)\n\n    # Checking existence and readability\n    if not directory_path.exists():\n        raise IOError('Directory does not exist.')\n    if not directory_path.is_dir():\n        raise IOError('Path is not a directory.')\n\n    # Collecting text files\n    text_files = glob.glob(f'{directory_path}/*.txt')\n\n    # If there are no text files, return an empty dict\n    if not text_files:\n        return {}\n\n    # Extracting matches from all text files in the directory\n    matches = {}\n    for file_path in text_files:\n        matches[Path(file_path).stem] = extract_matches(file_path, regex_pattern)\n\n    # Returning a dictionary containing the matches\n    return matches", "compilation_passed": true, "time": 0.001779794692993164, "tests_passed": false, "error": "NameError"}
{"code": "matches = {}\n\n    for file in glob.glob(f'{directory_path}/*'):\n        with open(file, 'r', encoding='utf8') as file:\n            contents = file.read()\n            matches[file.name[:-4]] = re.findall(regex_pattern, contents)\n\n    return matches", "compilation_passed": true, "time": 0.0018358230590820312, "tests_passed": true, "error": null}
{"code": "regex = re.compile(regex_pattern)\n    matches: dict = {}\n\n    for file_path in glob.glob(f'{directory_path}/*.txt'):\n        with open(file_path, 'r') as file:\n            content = file.read()\n            matches[Path(file_path).stem] = [match[0] for match in re.finditer(regex, content) if match]\n    return matches", "compilation_passed": true, "time": 0.002103090286254883, "tests_passed": true, "error": null}
{"code": "matches = {}\n    directory = Path(directory_path)\n    for file_path in glob.glob(directory.joinpath(\"**/*.txt\"), recursive=True):\n        if file_path.name.startswith(\".\") or file_path.name.startswith(\"_\"):\n            continue\n\n        with open(file_path, \"r\") as f:\n            text = f.read()\n            matches[file_path.name] = re.findall(regex_pattern, text)\n\n    return matches", "compilation_passed": true, "time": 0.0021331310272216797, "tests_passed": false, "error": "TypeError"}
{"code": "matches = {}\n    file_paths = glob.glob(os.path.join(directory_path, '**', '*.txt'), recursive=True)\n    for file_path in file_paths:\n        with open(file_path, 'r', encoding='utf-8') as f:\n            text_content = f.read()\n            matches[os.path.basename(file_path)[:-4]] = re.findall(regex_pattern, text_content)\n    return matches", "compilation_passed": true, "time": 0.002074718475341797, "tests_passed": true, "error": null}
{"code": "matches = {}\n    if not os.path.isdir(directory_path):\n        print(f\"{directory_path} is not a directory!\")\n        return matches\n\n    for file in glob.glob(os.path.join(directory_path, '*')):\n        if os.path.isdir(file):\n            continue\n\n        with open(file, 'r') as file_stream:\n            file_text = file_stream.read()\n            matches_ = re.findall(regex_pattern, file_text)\n            file_name = Path(file).stem\n\n            # If regex matches were found\n            if matches_:\n                matches[file_name] = matches_\n            else:\n                matches[file_name] = []\n    return matches", "compilation_passed": true, "time": 0.002063274383544922, "tests_passed": true, "error": null}
{"code": "matches = {}\n\n    # Check that the given directory path exists\n    if not os.path.exists(directory_path):\n        raise FileNotFoundError(f\"Directory not found: '{directory_path}'\")\n\n    # Check that the given regex pattern is a valid regular expression\n    regex = re.compile(regex_pattern)\n    if not regex:\n        raise ValueError(f\"Invalid regex pattern: '{regex_pattern}'\")\n\n    # Iterate over all files in the directory\n    for file in glob.glob(f'{directory_path}/**/*.txt'):\n        # Check if the file exists\n        if not os.path.exists(file):\n            raise FileNotFoundError(f\"File not found: '{file}'\")\n\n        # Read the file contents\n        with open(file, 'r') as f:\n            content = f.read()\n\n        # Extract matches from the content using the regular expression\n        matches_dict = regex.findall(content)\n        matches_dict = {os.path.basename(file): matches_dict}\n\n        # Update the", "compilation_passed": true, "time": 0.001772165298461914, "tests_passed": true, "error": null}
{"code": "matches = {}\n    text_file_paths = glob.glob(os.path.join(directory_path, '*.txt'))\n    for text_file_path in text_file_paths:\n        with open(text_file_path, 'r', encoding='utf-8') as file:\n            matches[os.path.basename(text_file_path)] = [match for match in re.findall(regex_pattern, file.read())]\n    return matches", "compilation_passed": true, "time": 0.003325223922729492, "tests_passed": true, "error": null}
{"code": "regex = re.compile(regex_pattern)\n    matches_dict = dict()\n\n    for file_path in glob.glob(directory_path + '/**/*.txt', recursive=True):\n        with open(file_path, 'r') as file:\n            file_contents = file.read()\n\n            matches = regex.findall(file_contents)\n\n            if matches:\n                matches_dict[os.path.basename(file_path)] = matches\n\n    return matches_dict", "compilation_passed": true, "time": 0.0018491744995117188, "tests_passed": true, "error": null}
{"code": "matches_dict = {}\n    # Create a dictionary to store the matches for each file\n\n    for filename in glob.glob(os.path.join(directory_path, '*.txt')):\n        with open(filename, 'r', encoding=\"utf8\") as file:\n            text = file.read()\n        matches = re.findall(regex_pattern, text)\n        matches_dict[filename.split(\"\\\\\")[-1]] = matches\n    # Read text files from the specified directory\n    # and match them with the regex pattern\n\n    return matches_dict\n    # Return the dictionary of matches", "compilation_passed": true, "time": 0.0018661022186279297, "tests_passed": true, "error": null}
{"code": "matches: dict = {}\n    regex_pattern: str = r'(?:(?:\\\\)?)(.+?)(?:\\\\)?'\n    regex_obj: re.Pattern = re.compile(regex_pattern)\n\n    path: Path = Path(directory_path)\n\n    for file in sorted(glob.glob(path.joinpath('**/*.txt'), recursive=True)):\n        with open(file, 'r', encoding='utf-8') as text_file:\n            text: str = text_file.read()\n            matches.update({file.name: list(regex_obj.findall(text))})\n\n    return matches", "compilation_passed": true, "time": 0.0018107891082763672, "tests_passed": false, "error": "TypeError"}
{"code": "matches = {}\n    # Extract the filenames and paths of all text files in the directory\n    filenames = [f.name for f in Path(directory_path).glob(\"**/*.txt\")]\n\n    for filename in filenames:\n        with open(os.path.join(directory_path, filename), \"r\") as file:\n            contents = file.read()\n\n            pattern = re.compile(regex_pattern)\n            matches_in_file = pattern.findall(contents)\n            matches[filename] = matches_in_file\n\n    return matches", "compilation_passed": true, "time": 0.003545045852661133, "tests_passed": true, "error": null}
{"code": "matches = {}\n    matches = {}\n    for filename in glob.glob(os.path.join(directory_path, '*.txt')):\n        with open(filename, 'r') as file:\n            text = file.read()\n            matches[os.path.basename(filename).rsplit('.', 1)[0]] = re.findall(regex_pattern, text)\n    return matches", "compilation_passed": true, "time": 0.0018339157104492188, "tests_passed": true, "error": null}
{"code": "# Create a dictionary to store the matches\n    matches = {}\n\n    # Create a list of all text files in the directory\n    text_files = glob.glob(os.path.join(directory_path, '**/*.txt'), recursive=True)\n\n    # Iterate through all text files\n    for text_file in text_files:\n        # Get the relative path of the text file\n        relative_path = os.path.relpath(text_file, directory_path)\n        relative_path = relative_path.replace(os.path.sep, os.path.altsep or os.path.sep)\n\n        # Read the contents of the file\n        with open(text_file, 'r', encoding='utf-8') as f:\n            contents = f.read()\n\n        # Use re to find matches based on the regex pattern\n        matches[relative_path] = re.findall(regex_pattern, contents)\n\n    return matches", "compilation_passed": true, "time": 0.0036020278930664062, "tests_passed": true, "error": null}
{"code": "matches = {}\n\n    for filename in glob.glob(directory_path):\n\n        with open(filename, 'r', encoding=\"utf8\") as f:\n            text = f.read()\n            match = re.search(regex_pattern, text, re.I)\n\n            if match:\n                matches[Path(filename).stem] = match.groups()\n\n    return matches", "compilation_passed": true, "time": 0.0017108917236328125, "tests_passed": false, "error": "IsADirectoryError"}
{"code": "matches = {}\n\n    regex_pattern = REGEX_PATTERN if regex_pattern is None else regex_pattern\n    regex = re.compile(regex_pattern)\n\n    for file_path in Path(directory_path).glob('**/*.txt'):\n        try:\n            with open(file_path, 'r') as f:\n                content = f.read()\n                matches[file_path.stem] = regex.findall(content)\n        except (FileNotFoundError, UnicodeDecodeError):\n            continue\n\n    return matches", "compilation_passed": true, "time": 0.0019412040710449219, "tests_passed": true, "error": null}
{"code": "matches: dict[str, list[str]] = {}\n\n    if not os.path.isdir(directory_path):\n        raise RuntimeError(\"Invalid directory path\")\n\n    for file_name in Path(directory_path).glob('*'):\n        file_name: Path = file_name\n        if not file_name.is_file() or not file_name.suffix.lower() == '.txt':\n            continue\n\n        with open(file_name, 'r', encoding='utf8') as file:\n            lines = file.readlines()\n\n            pattern = re.compile(regex_pattern)\n            matches_in_file = {file_name: pattern.findall(\"\\n\".join(lines))}\n\n            for file_name, file_matches in matches_in_file.items():\n                matches[file_name] = file_matches\n\n    return matches", "compilation_passed": true, "time": 0.001964092254638672, "tests_passed": true, "error": null}
{"code": "matches = {}\n\n    for file_path in glob.glob(os.path.join(directory_path, '**/*.txt'), recursive=True):\n        with open(file_path) as f:\n            for line in f:\n                match = re.search(regex_pattern, line)\n                if match:\n                    if match.group(1) is not None:\n                        name = match.group(1)\n                        matches[os.path.basename(file_path).split('.')[0]] = matches.get(os.path.basename(file_path).split('.')[0], []) + [name.strip()]\n    return matches", "compilation_passed": true, "time": 0.0019788742065429688, "tests_passed": true, "error": null}
{"code": "matches = {}\n    regex = re.compile(regex_pattern)\n    for file in glob.iglob(directory_path + '/*.txt'):\n        with open(file, 'r', encoding='utf-8') as file:\n            for line in file:\n                match = regex.findall(line)\n                if match:\n                    matches[Path(file).name] = match\n    return matches", "compilation_passed": true, "time": 0.0018131732940673828, "tests_passed": true, "error": null}
{"code": "matches = {}\n\n    for file in glob.glob(os.path.join(directory_path, '*')):\n        # Get the file name without path\n        name = Path(file).name\n\n        if not name.startswith('.'):\n            with open(file, 'r') as f:\n                for line in f:\n                    matches.setdefault(name, []).append(\n                        re.findall(regex_pattern, line)[0])\n\n    return matches", "compilation_passed": true, "time": 0.0016989707946777344, "tests_passed": false, "error": "IndexError"}
{"code": "matches = {}\n    regex = re.compile(regex_pattern)\n    for filename in os.listdir(directory_path):\n        path = Path(directory_path) / filename\n        if path.is_file() and path.suffix == '.txt':\n            with open(path, 'r', encoding='utf-8') as file:\n                text = file.read()\n                match = regex.findall(text)\n                if match:\n                    matches[filename[:-4]] = match\n    return matches", "compilation_passed": true, "time": 0.0017840862274169922, "tests_passed": true, "error": null}
{"code": "matches = {}\n    if not os.path.exists(directory_path):\n        raise ValueError(\"Directory path not found!\")\n    regex = re.compile(regex_pattern)\n\n    for filename in glob.glob(f'{directory_path}\\\\**\\\\*.txt', recursive=True):\n        with open(filename, \"r\", encoding='UTF8') as file:\n            text = file.read()\n            matches[Path(filename).stem] = [match.group(0) for match in re.finditer(regex, text)]\n    return matches", "compilation_passed": true, "time": 0.0018551349639892578, "tests_passed": true, "error": null}
{"code": "matches = {}\n    for file_path in Path(directory_path).rglob(\"*.txt\"):\n        file_name = file_path.name\n        if not file_name.startswith(\".\") and not file_name.endswith(\".txt\"):\n            # skip hidden files and text files\n            continue\n\n        matches[file_name] = []\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as file:\n                text = file.read()\n        except UnicodeDecodeError:\n            continue\n\n        matches[file_name].extend(re.findall(regex_pattern, text))\n    return matches", "compilation_passed": true, "time": 0.003476858139038086, "tests_passed": true, "error": null}
{"code": "matches: dict[Path, list[str]] = {}\n    for path in glob.glob(os.path.join(directory_path, '**'), recursive=True):\n        if Path(path).is_file():\n            if re.search(regex_pattern, os.path.basename(path)):\n                matches[Path(path).stem] = re.findall(regex_pattern, os.path.basename(path))\n    return matches", "compilation_passed": true, "time": 0.0017819404602050781, "tests_passed": true, "error": null}
{"code": "matches = {}\n    for filename in glob.glob(directory_path + r'\\\\*.txt'):\n        with open(filename, encoding='utf-8') as file:\n            file_content = file.read()\n            matches[Path(filename).stem] = re.findall(regex_pattern, file_content)\n\n    return matches", "compilation_passed": true, "time": 0.0017211437225341797, "tests_passed": true, "error": null}
{"code": "matches = {}\n\n    # Check for invalid input and raise exceptions\n    if not os.path.isdir(directory_path):\n        raise IOError('Directory path is not valid')\n\n    # Iterate through all text files in the directory\n    for file_path in Path(directory_path).rglob(\"*.txt\"):\n        # Check if file is a text file (e.g., not a log file)\n        if Path(file_path).suffix.lower() == '.txt':\n            with open(file_path, 'r') as file:\n                matches[file_path.stem] = [m.group() for m in re.finditer(regex_pattern, file.read())]\n\n    return matches", "compilation_passed": true, "time": 0.001961946487426758, "tests_passed": true, "error": null}
{"code": "matches = {}\n\n    # Path object to the directory\n    directory_path_obj = Path(directory_path)\n\n    # Check if the directory exists\n    if not directory_path_obj.exists():\n        raise FileNotFoundError(f'Directory: {directory_path_obj.name} does not exist')\n\n    # If it exists, process each text file in the directory\n    for file in glob.glob(directory_path_obj / '*.txt'):\n\n        # Get the file name without path\n        file_name = file.name.split('.')[0]\n        # Get the contents of the file\n        file_contents = file.read_text()\n        # Check if the file contents are empty or None\n        if not file_contents:\n            raise FileNotFoundError(f'File: {file_name} is empty')\n\n        # Define the pattern to match\n        pattern = re.compile(regex_pattern)\n        # Match the contents of the file with the pattern\n        matches_in_file = pattern.findall(file_contents)\n        # If there are no matches, raise an error", "compilation_passed": true, "time": 0.0017271041870117188, "tests_passed": false, "error": "TypeError"}
{"code": "matches: dict = {}\n\n    # TODO: Make sure that the directory passed exists\n    for file_path in glob.glob(directory_path + '\\\\**\\\\*.txt', recursive=True):\n        with open(file_path, 'r', encoding='utf-8') as file:\n            file_name = os.path.basename(file_path)\n            file_name, extension = os.path.splitext(file_name)\n            matches[file_name] = [match.group() for match in re.finditer(regex_pattern, file.read())]\n    return matches", "compilation_passed": true, "time": 0.001688241958618164, "tests_passed": true, "error": null}
{"code": "matches = {}\n\n    if not os.path.isdir(directory_path):\n        return matches\n    for file_path in glob.glob(os.path.join(directory_path, '*')):\n        if not file_path.endswith(\".txt\"):\n            continue\n        matches[os.path.basename(file_path)[:-4]] = list(re.findall(regex_pattern, Path(file_path).read_text()))\n    return matches", "compilation_passed": true, "time": 0.0018360614776611328, "tests_passed": true, "error": null}
