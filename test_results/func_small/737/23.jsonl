{"code": "return np.median(np.ndarray.flatten(L))", "compilation_passed": true, "time": 0.00048089027404785156, "tests_passed": false, "error": "TypeError"}
{"code": "# Your code starts here.\n    L = list(map(list, L))\n\n    for i in L:\n        if type(i) == list:\n            i.sort()\n\n    L.sort()\n\n    if len(L) % 2 != 0:\n        median = L[math.floor(len(L) / 2)]\n    else:\n        median = (L[len(L) // 2 - 1] + L[len(L) // 2]) / 2\n    return median", "compilation_passed": true, "time": 0.0006442070007324219, "tests_passed": false, "error": "TypeError"}
{"code": "median = 0\n\n    L2 = list()\n\n    for i in L:\n        L2.extend(i)\n\n    L2.sort()\n    length = len(L2)\n    if length % 2 == 0:\n        median = (L2[length // 2 - 1] + L2[length // 2]) / 2\n    else:\n        median = L2[length // 2]\n    return median", "compilation_passed": true, "time": 0.0005590915679931641, "tests_passed": false, "error": "TypeError"}
{"code": "# return median_iterative_v2(L)\n    return median_recursive(L, 0, len(L))", "compilation_passed": true, "time": 0.0004711151123046875, "tests_passed": false, "error": "NameError"}
{"code": "# your code\n    return median", "compilation_passed": true, "time": 0.00046372413635253906, "tests_passed": false, "error": "NameError"}
{"code": "flat_list = [num for sublist in L for num in sublist]\n    flat_list.sort()\n    n = len(flat_list)\n\n    if n % 2 == 0:\n        median1 = flat_list[n//2]\n        median2 = flat_list[n//2 - 1]\n        median = (median1 + median2) / 2\n    else:\n        median = flat_list[n//2]\n\n    return median", "compilation_passed": true, "time": 0.0006308555603027344, "tests_passed": false, "error": "TypeError"}
{"code": "L = np.asanyarray(L)\n    L = L.tolist()\n    if L == []:\n        return None\n    if len(L) == 1:\n        return L[0]\n    L.sort()\n    if len(L) % 2 == 0:\n        return L[int(len(L)/2)]\n    return (L[int(len(L)/2) - 1] + L[int(len(L)/2)])/2", "compilation_passed": true, "time": 0.0005781650543212891, "tests_passed": false, "error": "ValueError"}
{"code": "flat_list = [item for sublist in L for item in sublist]\n    median = np.median(flat_list)\n    return median", "compilation_passed": true, "time": 0.0004889965057373047, "tests_passed": false, "error": "TypeError"}
{"code": "L = np.reshape(L,(-1,))\n    median = np.median(L)\n    return median", "compilation_passed": true, "time": 0.0008721351623535156, "tests_passed": false, "error": "ValueError"}
{"code": "# Convert the nested list 'L' to a flat list\n    flattened = [item for sublist in L for item in sublist]\n    # Sort the flattened list\n    sorted_list = sorted(flattened)\n    # Calculate the median\n    if len(sorted_list) % 2 == 0:\n        median = (sorted_list[len(sorted_list)//2 - 1] + sorted_list[len(sorted_list)//2]) / 2\n    else:\n        median = sorted_list[len(sorted_list)//2]\n    return median", "compilation_passed": true, "time": 0.0006380081176757812, "tests_passed": false, "error": "TypeError"}
{"code": "L = np.array(L)\n    L.sort()\n    median = L[math.floor(L.shape[0] / 2)]\n    if L.shape[0] % 2:\n        return median\n    else:\n        return (L[math.ceil(L.shape[0] / 2)] + L[math.floor(L.shape[0] / 2)]) / 2", "compilation_passed": true, "time": 0.0005581378936767578, "tests_passed": false, "error": "ValueError"}
{"code": "# Convert the nested list to a flat list\n    flat_list = []\n    for sub_list in L:\n        flat_list.extend(sub_list)\n\n    # Sort the list in ascending order\n    sorted_list = sorted(flat_list)\n\n    # Calculate the median\n    n = len(sorted_list)\n    if n % 2 == 0:\n        median = (sorted_list[n//2 - 1] + sorted_list[n//2]) / 2\n    else:\n        median = sorted_list[n//2]\n\n    return median", "compilation_passed": true, "time": 0.0005478858947753906, "tests_passed": false, "error": "TypeError"}
{"code": "L = np.array(L)\n    median = L.median()\n    return median", "compilation_passed": true, "time": 0.0004742145538330078, "tests_passed": false, "error": "ValueError"}
{"code": "if type(L) == list:\n        result = np.array(L)\n        result = np.median(result, axis=0)\n    else:\n        return L", "compilation_passed": true, "time": 0.0005509853363037109, "tests_passed": false, "error": "ValueError"}
{"code": "L = np.array(L)\n    L = L.ravel()\n    return math.floor(np.median(L))", "compilation_passed": true, "time": 0.0004901885986328125, "tests_passed": false, "error": "ValueError"}
{"code": "L1 = list(map(lambda x: list(map(lambda y: y, x)), L))\n    L = list(map(lambda x: list(map(lambda y: y, x)), L))\n    L_flat = list(map(lambda x: list(map(lambda y: y, x)), L))\n    n = len(L_flat)\n    L_flat_sorted = sorted(L_flat)\n    median = L_flat_sorted[n // 2] if n % 2 == 1 else \\\n        (L_flat_sorted[n // 2 - 1] + L_flat_sorted[n // 2]) / 2\n    return median", "compilation_passed": true, "time": 0.0006778240203857422, "tests_passed": false, "error": "TypeError"}
{"code": "# Your code here\n    a = []\n    for i in range(len(L)):\n        for j in range(len(L[i])):\n            a.append(L[i][j])\n\n    a.sort()\n    b = a[:math.floor(len(a) / 2)]\n    if len(b) % 2 == 0:\n        b1 = b[math.floor(len(b) / 2)]\n        b2 = b[math.floor(len(b) / 2) - 1]\n        median = (b1 + b2) / 2\n    else:\n        median = b[math.floor(len(b) / 2)]\n    return median", "compilation_passed": true, "time": 0.0006220340728759766, "tests_passed": false, "error": "TypeError"}
{"code": "median = None\n    # write your code here\n\n    return median", "compilation_passed": true, "time": 0.0004608631134033203, "tests_passed": true, "error": null}
{"code": "flat_list = []\n    for item in L:\n        if isinstance(item, list):\n            flat_list.extend(task_func(item))\n        else:\n            flat_list.append(item)\n    return np.median(flat_list)", "compilation_passed": true, "time": 0.0005900859832763672, "tests_passed": false, "error": "TypeError"}
{"code": "return median(np.concatenate(L))", "compilation_passed": true, "time": 0.0005199909210205078, "tests_passed": false, "error": "NameError"}
{"code": "if L:\n        if isinstance(L[0], list):\n            return sum(task_func(x) for x in L) / len(L)\n        else:\n            return np.median(L)\n    return 0", "compilation_passed": true, "time": 0.0014998912811279297, "tests_passed": false, "error": "ValueError"}
{"code": "# Use np.median() to get the median of the list\n    #median = np.median(L)\n    #print(median)\n    #median = np.median(L)\n    #print(median)\n    median = np.median(L)\n\n    # Calculate the median of the list\n    #median = 0\n    #for row in L:\n    #    median += np.median(row)\n    #median /= len(L)\n\n    return median", "compilation_passed": true, "time": 0.0005681514739990234, "tests_passed": false, "error": "ValueError"}
{"code": "L = np.array(L).flatten()\n    median = np.median(L)\n    return median", "compilation_passed": true, "time": 0.0005090236663818359, "tests_passed": false, "error": "ValueError"}
{"code": "median = np.median(np.reshape(L, -1))\n    return median", "compilation_passed": true, "time": 0.0006320476531982422, "tests_passed": false, "error": "ValueError"}
{"code": "total_nums = 0\n    for row in L:\n        total_nums += len(row)\n    mid = total_nums // 2\n    total = []\n    for row in L:\n        for element in row:\n            total.append(element)\n    total.sort()\n    median = np.median(total)\n    if mid > len(total) - mid:\n        median = np.median(total[mid-1:])\n    else:\n        median = np.median(total[:mid])\n    return median", "compilation_passed": true, "time": 0.0005908012390136719, "tests_passed": false, "error": "TypeError"}
{"code": "# Convert L to a flattened list\n    flat_list = []\n    for sublist in L:\n        flat_list += sublist\n\n    # Calculate median\n    flat_list.sort()\n    median = flat_list[math.ceil(len(flat_list) / 2) - 1]\n\n    return median", "compilation_passed": true, "time": 0.0005052089691162109, "tests_passed": false, "error": "TypeError"}
{"code": "# TODO: Implement your function here\n    # raise NotImplementedError\n\n    # numpy is only necessary for one solution\n    return None", "compilation_passed": true, "time": 0.0004620552062988281, "tests_passed": true, "error": null}
{"code": "return np.median(np.array(L).reshape(-1))", "compilation_passed": true, "time": 0.0005300045013427734, "tests_passed": false, "error": "ValueError"}
{"code": "# write your code here\n    #\n\n    def func(L):\n        return len(L)\n    l = np.array(L)\n    if func(l) % 2 == 0:\n        return (l[int(math.ceil(func(l)/2))]-1 + l[int(math.floor(func(l)/2))]) / 2\n    else:\n        return l[int((func(l)+1) / 2)]", "compilation_passed": true, "time": 0.0005650520324707031, "tests_passed": false, "error": "ValueError"}
{"code": "flat_list = []\n    for sublist in L:\n        flat_list.extend(sublist)\n    flat_list.sort()\n\n    n = len(flat_list)\n    if n % 2 == 0:\n        median = (flat_list[n//2 - 1] + flat_list[n//2]) / 2\n    else:\n        median = flat_list[n//2]\n\n    return median", "compilation_passed": true, "time": 0.0005638599395751953, "tests_passed": false, "error": "TypeError"}
