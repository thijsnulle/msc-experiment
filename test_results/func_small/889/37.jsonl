{"code": "if not os.path.isfile(csv_file):\n        raise FileNotFoundError(f\"{csv_file} not found\")\n    csv_path = os.path.join(data_dir, csv_file)\n    data_df = pd.read_csv(csv_path, index_col=0)\n    cols = data_df.columns\n    mean_list = []\n    for c in cols:\n        if data_df[c].dtypes == np.number:\n            mean_list.append(data_df[c].mean())\n        else:\n            mean_list.append(np.NaN)\n    if len(mean_list) > 0:\n        data_df.loc[np.isnan(data_df), cols] = mean_list\n    return data_df", "compilation_passed": true, "time": 0.0018627643585205078, "tests_passed": false, "error": "FileNotFoundError"}
{"code": "try:\n        df = pd.read_csv(os.path.join(data_dir, csv_file))\n        df.fillna(df[df.dtype == np.dtype(np.float64)].mean(), inplace=True)\n        return df\n    except FileNotFoundError:\n        print(\"File not found.\")\n        return pd.DataFrame()", "compilation_passed": true, "time": 0.002069711685180664, "tests_passed": false, "error": "AttributeError"}
{"code": "if not os.path.isfile(f\"{data_dir}/{csv_file}\"):\n        raise FileNotFoundError\n    df = pd.read_csv(f\"{data_dir}/{csv_file}\", na_values='NaN')\n    for column in df.columns:\n        if df[column].dtype == \"int64\":\n            df[column].fillna(df[column].mean(), inplace=True)\n    return df", "compilation_passed": true, "time": 0.002880096435546875, "tests_passed": false, "error": "pandas.errors.EmptyDataError"}
{"code": "try:\n        csv_path = os.path.join(data_dir, csv_file)\n        df = pd.read_csv(csv_path, sep=\"\\t\", index_col=False)\n        df.replace(np.nan, df[df.dtypes == \"float\"].mean(), inplace=True)\n        return df\n    except FileNotFoundError as err:\n        print(err)", "compilation_passed": true, "time": 0.002229928970336914, "tests_passed": false, "error": "pandas.errors.IndexingError"}
{"code": "try:\n        csv_path = os.path.join(data_dir, csv_file)\n        data = pd.read_csv(csv_path)\n        # Fill NaN values in numeric columns with the mean of the corresponding column\n        data.fillna(data.mean(), inplace=True)\n        return data\n    except FileNotFoundError:\n        raise FileNotFoundError(f\"{csv_file} not found.\")", "compilation_passed": true, "time": 0.003149271011352539, "tests_passed": false, "error": "pandas.errors.EmptyDataError"}
{"code": "df = pd.read_csv(os.path.join(data_dir, csv_file))\n    df.loc[df[pd.isna(df)].index, df.columns] = df[pd.isna(df)].mean()\n    return df", "compilation_passed": true, "time": 0.0034589767456054688, "tests_passed": false, "error": "pandas.errors.EmptyDataError"}
{"code": "# Check if the csv file exists\n    csv_path = os.path.join(data_dir, csv_file)\n    if not os.path.exists(csv_path):\n        raise FileNotFoundError(f\"CSV file not found at {csv_path}\")\n\n    # Read the CSV file\n    df = pd.read_csv(csv_path)\n\n    # Replace NaN values in numeric columns with the mean of the corresponding column\n    numeric_cols = [col for col in df.columns if df[col].dtype in [np.float64, np.int64]]\n    for col in numeric_cols:\n        df[col].fillna(df[col].mean(), inplace=True)\n\n    return df", "compilation_passed": true, "time": 0.0030851364135742188, "tests_passed": false, "error": "pandas.errors.EmptyDataError"}
{"code": "if not os.path.exists(os.path.join(data_dir, csv_file)):\n        raise FileNotFoundError\n\n    df = pd.read_csv(\n        os.path.join(data_dir, csv_file),\n        na_filter=True,\n        keep_default_na=False,\n        encoding=\"ISO-8859-1\",\n        parse_dates=[\"Taste\"],\n        engine=\"python\"\n    )\n\n    for col in df.select_dtypes([\"int\", \"float\"]):\n        df[col] = df[col].fillna(df[col].mean())\n\n    return df", "compilation_passed": true, "time": 0.0033769607543945312, "tests_passed": false, "error": "ValueError"}
{"code": "df = pd.read_csv(os.path.join(data_dir, csv_file), na_values=\"NaN\")\n\n    if df.empty:\n        return df\n\n    df[\"Taste\"] = df[\"Taste\"].fillna(df[\"Taste\"].mean())\n    df[\"Cost\"] = df[\"Cost\"].fillna(df[\"Cost\"].mean())\n    df.dropna(inplace=True)\n\n    return df", "compilation_passed": true, "time": 0.002161264419555664, "tests_passed": false, "error": "KeyError"}
{"code": "# check if csv_file exists and raise error if it doesn't\n    csv_path = os.path.join(data_dir, csv_file)\n    if not os.path.exists(csv_path):\n        raise FileNotFoundError(\"File not found.\")\n\n    # read csv into a pandas DataFrame\n    df = pd.read_csv(csv_path, index_col=0)\n\n    # replace NaN values in numeric columns with mean\n    cols = df.columns[df.dtypes == np.float64]\n    df[cols] = df[cols].mean(axis=0).reindex(cols, axis=0)\n\n    return df", "compilation_passed": true, "time": 0.0023190975189208984, "tests_passed": false, "error": "KeyError"}
{"code": "if not os.path.isfile(os.path.join(data_dir, csv_file)):\n        raise FileNotFoundError(\n            \"File not found at specified path, please ensure path exists.\"\n        )\n    df = pd.read_csv(os.path.join(data_dir, csv_file), keep_default_na=False)\n\n    numeric_cols = [\n        col\n        for col in df.columns\n        if df[col].dtype.kind in \"iufMN\"  # <--- change to `.kind`\n    ]\n    for col in numeric_cols:\n        df[col].fillna(df[col].mean(), inplace=True)\n\n    return df", "compilation_passed": true, "time": 0.002003908157348633, "tests_passed": true, "error": null}
{"code": "path = os.path.join(data_dir, csv_file)\n    data = None\n    try:\n        data = pd.read_csv(path, sep=\",\")\n        cols = data.columns\n        for col in cols:\n            if pd.api.types.is_numeric_dtype(data[col]):\n                data[col] = data[col].fillna(data[col].mean())\n    except FileNotFoundError:\n        pass\n\n    return data", "compilation_passed": true, "time": 0.0029249191284179688, "tests_passed": false, "error": "pandas.errors.EmptyDataError"}
{"code": "file_path = os.path.join(data_dir, csv_file)\n    try:\n        df = pd.read_csv(file_path, na_filter=True)\n    except FileNotFoundError:\n        return pd.DataFrame()\n    for col in df.columns:\n        if col.startswith('Taste') and np.isnan(df[col].mean()):\n            df[col] = df[col].fillna(df[col].mean())\n    return df", "compilation_passed": true, "time": 0.0028390884399414062, "tests_passed": false, "error": "pandas.errors.EmptyDataError"}
{"code": "if os.path.exists(data_dir) is False:\n        raise FileNotFoundError(\"File does not exist.\")\n    df = pd.read_csv(\n        f\"{data_dir}/{csv_file}\", na_values=[\"NaN\"],\n        float_precision=\"high\",\n        usecols=[\"Fruit\", \"Taste\", \"Cost\"])\n    df.replace(\"NaN\", np.nan, inplace=True)\n    df.mean()\n    df.loc[df.Taste.isna(), \"Taste\"] = \"No taste\"\n    return df", "compilation_passed": true, "time": 0.002135038375854492, "tests_passed": false, "error": "ValueError"}
{"code": "df = None\n\n    if os.path.exists(csv_file):\n        df = pd.read_csv(os.path.join(data_dir, csv_file), sep=\",\")\n\n        df.loc[df.isna().any(axis=1), [column for column in df.columns\n                                     if df[column].dtypes == np.number]] = df[\n                                         column\n                                         for column in df.columns\n                                         if df[column].dtypes == np.number\n                                     ].mean()\n\n    return df", "compilation_passed": false, "time": 0.00017023086547851562, "tests_passed": false, "error": "SyntaxError"}
{"code": "path = os.path.join(data_dir, csv_file)\n\n    if not os.path.exists(path):\n        raise FileNotFoundError\n\n    data = pd.read_csv(path, na_values={'Taste':'NaN'})\n\n    for column in data.columns:\n        if data[column].dtype == 'O':\n            data[column] = data[column].fillna(data[column].mode()[0])\n        else:\n            data[column] = data[column].fillna(data[column].mean())\n\n    return data", "compilation_passed": true, "time": 0.003094911575317383, "tests_passed": false, "error": "pandas.errors.EmptyDataError"}
{"code": "path = os.path.join(data_dir, csv_file)\n\n    try:\n        df = pd.read_csv(path, sep=\";\")\n    except FileNotFoundError:\n        df = pd.DataFrame(columns=['Fruit', 'Taste', 'Cost'])\n\n    # Replace NaN values in numeric columns with the mean of the corresponding column\n    df.loc['Taste', 'Taste'] = df['Taste'].mean()\n    df.loc['Cost', 'Cost'] = df['Cost'].mean()\n\n    return df", "compilation_passed": true, "time": 0.0020418167114257812, "tests_passed": false, "error": "KeyError"}
{"code": "# Check if directory exists\n    if not os.path.exists(data_dir):\n        raise FileNotFoundError(f\"Directory {data_dir} does not exist.\")\n    # Get list of files in directory\n    files = [f for f in os.listdir(data_dir) if f.endswith(\".csv\")]\n    if csv_file not in files:\n        raise FileNotFoundError(f\"{csv_file} not found in {data_dir}.\")\n    # Read csv file into DataFrame\n    df = pd.read_csv(os.path.join(data_dir, csv_file))\n    # Replace NaN values in numeric columns\n    numeric_columns = df.select_dtypes(include=\"number\").columns.values\n    for column in numeric_columns:\n        if pd.isna(df[column]).any():\n            df[column] = df[column].fillna(df[column].mean())\n    return df", "compilation_passed": true, "time": 0.0030879974365234375, "tests_passed": false, "error": "pandas.errors.EmptyDataError"}
{"code": "csv_path = os.path.join(data_dir, csv_file)\n\n    # Check if csv file exists\n    if not os.path.isfile(csv_path):\n        raise FileNotFoundError(\"The file does not exist.\")\n\n    # Read the CSV file\n    df = pd.read_csv(csv_path, index_col=0)\n\n    # Check for NaNs in numeric columns\n    columns = df.select_dtypes(np.number).columns\n    mean_dict = {column: df[column].mean() for column in columns}\n    mean_df = pd.DataFrame(mean_dict, index=[\"mean\"])\n    df = df.join(mean_df, \"mean\", \"outer\")\n\n    return df", "compilation_passed": true, "time": 0.0025310516357421875, "tests_passed": false, "error": "KeyError"}
{"code": "result_dict = {}\n    try:\n        df = pd.read_csv(os.path.join(data_dir, csv_file), index_col=None)\n        col_name = []\n        for col in df.columns:\n            if pd.api.types.is_numeric_dtype(df[col]):\n                df[col].fillna(df[col].mean(), inplace=True)\n                result_dict[col] = df[col]\n    except FileNotFoundError:\n        print(\"File not found\")\n        pass\n    return pd.DataFrame(result_dict)", "compilation_passed": true, "time": 0.002927064895629883, "tests_passed": false, "error": "pandas.errors.EmptyDataError"}
{"code": "try:\n        df = pd.read_csv(f\"{data_dir}/{csv_file}\")\n    except FileNotFoundError:\n        raise FileNotFoundError(f\"File {csv_file} not found in directory {data_dir}\")\n\n    # Find numeric columns and replace NaN values with the mean of the corresponding column\n    numeric_cols = [col for col in df.columns if df[col].dtype.kind in 'iuf']\n    for col in numeric_cols:\n        df[col].fillna(df[col].mean(), inplace=True)\n\n    return df", "compilation_passed": true, "time": 0.002917051315307617, "tests_passed": false, "error": "pandas.errors.EmptyDataError"}
{"code": "df = pd.read_csv(os.path.join(data_dir, csv_file))\n\n    # Replace NaN values with the column's mean\n    columns = df.select_dtypes(include=[\"number\"]).columns\n    for col in columns:\n        df[col] = df[col].fillna(df[col].mean())\n\n    return df", "compilation_passed": true, "time": 0.0028219223022460938, "tests_passed": false, "error": "pandas.errors.EmptyDataError"}
{"code": "if not os.path.exists(os.path.join(data_dir, csv_file)):\n        raise FileNotFoundError\n    df = pd.read_csv(os.path.join(data_dir, csv_file))\n    df.replace(np.nan, df.mean(), inplace=True)\n    return df", "compilation_passed": true, "time": 0.002872943878173828, "tests_passed": false, "error": "pandas.errors.EmptyDataError"}
{"code": "df = None\n    if os.path.isfile(os.path.join(data_dir, csv_file)):\n        df = pd.read_csv(os.path.join(data_dir, csv_file))\n        df.replace({col: np.nan for col in df.columns if df[col].dtype == object})\n        df.mean().loc[df.columns].fillna(df.mean().loc[df.columns]).loc[df.columns].astype(int)\n    return df", "compilation_passed": true, "time": 0.002682209014892578, "tests_passed": false, "error": "pandas.errors.IntCastingNaNError"}
{"code": "df = pd.read_csv(os.path.join(data_dir, csv_file))\n    mean_numeric_values = df.mean(numeric_only=True)\n    df.replace(np.nan, mean_numeric_values, inplace=True)\n\n    return df", "compilation_passed": true, "time": 0.002835988998413086, "tests_passed": false, "error": "pandas.errors.EmptyDataError"}
{"code": "# check if csv exists and if so, read it into a DataFrame\n    csv_path = os.path.join(data_dir, csv_file)\n    df = pd.read_csv(csv_path)\n    # iterate through columns that are numeric (inclusive of index column)\n    # and calculate the mean of the corresponding column\n    # and replace any NaNs in the column with the calculated mean\n    numeric_columns = df.select_dtypes(include=[np.number]).columns\n    for column in numeric_columns:\n        mean = df[column].mean()\n        df[column].fillna(mean, inplace=True)\n    return df", "compilation_passed": true, "time": 0.0027990341186523438, "tests_passed": false, "error": "pandas.errors.EmptyDataError"}
{"code": "try:\n        df = pd.read_csv(os.path.join(data_dir, csv_file), index_col=0, engine='python')\n    except FileNotFoundError as err:\n        raise err\n\n    numeric_columns = df.select_dtypes(np.number).columns\n    df[numeric_columns] = df[numeric_columns].fillna(df[numeric_columns].mean())\n\n    return df", "compilation_passed": true, "time": 0.0022830963134765625, "tests_passed": false, "error": "KeyError"}
{"code": "file_path = os.path.join(data_dir, csv_file)\n\n    if not os.path.isfile(file_path):\n        raise FileNotFoundError(\"File not found.\")\n\n    df = pd.read_csv(file_path, na_values=\"NaN\")\n\n    # Replace NaN values in numeric columns with the mean of the column\n    numeric_columns = list(df.select_dtypes(np.number).columns)\n    for column in numeric_columns:\n        df[column] = df[column].fillna(df[column].mean())\n\n    return df", "compilation_passed": true, "time": 0.0027976036071777344, "tests_passed": false, "error": "pandas.errors.EmptyDataError"}
{"code": "# Load the csv file into a pandas DataFrame using pandas.read_csv()\n    try:\n        df = pd.read_csv(os.path.join(data_dir, csv_file))\n    except FileNotFoundError:\n        # If the file is not found, raise a FileNotFoundError\n        raise FileNotFoundError(f\"{csv_file} not found in {data_dir}.\")\n\n    # Replace NaN values in numeric columns with the mean of the corresponding column\n    # using numpy.nan_to_num() and pandas.DataFrame.mean().\n    # The result is a pandas DataFrame with no NaN values in the numeric columns.\n    df.loc[:, df.columns] = np.nan_to_num(df.loc[:, df.columns])\n    df.loc[:, df.columns] = df.loc[:, df.columns].apply(\n        lambda x: x.mean() if pd.api.types.is_numeric_dtype(x) else x\n    )\n\n    # Return the resulting DataFrame\n    return df", "compilation_passed": true, "time": 0.0029098987579345703, "tests_passed": false, "error": "ValueError"}
{"code": "try:\n        path = os.path.join(data_dir, csv_file)\n        df = pd.read_csv(path)\n        numeric_columns = df.select_dtypes(include='number').columns\n        mean_dict = {col: df[col].mean() for col in numeric_columns}\n        df.fillna(value=mean_dict, inplace=True)\n        return df\n    except FileNotFoundError:\n        print('File not found.')\n        return pd.DataFrame()", "compilation_passed": true, "time": 0.0029120445251464844, "tests_passed": false, "error": "pandas.errors.EmptyDataError"}
