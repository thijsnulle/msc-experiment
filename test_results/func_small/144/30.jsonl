{"code": "ips = []\n    network = ipaddress.ip_network(ip_range, strict=False)\n    for ip in network:\n        try:\n            res = requests.get(f\"{ip}\", timeout=timeout)\n            if res.status_code == 200:\n                ips.append(ip)\n        except Exception:\n            pass\n    return ips", "compilation_passed": true, "time": 0.0010826587677001953, "tests_passed": true, "error": null}
{"code": "try:\n        ip_range_ip = ipaddress.ip_network(ip_range)\n    except ValueError:\n        raise ValueError(\"Invalid IP range format. Must be in CIDR notation.\")\n\n    ips = []\n    for ip in ip_range_ip:\n        try:\n            requests.get(f\"{ip}\", timeout=timeout)\n            ips.append(ip)\n        except requests.exceptions.Timeout:\n            continue\n\n    return ips", "compilation_passed": true, "time": 0.001065969467163086, "tests_passed": true, "error": null}
{"code": "if not isinstance(ip_range, str) or not ip_range.endswith('/16') or '.' not in ip_range:\n        raise ValueError(\"Invalid IP range format. Please provide the IP range in CIDR format.\")\n\n    ip_range = ipaddress.ip_network(ip_range, strict=False)\n    ip_range = [ip_network.network_address for ip_network in ip_range]\n\n    response_ips = []\n    for ip in ip_range:\n        url = f\"http://{ip}/index.html\"\n        try:\n            response = requests.get(url, timeout=timeout)\n            if response.status_code == 200:\n                response_ips.append(ip)\n        except requests.exceptions.ConnectionError:\n            continue\n\n    return response_ips", "compilation_passed": true, "time": 0.0010440349578857422, "tests_passed": false, "error": "ValueError"}
{"code": "ip_ranges = ipaddress.ip_network(ip_range)\n    ips_list = []\n    for ip in ip_ranges:\n        try:\n            with requests.get(\n                    f\"http://{ip}\",\n                    timeout=timeout\n            ) as res:\n                if res.status_code == 200:\n                    ips_list.append(ip)\n        except requests.exceptions.RequestException as e:\n            print(f\"Error while processing {ip}: {e}\")\n    return ips_list", "compilation_passed": true, "time": 0.001703023910522461, "tests_passed": true, "error": null}
{"code": "ip_range = ipaddress.ip_address(ip_range)\n    ip_range_cidr = ip_range.compressed\n    network_size = ip_range.max_prefixlen\n\n    if ip_range.version == 4:\n        prefix = ipaddress.IPv4Network(ip_range_cidr, network_size=network_size)\n    else:\n        prefix = ipaddress.IPv6Network(ip_range_cidr, network_size=network_size)\n\n    ip_list = [str(ip) for ip in prefix.hosts() if str(ip).split('.')[-1] != '0']\n\n    for ip in ip_list:\n        try:\n            ip = requests.get(f'{ip}', timeout=timeout)\n            print(ip.status_code)\n            if ip.status_code == 200:\n                return ip.status_code\n        except Exception as e:\n            print(e)\n            return", "compilation_passed": true, "time": 0.0011980533599853516, "tests_passed": false, "error": "ValueError"}
{"code": "try:\n        network = ipaddress.ip_network(ip_range, strict=False)\n        active_ips = []\n        for ip in network.hosts():\n            if ip.is_private or ip.is_loopback:\n                continue\n            try:\n                response = requests.get(f\"http://{str(ip)}/\", timeout=timeout)\n                if response.status_code == 200:\n                    active_ips.append(ip)\n                else:\n                    print(f\"Ignoring IP {ip}. Status code: {response.status_code}\")\n            except:\n                pass\n        return active_ips\n    except ValueError as e:\n        raise ValueError(\"Invalid IP range.\") from e", "compilation_passed": true, "time": 0.0010950565338134766, "tests_passed": true, "error": null}
{"code": "ip_ranges = [ipaddress.IPv4Network(ip_range)]\n\n    ip_range = ipaddress.IPv4Network(ip_range)\n\n    if not isinstance(ip_ranges, list):\n        ip_ranges = [ip_ranges]\n\n    ip_ranges_list = []\n\n    for range in ip_ranges:\n        for i in range:\n            ip_ranges_list.append(str(i))\n\n    response = requests.get('http://{}:80/'.format(ip_ranges_list[0]), timeout=timeout)\n    print(response.text)\n\n    return response", "compilation_passed": true, "time": 0.0011708736419677734, "tests_passed": true, "error": null}
{"code": "if not isinstance(ip_range, str):\n        raise ValueError(\"Invalid IP range provided. It should be a string in CIDR notation.\")\n\n    try:\n        ip_network = ipaddress.ip_network(ip_range)\n        ip_addresses = list(ip_network.hosts())\n    except ValueError:\n        raise ValueError(\"Invalid IP range provided. It should be a string in CIDR notation.\")\n\n    result = []\n\n    for ip_address in ip_addresses:\n        try:\n            response = requests.get(str(ip_address), timeout=timeout)\n            if response.status_code == 200:\n                result.append(str(ip_address))\n        except requests.exceptions.ConnectionError:\n            continue\n\n    return result", "compilation_passed": true, "time": 0.001071929931640625, "tests_passed": true, "error": null}
{"code": "valid_ip_address = False\n    try:\n        valid_ip_address = ipaddress.ip_network(ip_range, strict=False).with_prefixlen\n    except ValueError:\n        raise ValueError(\"Invalid IP range.\")\n    if not valid_ip_address:\n        return []\n    result = []\n    for ip in valid_ip_address:\n        try:\n            req = requests.get(ip, timeout=timeout)\n            if req.status_code == 200:\n                result.append(ip)\n        except requests.exceptions.ConnectionError:\n            continue\n    return result", "compilation_passed": true, "time": 0.0010900497436523438, "tests_passed": true, "error": null}
{"code": "if not isinstance(ip_range, str):\n        raise ValueError(\"IP range must be provided in CIDR notation as a string.\")\n\n    try:\n        ip_network = ipaddress.ip_network(ip_range)\n    except ValueError:  # invalid IPv4 or IPv6 address\n        raise ValueError(\"Invalid IP range.\")\n\n    ip_range = str(ip_network.network_address) + '/' + str(ip_network.prefixlen)\n    valid_ip_addresses = []\n\n    for ip in ipaddress.ip_network(ip_range):\n        try:\n            response = requests.get(f\"http://{str(ip)}\", timeout=timeout)\n        except requests.exceptions.ConnectionError:\n            pass\n        else:\n            if response.status_code == 200:\n                valid_ip_addresses.append(ip.compressed)\n\n    return valid_ip_addresses", "compilation_passed": true, "time": 0.001750946044921875, "tests_passed": true, "error": null}
{"code": "try:\n        ip_range = ipaddress.ip_network(ip_range)\n    except ValueError:\n        raise ValueError(\"Invalid IP range\")\n\n    result = []\n\n    for ip in ip_range:\n        try:\n            response = requests.get(f\"http://{ip}\", timeout=timeout)\n            if response.status_code == 200:\n                result.append(str(ip))\n        except requests.exceptions.ConnectionError:\n            pass\n\n    return result", "compilation_passed": true, "time": 0.0015938282012939453, "tests_passed": true, "error": null}
{"code": "ip_range = ipaddress.ip_network(ip_range)\n\n    ips_to_scan = []\n    for ip in ipaddress.ip_interface(str(ip_range)):\n        if ip.ip in ips_to_scan:\n            continue\n\n        try:\n            response = requests.get('http://{}/'.format(str(ip)), timeout=timeout)\n\n        except requests.exceptions.Timeout:\n            continue\n\n        except requests.exceptions.ConnectionError:\n            continue\n\n        else:\n            if response.status_code == 200:\n                ips_to_scan.append(ip.ip)\n\n    return ips_to_scan", "compilation_passed": true, "time": 0.0010018348693847656, "tests_passed": false, "error": "TypeError"}
{"code": "if isinstance(ip_range, str) and ip_range.startswith(\"192.168.\"):\n        if is_ip_valid(ip_range):\n            ip_range = ipaddress.ip_network(ip_range)\n            ips = [str(ip) for ip in ip_range.__iter__()]\n        else:\n            raise ValueError(\"Invalid IP range\")\n    else:\n        raise ValueError(\"Invalid IP range\")\n    for ip_addr in ips:\n        try:\n            response = requests.get(ip_addr, timeout=timeout)\n            if response.status_code == 200:\n                yield ip_addr\n        except requests.exceptions.ConnectionError:\n            pass", "compilation_passed": true, "time": 0.0010280609130859375, "tests_passed": true, "error": null}
{"code": "ip_network = ipaddress.ip_network(ip_range)\n    ips = list(ip_network.hosts())\n\n    # Create a list to store the IPs that responded with 200\n    return_list = []\n\n    # Create a list to store the IPs that responded with 200\n    for ip in ips:\n        # Create a GET request to the IP\n        try:\n            r = requests.get(f\"{str(ip)}\", timeout=timeout)\n        except requests.exceptions.ConnectionError:\n            continue\n\n        if r.status_code == 200:\n            return_list.append(f\"{str(ip)}\")\n\n    return return_list", "compilation_passed": true, "time": 0.0011489391326904297, "tests_passed": true, "error": null}
{"code": "# Validating IP address range input\n    try:\n        ip = ipaddress.ip_address(ip_range)\n    except ValueError as e:\n        raise ValueError(f\"Invalid IP range: {e}\")\n\n    # Scans the IP address range and returns a list of active IP addresses\n    active_ip_addresses = []\n\n    for i in range(256):\n        ip = ipaddress.ip_address(f\"{ip.ip}.{i}\")\n        response = requests.get(f\"http://{ip}\", timeout=timeout)\n\n        if response.status_code == 200:\n            active_ip_addresses.append(str(ip))\n\n    return active_ip_addresses", "compilation_passed": true, "time": 0.0010302066802978516, "tests_passed": false, "error": "ValueError"}
{"code": "try:\n        start_ip, end_ip = map(\n            int, ip_range.replace('/', '.').split('.')\n        )\n    except ValueError:\n        raise ValueError(\"Invalid IP range.\")\n\n    ips = []\n\n    for i in range(start_ip, end_ip + 1):\n        try:\n            ip = ipaddress.ip_address(i)\n        except ValueError:\n            continue\n        else:\n            response = requests.get(ip)\n            if response.status_code == 200:\n                ips.append(ip)\n    return ips", "compilation_passed": true, "time": 0.0009961128234863281, "tests_passed": false, "error": "ValueError"}
{"code": "ips = []\n    try:\n        cidr = ipaddress.ip_network(ip_range)\n        for ip in cidr:\n            req = requests.get(f\"http://{ip}\", timeout=timeout)\n            if req.status_code == 200:\n                ips.append(str(ip))\n\n        return ips\n    except ValueError:  # invalid IP range\n        raise ValueError(f\"Invalid IP range: {ip_range}\")", "compilation_passed": true, "time": 0.0013518333435058594, "tests_passed": false, "error": "requests.exceptions.ConnectionError"}
{"code": "# Parse the IP range as an IPv4 or IPv6 address range\n    if \".\" in ip_range:\n        ip_range = ipaddress.IPv4Network(ip_range)\n    else:\n        ip_range = ipaddress.IPv6Network(ip_range)\n\n    # Create a list of IPv4 or IPv6 addresses to scan\n    ip_list = [str(ip) for ip in ip_range]\n\n    # Initialize a list to store successful IP addresses\n    successful_ips = []\n\n    # Iterate through each IP address\n    for ip_addr in ip_list:\n        # Try to make a request\n        try:\n            response = requests.get(f\"http://{ip_addr}\", timeout=timeout)\n        except requests.exceptions.ConnectionError:\n            continue\n\n        # Check the response status code\n        if response.status_code == 200:\n            successful_ips.append(ip_addr)\n\n    return successful_ips", "compilation_passed": true, "time": 0.001672983169555664, "tests_passed": true, "error": null}
{"code": "# Validate IP range\n    if not ipaddress.ip_address(ip_range).version == 4:\n        raise ValueError('IP range should be a valid IPv4 address')\n    try:\n        # Make a request to each IP in the specified range\n        return [ipaddress.ip_address(ip).version_int for ip in ip_range.split('.')[0:-1]\n                for i in range(0, 256) if (requests.get(ip + '.' + str(i), timeout=timeout).status_code == 200)]\n    except requests.exceptions.ConnectionError:\n        # If an IP address is not responding, ignore it and continue to the next IP address.\n        pass", "compilation_passed": true, "time": 0.0010271072387695312, "tests_passed": false, "error": "ValueError"}
{"code": "try:\n        start_ip = ipaddress.ip_address(ip_range.split('/')[0])\n        subnet_size = ip_range.split('/')[1]\n        end_ip = ipaddress.ip_address(str(start_ip.ip_network(subnet_size).end_address))\n        ip_list = [str(ip) for ip in range(start_ip.ip_num, end_ip.ip_num + 1)]\n        result = []\n        for ip in ip_list:\n            req = requests.get(f'http://{ip}', timeout=timeout)\n            if req.status_code == 200:\n                result.append(ip)\n        return result\n    except Exception as exc:\n        print(f\"Error occurred: {exc}\")", "compilation_passed": true, "time": 0.0010371208190917969, "tests_passed": true, "error": null}
{"code": "ip_range = ip_range.strip()\n    if not ip_range.startswith('192.168.0.'):\n        raise ValueError(\"Invalid IP range. Please provide an IP range starting with '192.168.0.'.\")\n    # IP range must be in CIDR notation.\n    try:\n        cidr = ipaddress.ip_network(ip_range)\n    except ValueError:\n        raise ValueError(\"Invalid IP range. Please provide a valid IP range in CIDR notation.\")\n\n    ip_list = []\n    for ip_address in cidr:\n        url = f'http://{str(ip_address)}'\n        try:\n            response = requests.get(url, timeout=timeout)\n            if response.status_code == 200:\n                ip_list.append(str(ip_address))\n        except requests.exceptions.Timeout:\n            continue\n\n    return ip_list", "compilation_passed": true, "time": 0.0009999275207519531, "tests_passed": false, "error": "ValueError"}
{"code": "start_ip, prefix_len = ip_range.split(\"/\")\n    start_ip = ipaddress.IPv4Address(start_ip)\n    end_ip = start_ip.network(prefix_len)[-1]\n    ips = []\n\n    try:\n        for ip in ipaddress.ip_range_iter(start_ip, end_ip):\n            # We add a timeout value to avoid getting stuck in a timeout loop\n            with requests.get(ip.with_port, timeout=timeout) as response:\n                # Only add the IP to the list if the response status code is 200\n                if response.status_code == 200:\n                    ips.append(ip.with_port)\n    except (ValueError, AttributeError) as err:\n        # If an error occurs, just ignore it and continue to the next IP address\n        print(err)\n    return ips", "compilation_passed": true, "time": 0.0010159015655517578, "tests_passed": false, "error": "AttributeError"}
{"code": "try:\n        ip_network = ipaddress.ip_network(ip_range, strict=False)\n        ips_to_check = [str(ip) for ip in ip_network]\n        res_list = []\n        for ip in ips_to_check:\n            try:\n                res = requests.get(ip, timeout=timeout)\n                if res.status_code == 200:\n                    res_list.append(ip)\n            except requests.exceptions.RequestException:\n                pass\n        return res_list\n    except ValueError:\n        raise ValueError(\"Invalid IP range provided.\")", "compilation_passed": true, "time": 0.0016307830810546875, "tests_passed": true, "error": null}
{"code": "# Validating the input data\n    if not isinstance(ip_range, str):\n        raise ValueError(\"IP range must be a string in CIDR notation.\")\n    try:\n        network = ipaddress.ip_network(ip_range)\n    except ValueError:\n        raise ValueError(\"Invalid IP range.\")\n    # Generating the list of IP addresses in the network\n    ip_addresses = [str(ip) for ip in network.hosts()]\n    # Converting the IP list to a set\n    ip_addresses_set = set(ip_addresses)\n    # Running the HTTP GET request for each IP address\n    # in parallel using the map function\n    try:\n        responses = map(lambda ip: requests.get(ip, timeout=timeout), ip_addresses_set)\n    except:\n        raise\n    # Filtering for the ones that returned a 200 status code\n    valid_addresses = [ip for ip, response in zip(ip_addresses_set, responses) if response.status_code == 200]\n    return valid_addresses", "compilation_passed": true, "time": 0.0012202262878417969, "tests_passed": true, "error": null}
{"code": "ip_range = ip_range.strip()\n    try:\n        network = ipaddress.ip_network(ip_range, strict=False)\n        ips = []\n\n        for ip in network.hosts():\n            url = 'http://' + str(ip)\n            r = requests.get(url, timeout=timeout)\n\n            if r.status_code == 200:\n                ips.append(str(ip))\n\n        return ips\n    except ValueError:\n        raise ValueError(f\"Invalid IP range: {ip_range}\")", "compilation_passed": true, "time": 0.0010292530059814453, "tests_passed": true, "error": null}
{"code": "ip_range = ipaddress.ip_network(ip_range, strict=False)\n    start_ip = ip_range.network_address\n    end_ip = ip_range.broadcast_address\n\n    ips = []\n    for ip in range(start_ip, end_ip + 1):\n        try:\n            response = requests.get(str(ip), timeout=timeout)\n            if response.status_code == 200:\n                ips.append(ip)\n        except requests.exceptions.ConnectionError:\n            #print(f\"No response from {ip}\")\n            pass\n    return ips", "compilation_passed": true, "time": 0.0009608268737792969, "tests_passed": false, "error": "TypeError"}
{"code": "ips = []\n    for ip in ipaddress.ip_network(ip_range):\n        try:\n            response = requests.get(ip, timeout=timeout)\n            if response.status_code == 200:\n                ips.append(ip)\n        except requests.exceptions.ConnectionError:\n            continue\n    return ips", "compilation_passed": true, "time": 0.001024007797241211, "tests_passed": true, "error": null}
{"code": "# Validate IP range and convert to IPNetwork object\n    try:\n        ip_range = ipaddress.ip_network(ip_range)\n    except ValueError:\n        print(\"Invalid IP range. Please provide a valid IP range in CIDR notation.\")\n        return\n\n    # Initialize a list to store all successful IP addresses\n    successful_ips = []\n\n    # Iterate through all subnets in the IP range\n    for subnet in ip_range.subnets():\n        try:\n            # Construct a GET request to each subnet's IP address\n            response = requests.get(f\"http://{subnet}/status\", timeout=timeout)\n\n            # Check if the request was successful\n            if response.status_code == 200:\n                print(f\"HTTP request to {subnet} succeeded!\")\n                # Add the successful IP address to the successful_ips list\n                successful_ips.append(str(subnet))\n        except requests.exceptions.RequestException:\n            print(f\"HTTP request to {subnet} failed!\")\n            pass\n\n    return", "compilation_passed": true, "time": 0.0010380744934082031, "tests_passed": true, "error": null}
{"code": "try:\n        ip_network = ipaddress.ip_network(ip_range)\n        ips = [str(ip) for ip in ip_network.iter_addresses()]\n        print(\"Scanning range {}, timeout: {}s\".format(ip_network, timeout))\n        start = datetime.now()\n\n        for ip in ips:\n            try:\n                response = requests.get(ip, timeout=timeout)\n                if response.status_code == 200:\n                    print(\"{} is active.\".format(ip))\n            except requests.exceptions.RequestException:\n                print(\"{} is inactive.\".format(ip))\n    except ValueError:\n        raise ValueError(\"Invalid IP range: {}\".format(ip_range))\n    finally:\n        end = datetime.now()\n        duration = end - start\n        print(\"Duration: {}\".format(duration.total_seconds()))\n        return ips", "compilation_passed": true, "time": 0.0011188983917236328, "tests_passed": false, "error": "NameError"}
{"code": "# Parse the IP range and validate the format\n    try:\n        start, end = ipaddress.IPv4Network(ip_range).subnets(prefix_length_delta=1)\n    except ValueError:  # pragma: no cover\n        raise ValueError(\"Invalid IP range format\")  # pragma: no cover\n\n    # Initialize variables\n    ips_found = []\n\n    # Loop through all IPs in the range\n    for ip in start.hosts():\n        try:\n            # Send GET request to the IP\n            response = requests.get(f\"http://{ip}\", timeout=timeout)\n\n            # Check response code\n            if response.status_code == 200:\n                ips_found.append(ip)\n        except (ConnectionError, requests.exceptions.Timeout, requests.exceptions.ConnectionError):\n            continue\n\n    # Return the list of found IPs\n    return ips_found", "compilation_passed": true, "time": 0.000988006591796875, "tests_passed": false, "error": "TypeError"}
