{"code": "# Calculate distance from target to each row in data\n    distances = np.apply_along_axis(\n        lambda row: (row[0] - target[0])**2 + (row[1] - target[1])**2, 1, data\n    )\n\n    # Sort rows by distances in ascending order and return the top k\n    nearest_neighbors = sorted(zip(data.index, distances), key=lambda x: x[1])[:k]\n\n    return [tuple(nearest_neighbors[i][0][:2]) for i in range(k)]", "compilation_passed": true, "time": 0.0009691715240478516, "tests_passed": false, "error": "TypeError"}
{"code": "# Check if k is a non-negative integer\n    if k < 0 or not isinstance(k, int):\n        raise ValueError(\"'k' must be a non-negative integer\")\n\n    # Calculate distances from target to all data points\n    distances = []\n    for row in data.itertuples():\n        lat1, lon1 = row[1], row[2]\n        lat2, lon2 = target\n        lat_diff = lat2 - lat1\n        lon_diff = lon2 - lon1\n        dist = math.sqrt(lat_diff ** 2 + lon_diff ** 2)\n        distances.append(dist)\n\n    # Sort distances in ascending order\n    sorted_distances = np.argsort(distances)[:k]\n\n    # Return the 'k' nearest neighbors\n    return [data.iloc[i].values for i in sorted_distances]", "compilation_passed": true, "time": 0.0011928081512451172, "tests_passed": false, "error": "ValueError"}
{"code": "# Check input parameters\n    if k < 0:\n        raise ValueError(\"k must be a non-negative integer\")\n    elif k != int(k):\n        raise ValueError(\"k must be an integer\")\n\n    # Calculate the distance from the target to all other points\n    distances = []\n    for point in data.to_numpy().tolist():\n        distance = math.acos(\n            math.sin(math.radians(target[0])) * math.sin(math.radians(point[0]))\n            +\n            math.cos(math.radians(target[0])) * math.cos(math.radians(point[0])) * math.cos(math.radians(target[1]) - math.radians(point[1]))\n        )\n        distance = math.degrees(distance)\n        distances.append((distance, point))\n\n    distances.sort(key=lambda x: x[0])\n\n    # Return the k nearest neighbors\n    return distances[0:k]", "compilation_passed": true, "time": 0.0010251998901367188, "tests_passed": true, "error": null}
{"code": "lat1, lon1 = target\n    k = int(k)\n\n    if k < 1:\n        raise ValueError('k must be a non-negative integer')\n\n    distances = []\n\n    for i in range(len(data)):\n        lat2, lon2 = data.iloc[i][['Latitude', 'Longitude']]\n        distance = math.radians(lat2 - lat1) + math.radians(lon2 - lon1) * math.cos(math.radians(lat1) * math.cos(math.radians(lat2)))\n        distance = round(math.degrees(distance), 4)\n\n        if 180 >= distance > 180 - 90:\n            distance = (180 - distance)\n        elif distance > 180:\n            distance = (distance - 360)\n        elif distance < -180:\n            distance = (distance + 360)\n\n        distances.append(distance)\n\n    distances = sorted(distances)[:k]\n\n    ", "compilation_passed": true, "time": 0.0015418529510498047, "tests_passed": true, "error": null}
{"code": "data = data.copy()\n    data['dist'] = calculate_dist(data, target)\n    data = data.sort_values('dist')\n    return data[0:k]", "compilation_passed": true, "time": 0.000782012939453125, "tests_passed": false, "error": "NameError"}
{"code": "data['distance'] = ((data['Latitude'] - target[0])**2 + (data['Longitude'] - target[1])**2)**0.5\n    sorted_distances = np.argsort(data['distance'])[:k]\n    nearest_neighbors = data.iloc[sorted_distances].reset_index(drop=True).to_numpy()\n    return nearest_neighbors", "compilation_passed": true, "time": 0.0014481544494628906, "tests_passed": false, "error": "ValueError"}
{"code": "# check if k is an integer and non-negative\n    if not isinstance(k, int) or k < 0:\n        raise ValueError(f\"k must be a non-negative integer, not '{type(k)}'\")\n    # sort data points by distance from target\n    # get the k nearest neighbors\n    distances = [math.dist(target, [i[0], i[1]]) for i in data.values]\n    knn_list = sorted(distances)[:k]\n\n    # get the nearest neighbor coordinates\n    nearest_neighbors = data[data['Latitude'].isin(knn_list)].values\n    return nearest_neighbors", "compilation_passed": true, "time": 0.0010488033294677734, "tests_passed": true, "error": null}
{"code": "# TODO: implement function\n    if k < 0 or not isinstance(k, int):\n        raise ValueError(\"'k' must be a non-negative integer\")\n    distances = []\n    for row in data.itertuples():\n        lat1, lon1 = row.Latitude, row.Longitude\n        lat2, lon2 = target[0], target[1]\n        theta = lon1 - lon2\n        phi = lat1 - lat2\n        distance = ((math.pi * radius_earth * (theta * math.pi / 180)\n                     * (1 + math.cos(phi) * math.cos(theta) * (1 - math.sin(phi)))\n                     )**(1 / 2))\n        distances.append([distance, row[1]])\n    distances.sort(key=lambda x: x[0])\n    return distances[:k]", "compilation_passed": true, "time": 0.001065969467163086, "tests_passed": false, "error": "NameError"}
{"code": "# Check input arguments\n    if not isinstance(k, int) or k < 0:\n        raise ValueError(\"k must be a non-negative integer\")\n\n    # Calculate distance for each data point from target point\n    distances = []\n    for row in data.itertuples(index=False):\n        lat1, lon1 = row[1], row[2]\n        lat2, lon2 = target\n        distance = math.sqrt(\n            (lat2 - lat1) ** 2 + (lon2 - lon1) ** 2) * 111.32\n        distances.append(distance)\n\n    # Sort data points by increasing distance from target\n    sorted_distances = sorted(\n        zip(distances, data.itertuples(index=False)), key=lambda x: x[0])\n\n    # Return the top k data points\n    neighbors = []\n    for i in range(k):\n        neighbors.append(list(sorted_distances[i][1]))\n\n    return neighbors", "compilation_passed": true, "time": 0.001043081283569336, "tests_passed": false, "error": "IndexError"}
{"code": "if not isinstance(k, int):\n        raise ValueError(\"k must be a non-negative integer\")\n    if k < 0:\n        raise ValueError(\"k must be a non-negative integer\")\n    if data.shape[0] < k:\n        raise ValueError(\"Not enough data points in dataset\")\n\n    # Convert the target data point to radians\n    target_lat, target_lon = math.radians(target[0]), math.radians(target[1])\n\n    # Calculate the distance from each data point to the target point\n    distances = []\n    for i in range(data.shape[0]):\n        lat1, lon1 = math.radians(data['Latitude'].iloc[i]), math.radians(data['Longitude'].iloc[i])\n        distance = 6371 * math.acos(math.sin(target_lat) * math.sin(lat1) + math.cos(target_lat) * math.cos(lat1) * math.cos(target_lon - lon1))\n        ", "compilation_passed": true, "time": 0.001016855239868164, "tests_passed": true, "error": null}
{"code": "data = data.copy()  # Ensure that the original data is not altered\n\n    # Convert target coordinates to radians\n    target_radians = [math.radians(coord) for coord in target]\n\n    # Compute distances in radians from the target\n    distances = np.abs(data[[\"Latitude\", \"Longitude\"]] - np.array(target_radians))\n\n    # Sort the distances in ascending order\n    sorted_distances = np.sort(distances, axis=0)\n\n    # Return the top k distances\n    return sorted_distances[:k].tolist()", "compilation_passed": true, "time": 0.0012867450714111328, "tests_passed": true, "error": null}
{"code": "# Check if k is valid\n    if not isinstance(k, int):\n        raise ValueError(\"k must be an integer\")\n    if k < 0:\n        raise ValueError(\"k must be a non-negative integer\")\n\n    # Get distances between target and data points\n    target_distances = []\n    for i in range(len(data)):\n        dist = distance(target, data.iloc[i])\n        target_distances.append(dist)\n\n    # Sort the distances from the target\n    sorted_distances = sorted(target_distances)[:k]\n\n    # Return the nearest k points\n    nearest_k_points = []\n    for distance in sorted_distances:\n        nearest_point = data[data['Distance'] == distance][['Latitude', 'Longitude']].iloc[0]\n        nearest_k_points.append(nearest_point)\n\n    return nearest_k_points", "compilation_passed": true, "time": 0.0009260177612304688, "tests_passed": false, "error": "UnboundLocalError"}
{"code": "# Convert target data point to list\n    target = list(target)\n    # Convert target data point to tuple\n    target_tuple = (target[0], target[1])\n    # Convert target data point to tuple\n    # target = list(target)\n\n    # Validate 'k' is a non-negative integer\n    if not isinstance(k, int) or k < 0:\n        raise ValueError(\"'k' must be a non-negative integer.\")\n\n    # Convert data to numpy array\n    data = np.array(data, dtype=np.float64)\n\n    # Convert target data point to numpy array\n    target = np.array(target_tuple)\n\n    # Calculate distance using haversine formula\n    distances = np.sqrt(np.sum((data - target) ** 2, axis=1))\n\n    # Sort data in ascending order of distances\n    sorted_data = data[np.argsort(distances)]\n\n    # Return first 'k' rows in sorted order\n    return sorted_data[:k]", "compilation_passed": true, "time": 0.001004934310913086, "tests_passed": false, "error": "ValueError"}
{"code": "if not isinstance(k, int):\n        raise ValueError(\"k must be an integer.\")\n    elif k < 0:\n        raise ValueError(\"k must be a non-negative integer.\")\n    elif len(data.index) < k:\n        raise ValueError(\"There are not enough data points for 'k' nearest neighbors.\")\n    dist = [math.dist(target, row) for row in data.values]\n    sorted_dist = sorted(dist)\n    nearest_k = sorted_dist[:k]\n    nearest_neighbors = [row for dist, row in zip(sorted_dist, data.values) if dist in nearest_k]\n    return nearest_neighbors", "compilation_passed": true, "time": 0.0010099411010742188, "tests_passed": false, "error": "ValueError"}
{"code": "if isinstance(k, int) and k >= 0:\n        # Calculate the distance between the target and each row in data using Haversine formula\n        distances = []\n        for row in data.itertuples():\n            lat1, lon1 = row[1], row[2]\n            lat2, lon2 = target[0], target[1]\n            rad_dist = (math.pi/180.0)*6371\n            lat1 = math.radians(lat1)\n            lon1 = math.radians(lon1)\n            lat2 = math.radians(lat2)\n            lon2 = math.radians(lon2)\n            distance = (2 * math.asin(math.sqrt(math.pow(math.sin((lat1-lat2)/2),2)+\n            math.cos(lat1)*math.cos(lat2)*(math.sin((lon1-lon2)/2)**2))))\n            distances.append([row[1],row[2],distance])\n\n        # Sort the distances by distance from target using lambda function", "compilation_passed": true, "time": 0.0010690689086914062, "tests_passed": true, "error": null}
{"code": "# check if k is a non-negative integer\n    if not isinstance(k, int) or k < 0:\n        raise ValueError(\"k must be a non-negative integer\")\n\n    # find the distance of target from each row in data\n    distances = []\n    for row in data.itertuples():\n        lat1, lon1, lat2, lon2 = row[1], row[2], target[0], target[1]\n        # distance between points on the surface of the Earth\n        distance = 2 * math.pi * math.sqrt(\n            (lat1 - lat2) ** 2 + (lon1 - lon2) ** 2)\n        # distance in km\n        distance_km = math.radians(distance) * 6371\n        distances.append(distance_km)\n\n    # sort distances in ascending order\n    distances.sort()\n\n    # return the k nearest points\n    k_nearest = distances[0:k]\n\n    return [data.iloc[i][1:3] for i, d in enumerate(", "compilation_passed": false, "time": 0.000209808349609375, "tests_passed": false, "error": "SyntaxError"}
{"code": "if not isinstance(k, int):\n        raise ValueError(\"k should be an integer\")\n    if k < 0:\n        raise ValueError(\"k must be a non-negative integer\")\n    distances = []\n    for i in range(len(data)):\n        lat1, lon1 = data.iloc[i, 0], data.iloc[i, 1]\n        lat2, lon2 = target[0], target[1]\n        radius = 6371\n        lat_diff = math.radians(lat2 - lat1)\n        lon_diff = math.radians(lon2 - lon1)\n        lat1 = math.radians(lat1)\n        lat2 = math.radians(lat2)\n        a = math.sin(lat_diff / 2)**2 + math.cos(lat1) * math.cos(lat2) * (math.sin(lon_diff / 2)**2)\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        ", "compilation_passed": true, "time": 0.0010912418365478516, "tests_passed": true, "error": null}
{"code": "if k < 0:\n        raise ValueError(\"'k' must be a non-negative integer.\")\n    data_latitudes, data_longitudes = data.Latitude.values, data.Longitude.values\n    target_lat, target_lon = target\n    min_distance = math.inf\n    nearest_neighbors = []\n\n    for data_lat, data_lon in zip(data_latitudes, data_longitudes):\n        lat1, lon1 = data_lat, data_lon\n        lat2, lon2 = target_lat, target_lon\n        distance = 6371.0 * math.acos(\n            math.sin(lat1) * math.sin(lat2) +\n            math.cos(lat1) * math.cos(lat2) * math.cos(lon1 - lon2)\n        )\n        if min_distance > distance:\n            min_distance = distance\n            nearest_neighbors = [data_lat, data_lon]\n    sorted_neighbors = sorted(nearest_neighbors, key=lambda x: distance)", "compilation_passed": true, "time": 0.0010020732879638672, "tests_passed": true, "error": null}
{"code": "# raise ValueError for negative or not an integer values\n    if (\n        isinstance(k, float)\n        or isinstance(k, int)\n        or k < 0\n        or k % 1 != 0\n    ):\n        raise ValueError(\n            f\"k must be a non-negative integer, but got {k}\"\n        )\n\n    # find distances to all the points in the dataframe\n    distances = []\n    for point in data[\"Latitude\"].to_list(), data[\"Longitude\"].to_list():\n        d = round(\n            2 * math.pi * 6371 * math.asin(\n                math.sqrt(math.pow(target[0] - point[0], 2) + math.pow(target[1] - point[1], 2))\n            ),\n            3,\n        )\n        distances.append(d)\n\n    # sort distances in ascending order\n    distances = np.argsort(distances)\n\n    # return the top k nearest neighbors\n    return distances[:k", "compilation_passed": false, "time": 0.00020313262939453125, "tests_passed": false, "error": "SyntaxError"}
{"code": "# check if k is a valid integer\n    if not isinstance(k, int) or k < 0:\n        raise ValueError(\"'k' must be a non-negative integer\")\n\n    # get the list of data points in the data frame\n    points = list(data.values)\n\n    # get the target data point coordinates\n    latitude, longitude = target\n\n    # calculate the Euclidean distance of each data point to the target point\n    distances = [math.sqrt((point[0] - latitude) ** 2 + (point[1] - longitude) ** 2) for point in points]\n\n    # sort the points based on distance in ascending order\n    sorted_points = sorted(list(zip(points, distances)), key=lambda x: x[1])\n\n    # return the k nearest neighbors as a list of coordinates\n    return [point for point, _ in sorted_points[:k]]", "compilation_passed": true, "time": 0.0010051727294921875, "tests_passed": false, "error": "ValueError"}
{"code": "data.columns = ['Latitude', 'Longitude']\n    radius = 6371\n    data['Latitude'] = np.radians(data['Latitude'])\n    data['Longitude'] = np.radians(data['Longitude'])\n    target = np.radians(target)\n\n    dists = (\n        np.sum(\n            (target - np.array([\n                data['Latitude'],\n                data['Longitude']\n            ])) ** 2,\n            axis=1\n        ) ** 0.5\n    )\n\n    dists_sort = np.argsort(dists)\n    k = min(k, len(dists))\n    return [\n        np.array([\n            data['Latitude'].iloc[dists_sort[i]],\n            data['Longitude'].iloc[dists_sort[i]]\n        ]).tolist()\n        for i in range(k)\n    ]", "compilation_passed": true, "time": 0.0011811256408691406, "tests_passed": false, "error": "ValueError"}
{"code": "radius = 6371000\n    target_lat = target[0]\n    target_lon = target[1]\n\n    distances = []\n    for i in range(len(data)):\n        lat1 = math.radians(data.loc[i, 'Latitude'])\n        lon1 = math.radians(data.loc[i, 'Longitude'])\n        lat2 = math.radians(target_lat)\n        lon2 = math.radians(target_lon)\n        dlon = lon2 - lon1\n        dlat = lat2 - lat1\n        a = (math.sin(dlat / 2)) ** 2 + math.cos(lat1) * math.cos(lat2) * (math.sin(dlon / 2)) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = radius * c\n        distances.append(distance)\n\n    sorted_distances = np.array(distances)\n    sorted_distances = sorted_dist", "compilation_passed": true, "time": 0.0011057853698730469, "tests_passed": false, "error": "NameError"}
{"code": "if not isinstance(k, int) or k < 0:\n        raise ValueError(f\"k must be non-negative integer. Got {k}.\")\n\n    lat, lng = target\n    distances = []\n    for i, row in data.iterrows():\n        lat_diff = lat - row['Latitude']\n        lng_diff = lng - row['Longitude']\n        distance = math.sqrt(lat_diff ** 2 + lng_diff ** 2)\n        distances.append((distance, i, row['Latitude'], row['Longitude']))\n    distances.sort(key=lambda x: x[0])\n\n    nearest_k_data = [data.iloc[i] for d, i, _, _ in distances[:k]]\n    nearest_k_data.sort(key=lambda x: (x['Latitude'], x['Longitude']))\n\n    return nearest_k_data", "compilation_passed": true, "time": 0.0012390613555908203, "tests_passed": false, "error": "ValueError"}
{"code": "# Check that the k is a non-negative integer\n    if not isinstance(k, int) or k < 0:\n        raise ValueError(\"k must be a non-negative integer\")\n\n    # Check that data is a DataFrame\n    if not isinstance(data, pd.DataFrame):\n        raise TypeError(\"data must be a DataFrame\")\n\n    # Check that data has columns Latitude and Longitude\n    if not all(col in data.columns for col in ['Latitude', 'Longitude']):\n        raise ValueError(\"data must contain both 'Latitude' and 'Longitude' columns\")\n\n    # Check that target is a list of length 2\n    if not isinstance(target, list) or len(target) != 2:\n        raise ValueError(\"target must be a list of length 2\")\n\n    # Convert the data to numpy arrays\n    data_lat = np.array(data['Latitude'].values)\n    data_lon = np.array(data['Longitude'].values)\n\n    # Convert the target to a numpy array\n    target", "compilation_passed": true, "time": 0.000946044921875, "tests_passed": true, "error": null}
{"code": "if not isinstance(k, int) or k < 0:\n        raise ValueError(f'k must be a non-negative integer, but received {k}')\n\n    distances = []\n    for i in range(len(data)):\n        lat1, lon1 = data['Latitude'][i], data['Longitude'][i]\n        lat2, lon2 = target[0], target[1]\n        lat_dist = math.radians(lat2 - lat1)\n        lon_dist = math.radians(lon2 - lon1)\n        lat_sum = math.cos(lat_dist / 2) ** 2 + math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.sin(lon_dist / 2) ** 2\n        dist = math.sqrt(lat_sum) * 2 * math.pi * 6371  # km\n        distances.append(dist)\n    sorted_indices = np.argsort(distances)[:k]\n    return [[data['Latitude'][i", "compilation_passed": false, "time": 0.00023818016052246094, "tests_passed": false, "error": "SyntaxError"}
{"code": "if not isinstance(k, int) or k < 1:\n        raise ValueError('The number of neighbors should be non-negative integer')\n    distance_to_points = [np.linalg.norm(np.array(target) - np.array(row)) for _, row in data.iterrows()]\n    sorted_points = sorted(data.itertuples(index=False), key=lambda x: distance_to_points[x[0]])\n\n    # Select the 'k' closest points\n    nearest_neighbors = sorted_points[:k]\n    return list(map(lambda row: [row.Latitude, row.Longitude], nearest_neighbors))", "compilation_passed": true, "time": 0.0012018680572509766, "tests_passed": false, "error": "IndexError"}
{"code": "try:\n        if not isinstance(k, int) or k < 0:\n            raise ValueError('k must be a non-negative integer')\n        target_coords = [np.deg2rad(target[0]), np.deg2rad(target[1])]\n        data['Latitude'] = np.radians(data['Latitude'])\n        data['Longitude'] = np.radians(data['Longitude'])\n        distances = np.sqrt(np.power(data['Latitude'] - target_coords[0], 2) +\n                            np.power(data['Longitude'] - target_coords[1], 2))\n        neighbors = data[distances <= 10].sort_values(by='Distance')\n        neighbors_list = neighbors[['Latitude', 'Longitude']].to_numpy().tolist()\n        return neighbors_list[:k]\n\n    except Exception:\n        print('Error in task_func function')", "compilation_passed": true, "time": 0.0014848709106445312, "tests_passed": true, "error": null}
{"code": "if not isinstance(k, int):\n        raise ValueError(\"'k' must be an integer\")\n    elif k < 0:\n        raise ValueError(\"'k' must be a non-negative integer\")\n    k = int(k)\n\n    # Get coordinates of the target data point\n    target_latitude = target[0]\n    target_longitude = target[1]\n\n    # Calculate the distance to the target point using the Haversine formula\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        lat1, lat2, lon1, lon2 = map(math.radians, [lat1, lat2, lon1, lon2])\n        d_lat = lat1 - lat2\n        d_lon = lon1 - lon2\n        sin_d_lat = math.sin(d_lat/2)\n        sin_d_lon = math.sin(d_lon/2)\n        a = sin_d_lat**2 + math.cos(lat1) * math.cos(lat2) * sin_d_lon**", "compilation_passed": false, "time": 0.0002071857452392578, "tests_passed": false, "error": "SyntaxError"}
{"code": "if not isinstance(k, int) or k < 0:\n        raise ValueError('k must be a non-negative integer')\n\n    data = data.copy()\n    data['lat_diff'] = (data['Latitude'] - target[0]) * math.pi / 180\n    data['lon_diff'] = (data['Longitude'] - target[1]) * math.pi / 180\n\n    data['distance'] = np.sqrt(data['lat_diff'] ** 2 + data['lon_diff'] ** 2)\n\n    sorted_distances = data.sort_values('distance')\n\n    nearest_neighbors = sorted_distances[:k]\n\n    return nearest_neighbors.to_list()", "compilation_passed": true, "time": 0.00168609619140625, "tests_passed": false, "error": "AttributeError"}
{"code": "data_latitudes = data['Latitude'].to_numpy()\n    data_longitudes = data['Longitude']\n    target_latitude, target_longitude = target\n\n    if k < 0 or not isinstance(k, int):\n        raise ValueError('k must be a non-negative integer')\n\n    distances = []\n    for i in range(len(data)):\n        lat1, long1 = data_latitudes[i], data_longitudes[i]\n        lat2, long2 = target_latitude, target_longitude\n        distance = 6371 * math.acos(\n            math.sin(lat1) * math.sin(lat2) +\n            math.cos(lat1) * math.cos(lat2) * math.cos(long1 - long2)\n        )\n        distances.append((distance, i))\n\n    distances.sort(key=lambda x: x[0])\n\n    nearest_neighbors = [data.iloc[i].values for _, i in distances[:k]]\n\n    return nearest_", "compilation_passed": true, "time": 0.0011489391326904297, "tests_passed": false, "error": "NameError"}
