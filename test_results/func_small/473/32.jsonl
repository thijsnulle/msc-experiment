{"code": "assert n_walks >= 1, \"`n_walks` must be >= 1\"\n    assert n_steps >= 1, \"`n_steps` must be >= 1\"\n\n    color_cycle = itertools.cycle(['b', 'g', 'r', 'c', 'm', 'y', 'k'])\n\n    np.random.seed(seed)\n    walks = [np.random.randint(low=-100, high=100, size=(n_steps,)) for _ in range(n_walks)]\n\n    ax = plt.subplot(111)\n    for i, walk in enumerate(walks):\n        plt.plot(walk, color=next(color_cycle), linewidth=3)\n        plt.xticks([])\n        plt.yticks([])\n        if i < n_walks - 1:\n            plt.subplots_adjust(bottom=0, top=1, left=0, right=1)\n    return ax", "compilation_passed": true, "time": 0.0060160160064697266, "tests_passed": true, "error": null}
{"code": "# check for valid input\n    if n_steps < 2:\n        raise ValueError(\"n_steps must be at least 2.\")\n    if n_walks <= 0:\n        raise ValueError(\"n_walks must be positive.\")\n\n    # set seed for reproducibility\n    if seed is not None:\n        np.random.seed(seed)\n\n    # generate random walks\n    walks = []\n    for _ in range(n_walks):\n        # generate single random walk\n        walk = np.random.normal(0, 1, n_steps)\n        # add walk to list of walks\n        walks.append(walk)\n\n    # create figure\n    fig, ax = plt.subplots(figsize=(8, 6), dpi=150)\n    ax.set_aspect('auto')\n    ax.grid(alpha=0.2, linestyle='-', linewidth=0.5)\n\n    # create colors for walks\n    color_cycle = itertools.cycle(['b', 'g', 'r', '", "compilation_passed": false, "time": 0.00011205673217773438, "tests_passed": false, "error": "SyntaxError"}
{"code": "plt.style.use('dark_background')\n\n    if n_walks < 1 or n_steps < 1:\n        raise ValueError(\"n_walks and n_steps must be positive integers.\")\n\n    random_walks = []\n    colors = itertools.cycle(['b', 'g', 'r', 'c', 'm', 'y', 'k'])\n\n    for _ in range(n_walks):\n        random_walk = np.random.uniform(-20, 20, size=n_steps)\n        color = next(colors)\n\n        plt.plot(random_walk, color=color)\n        random_walks.append(random_walk)\n\n    ax = plt.gca()\n    ax.set_xticks([-20, -10, -0, +10, +20])\n    ax.set_xticklabels([\"\u221220\", \"\u221210\", \"0\", \"+10\", \"+20\"])\n    ax.set_yticklabels([])", "compilation_passed": true, "time": 0.009519815444946289, "tests_passed": true, "error": null}
{"code": "if (n_walks > 0) and (n_steps > 0):\n        np.random.seed(seed)\n\n        steps = [i for i in np.random.randint(1, 6, n_steps) if i in [1,2,3,4,5,6]]\n        steps.append(1)\n\n        for i in range(n_walks):\n            pos = [0]\n            for j in range(len(steps)):\n                pos.append(pos[j] + steps[j])\n\n            plt.plot(pos, [i+1] * len(pos), '-', color=itertools.cycle(['b', 'g', 'r', 'c', 'm', 'y', 'k'])[i], lw=2)\n\n        ax = plt.gca()\n        ax.get_xticklabels()\n        return ax\n    else:\n        raise ValueError(\"Inputs must be positive numbers.\")", "compilation_passed": true, "time": 0.001199960708618164, "tests_passed": false, "error": "TypeError"}
{"code": "np.random.seed(seed)\n\n    # Check for valid n_walks and n_steps\n    if n_walks < 1:\n        raise ValueError('n_walks must be a positive integer.')\n    if n_steps < 1:\n        raise ValueError('n_steps must be a positive integer.')\n\n    # Generate n_walks random walks of length n_steps\n    walks = np.random.normal(size=(n_walks, n_steps))\n\n    # Initialize figure and axes\n    fig, ax = plt.subplots()\n\n    # Create a list of colors for the walks\n    colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k']\n    colors = itertools.cycle(colors)\n\n    # Plot each walk in a different color\n    for walk in walks:\n        ax.plot(walk[:, 0], walk[:, 1])\n        ax.set_xlim(left=walk.min(), right=walk.max())\n        ax.set_ylim(", "compilation_passed": false, "time": 0.00023603439331054688, "tests_passed": false, "error": "SyntaxError"}
{"code": "random.seed(seed)\n    if n_steps < 1 or n_steps > 120:\n        raise ValueError(f\"Invalid number of steps: {n_steps}.\\n\"\n                         f\"Must be between 1 and 120.\")\n    if n_walks < 1:\n        raise ValueError(f\"Invalid number of walks: {n_walks}.\\n\"\n                         f\"Must be at least 1.\")\n    n_walks, n_steps = int(n_walks), int(n_steps)\n\n    # colors used: ['b', 'g', 'r', 'c', 'm', 'y', 'k']\n    colors = itertools.cycle(['b', 'g', 'r', 'c', 'm', 'y', 'k'])\n    # set up the figure\n    fig, ax = plt.subplots(figsize=(8, 6), dpi=100, frameon=True)\n\n    # create random walk\n    random", "compilation_passed": true, "time": 0.0009610652923583984, "tests_passed": false, "error": "NameError"}
{"code": "# Check for valid n_walks and n_steps\n    if not isinstance(n_walks, int) or n_walks < 1:\n        raise ValueError(\"n_walks must be a positive integer.\")\n    if not isinstance(n_steps, int) or n_steps < 1:\n        raise ValueError(\"n_steps must be a positive integer.\")\n\n    # Generate the random walks\n    np.random.seed(seed)\n    walks = [\n        np.random.choice(\n            [-20, 0, 20, 40, 60, 80, 100, 120],\n            size=n_steps,\n            p=[0.3, 0.2, 0.15, 0.1, 0.05, 0.05, 0.05, 0.05]\n        ) for _ in range(n_walks)\n    ]\n\n    # Plot the walks\n    colors = itertools.cycle(['b', 'g', 'r", "compilation_passed": false, "time": 9.298324584960938e-05, "tests_passed": false, "error": "SyntaxError"}
{"code": "plt.style.use(\"fivethirtyeight\")\n    color_list = ['b', 'g', 'r', 'c', 'm', 'y', 'k']\n    if n_walks > 7:\n        raise ValueError(\"Too many walks to plot. Maximum is 7.\")\n    if n_steps > 10000:\n        raise ValueError(\"Too many steps for this walk. Maximum is 10,000.\")\n    # print(n_walks, n_steps, color_list)\n\n    rng = np.random.default_rng(seed)\n    steps = rng.uniform(-20, 20, n_walks)\n    steps = steps.astype(int)\n    # print(steps)\n\n    ax = plt.subplot()\n    ax.set_ylim(-10, 10)\n    ax.set_xlim(-50, 50)\n    # plt.axis('off')\n\n    # Plot random walks\n    for i, step", "compilation_passed": false, "time": 0.00020313262939453125, "tests_passed": false, "error": "SyntaxError"}
{"code": "if not isinstance(n_walks, int) or not isinstance(n_steps, int):\n        raise TypeError(\"Input n_walks and n_steps must be integers.\")\n    if n_walks < 1 or n_steps < 1:\n        raise ValueError(\"n_walks and n_steps must be at least 1.\")\n\n    np.random.seed(seed)\n    walks = itertools.repeat(\n        [np.random.uniform(-20, 20, n_steps) for _ in range(n_walks)], n_walks\n    )\n    return plt.axes(figsize=(4, 4), sharex=True, sharey=True), plt.gca(), list(\n        zip(*np.array([*walks]))\n    )", "compilation_passed": true, "time": 0.004204988479614258, "tests_passed": false, "error": "TypeError"}
{"code": "if n_walks <= 0 or n_steps <= 0:\n        raise ValueError(\"n_walks and n_steps must be positive integers.\")\n\n    if seed is not None:\n        np.random.seed(seed)\n\n    random_walk = []\n    for _ in range(n_walks):\n        steps = np.random.choice([-1, 1], size=n_steps, replace=True)\n        random_walk.append(steps)\n\n    random_walk = np.vstack(random_walk).T.tolist()\n\n    ax = plt.subplots(n_walks, 1, figsize=(8, 6))[1]\n    for i, walk in enumerate(random_walk):\n        ax[i].plot(walk)\n        ax[i].set(xlim=[-n_steps / 2, n_steps / 2], ylim=[-1.5, 1.5])\n        ax[i].set_xticks([-n_steps / 2, 0, n_steps", "compilation_passed": false, "time": 0.000263214111328125, "tests_passed": false, "error": "SyntaxError"}
{"code": "n_walks, n_steps = int(n_walks), int(n_steps)\n\n    # Check for valid n_walks and n_steps\n    if n_walks <= 0 or n_steps <= 0:\n        raise ValueError(\"n_walks and n_steps must be positive integers.\")\n    if n_steps > 100:\n        raise ValueError(\"n_steps must be at most 100.\")\n\n    # Generate random walks\n    if seed is not None:\n        rng = np.random.default_rng(seed)\n    else:\n        rng = np.random.default_rng()\n    walks = []\n    for _ in range(n_walks):\n        steps = rng.randint(-100, 100, size=n_steps)\n        steps = np.cumsum(steps)\n        steps = np.clip(steps, -100, 100)\n        walks.append(steps)\n\n    # Plot random walks\n    colors = itertools", "compilation_passed": true, "time": 0.0010709762573242188, "tests_passed": false, "error": "AttributeError"}
{"code": "# Check that the parameters are valid and create a list of random numbers between -20 and 20.\n    if n_walks < 1 or n_steps < 1:\n        raise ValueError(\"n_walks and n_steps must be positive integers.\")\n\n    np.random.seed(seed)\n    walks = []\n    for _ in range(n_walks):\n        walk = np.random.randint(101, size=n_steps) - 50\n        walks.append(walk)\n\n    # Create a figure and set the layout and width and height for the subplots.\n    fig, ax = plt.subplots(1, n_walks, figsize=(1.4 * n_walks, 1.4))\n    fig.subplots_adjust(left=0, bottom=0, right=1, top=1, wspace=0, hspace=0)\n\n    # Set the aspect ratio of the axes to 1:1.\n    ax.set_aspect(1)\n    # Set the limits of the x-axis to be", "compilation_passed": true, "time": 1.8261520862579346, "tests_passed": false, "error": "TimeoutError"}
{"code": "n_walks = int(n_walks)\n    if n_walks < 0:\n        raise ValueError(f\"Invalid number of walks: {n_walks}. Please enter a positive integer.\")\n\n    n_steps = int(n_steps)\n    if n_steps < 1:\n        raise ValueError(f\"Invalid number of steps: {n_steps}. Please enter a positive integer.\")\n\n    if seed is not None:\n        np.random.seed(seed)\n\n    walks = []\n    for _ in range(n_walks):\n        walk = np.zeros(n_steps)\n        for i in range(1, n_steps + 1):\n            if i % 2 == 1:\n                walk[i - 1] = np.random.choice([1, 2])\n            else:\n                walk[i - 1] = np.random.choice([3, 4])\n        walks.append(walk)\n\n    colours = itertools.cycle(['b', 'g', 'r', '", "compilation_passed": false, "time": 0.00013637542724609375, "tests_passed": false, "error": "SyntaxError"}
{"code": "n_steps = max(5, n_steps)\n    n_walks = max(5, n_walks)\n    random.seed(seed)\n    plt.style.use(\"seaborn-poster\")\n    colors = itertools.cycle(['b', 'g', 'r', 'c', 'm', 'y', 'k'])\n    steps = list(range(-n_steps, n_steps + 1))\n    ax = plt.subplots(figsize=(16, 4), ncols=16, squeeze=False)[0]\n\n    for i in range(n_walks):\n        y_points = [random.choice(steps) for _ in range(n_steps)]\n        y_points = np.asarray(y_points, int)\n\n        x_points = np.arange(-n_steps, n_steps + 1, 1, dtype=int)\n        ax.plot(x_points, y_points, next(colors) + \"-\")\n\n    ax.set_xticks(range(-n", "compilation_passed": false, "time": 0.0002770423889160156, "tests_passed": false, "error": "SyntaxError"}
{"code": "np.random.seed(seed)\n    walks = np.random.randint(0, 1, size=[n_walks, n_steps])\n    colors = itertools.cycle(['b', 'g', 'r', 'c', 'm', 'y', 'k'])\n    for walk in walks:\n        plt.plot(walk, color=next(colors))\n    plt.show()\n    return plt.gca()", "compilation_passed": true, "time": 0.007969856262207031, "tests_passed": true, "error": null}
{"code": "rng = np.random.RandomState(seed)\n    color_cycle = itertools.cycle(['b', 'g', 'r', 'c', 'm', 'y', 'k'])\n    for i in range(n_walks):\n        walk = rng.uniform(-20, 20, n_steps)\n        ax.plot(np.linspace(-20, 20, n_steps), walk, next(color_cycle))\n    return ax", "compilation_passed": true, "time": 0.0010540485382080078, "tests_passed": false, "error": "NameError"}
{"code": "if seed:\n        np.random.seed(seed)\n\n    if not n_walks > 0 or not n_steps > 0:\n        return print(\"n_walks and n_steps must be positive integers\")\n\n    walks = np.random.uniform(-100, 100, (n_walks, n_steps))\n\n    color_cycle = itertools.cycle(['b', 'g', 'r', 'c', 'm', 'y', 'k'])\n\n    for walk, color in zip(walks, color_cycle):\n        ax = plt.plot(walk, color=color)\n\n    return ax", "compilation_passed": true, "time": 0.00500798225402832, "tests_passed": true, "error": null}
{"code": "np.random.seed(seed)\n    colors = itertools.cycle(['b', 'g', 'r', 'c', 'm', 'y', 'k'])\n\n    # Check if n_walks and n_steps are valid integers\n    if not isinstance(n_walks, int) or not isinstance(n_steps, int):\n        print(\"Invalid input for n_walks and n_steps\")\n        return\n\n    if n_walks < 0 or n_steps < 0:\n        print(\"n_walks and n_steps cannot be negative\")\n        return\n\n    # Create the random walks\n    walks = [np.random.randint(0, 2, n_steps).cumsum() for _ in range(n_walks)]\n\n    # Create the axes object\n    fig, ax = plt.subplots()\n\n    # Plot the random walks\n    for walk in walks:\n        ax.plot(np.arange(walk.size), walk, color=next(colors), linewidth=1)\n\n    # Set", "compilation_passed": true, "time": 0.004505157470703125, "tests_passed": true, "error": null}
{"code": "# Check for valid n_walks and n_steps\n    if n_walks < 0 or n_steps < 0:\n        raise ValueError(\"Invalid n_walks and n_steps\")\n\n    # Create a random number generator (np.random) using the provided seed\n    # Note that if no seed is provided, a default seed (42) will be used\n    if seed:\n        np.random.seed(seed)\n\n    # Initialize the plot with 100 steps\n    x = np.arange(101)  # x-axis values from 0 to 100 (inclusive)\n    y = np.zeros_like(x)  # y-axis values (all zero initially)\n\n    # Create a random number generator (np.random)\n    rng = np.random.default_rng()\n\n    # Loop over n_walks times\n    for _ in range(n_walks):\n        # Loop over n_steps times\n        for i in range(n_steps):\n            # Choose a random direction based on the probabilities defined below\n            direction", "compilation_passed": true, "time": 0.0010020732879638672, "tests_passed": false, "error": "NameError"}
{"code": "random.seed(seed)\n\n    if not (isinstance(n_walks, int) and isinstance(n_steps, int)):\n        raise TypeError(f'n_walks and n_steps must be int, not {type(n_walks)} and {type(n_steps)}')\n    if n_steps < 0:\n        raise ValueError(f'n_steps must be non-negative, not {n_steps}')\n    if n_walks < 1:\n        raise ValueError(f'n_walks must be positive, not {n_walks}')\n\n    colors = itertools.cycle(['b', 'g', 'r', 'c', 'm', 'y', 'k'])\n\n    ax = plt.subplots().get_axes()[0]\n    ax.set_xticks(np.arange(0, n_steps, 10))\n    ax.set_xticklabels(np.arange(0, n_steps, 10).astype(int))\n    for _ in range(n_", "compilation_passed": false, "time": 0.0002617835998535156, "tests_passed": false, "error": "SyntaxError"}
{"code": "# Validations\n    if seed is None:\n        rng = np.random\n    else:\n        rng = np.random.RandomState(seed)\n    if n_walks < 0 or n_steps < 0:\n        raise ValueError('`n_walks` and `n_steps` must be positive integers!')\n\n    # Initialize the plot\n    fig, ax = plt.subplots()\n\n    # Generate the walks\n    for _ in itertools.repeat(None, n_walks):\n        pos = 0\n        colors = plt.cm.get_cmap('hsv', n_walks)\n        while abs(pos) < n_steps:\n            move = rng.binomial(1, 0.25)\n            pos += 1 if move else -1\n            color = colors(_+1)\n            ax.scatter(pos, 0, s=3, c=color, marker='o')\n        ax.set_xlim(-n_steps, n_steps)\n        ax.set_ylim(-n_steps, n_steps)\n", "compilation_passed": true, "time": 0.004025936126708984, "tests_passed": false, "error": "TypeError"}
{"code": "# Check that n_walks and n_steps are integers and greater than 0.\n    if not (isinstance(n_walks, int) and n_walks > 0):\n        print(\"n_walks must be an integer greater than 0.\")\n        return\n    if not (isinstance(n_steps, int) and n_steps > 0):\n        print(\"n_steps must be an integer greater than 0.\")\n        return\n\n    # Check that the seed is an integer.\n    if seed is not None:\n        if not (isinstance(seed, int)):\n            print(\"seed must be an integer.\")\n            return\n\n    # Generate walks.\n    np.random.seed(seed)  # Seed random number generator.\n    walk = np.zeros(n_steps)  # Initialize array of zeros.\n\n    for i in range(n_walks):  # Iterate over each random walk.\n        for j in range(n_steps):  # Iterate over each step in the walk.\n            walk[j] += 1  ", "compilation_passed": true, "time": 0.0010249614715576172, "tests_passed": true, "error": null}
{"code": "walks = []\n    if n_walks <= 0:\n        raise ValueError(\"n_walks must be positive integer.\")\n    if n_steps <= 0:\n        raise ValueError(\"n_steps must be positive integer.\")\n\n    if seed is not None:\n        np.random.seed(seed)\n\n    for _ in range(n_walks):\n        walk = []\n        for _ in range(n_steps):\n            if not walk:\n                walk.append(0.0)\n            new_value = np.random.choice([-20, 20, -20])\n            walk.append(walk[-1] + new_value)\n        walks.append(walk)\n\n    fig, ax = plt.subplots()\n    # TODO\n    # Complete the task using itertools and matplotlib.\n    # Use a for loop to iterate over the walks and plot each one\n    # in a different color.\n    # Do not change the following lines as they are used for testing.\n    ax.plot([w[0] for w in walks],", "compilation_passed": false, "time": 0.0002307891845703125, "tests_passed": false, "error": "SyntaxError"}
{"code": "np.random.seed(seed)\n    walk_lengths = np.random.choice(range(1, n_steps + 1), n_walks, replace=False)\n\n    fig, ax = plt.subplots(1, 1)\n\n    for i in range(n_walks):\n        ax.plot([i], [walk_lengths[i]], 'o', color='b')\n\n    for x in itertools.chain([0], [n for n in range(1, n_steps, 10)], [n_steps], [n_steps + 1]):\n        ax.axvline(x, color='k', alpha=0.5)\n    for y in itertools.chain([0], [n for n in range(1, n_walks, 10)], [n_walks], [n_walks + 1]):\n        ax.axhline(y, color='k', alpha=0.5)\n\n    return ax", "compilation_passed": true, "time": 0.013433218002319336, "tests_passed": true, "error": null}
{"code": "walks = itertools.repeat([0.0], n_steps)\n    if not seed:\n        np.random.seed()\n    else:\n        np.random.seed(seed)\n\n    for _ in range(n_walks):\n        for _ in range(n_steps - 1):\n            new = walks.__next__() + np.random.choice([-1, 1])\n            walks.__next__() = new\n\n    x_values = np.arange(n_steps)\n    y_values = np.array(list(walks))\n    plt.bar(x_values, y_values, width=1, alpha=0.5)\n    plt.ylabel(\"distance\")\n    return plt.gca()", "compilation_passed": false, "time": 0.00017523765563964844, "tests_passed": false, "error": "SyntaxError"}
{"code": "np.random.seed(seed)\n    if n_walks > 0 and n_steps > 0:\n        walks = np.array([np.random.randint(-10, 10, n_steps) for _ in range(n_walks)])\n        colors = itertools.cycle(['b', 'g', 'r', 'c', 'm', 'y', 'k'])\n        ax = plt.subplot(1, 1, 1)\n        ax.grid()\n        for i, walk in enumerate(walks):\n            color = next(colors)\n            ax.plot(walk, color=color)\n            ax.set_xticks([i*20+j for j in range(-20, 100, 20)])\n            ax.set_xticklabels([str(i*20+j) for j in range(-20, 100, 20)])\n            ax.set_yticks(range(-10, 101, 20))\n            ax.set_yticklabels", "compilation_passed": true, "time": 0.00870513916015625, "tests_passed": true, "error": null}
{"code": "if n_steps < 100 or n_walks < 10:\n        raise ValueError(\"The number of steps and number of walks must be at least 100\")\n    random.seed(seed)\n    colors_cycle = itertools.cycle(['b', 'g', 'r', 'c', 'm', 'y', 'k'])\n    np.random.seed(seed)\n\n    fig, ax = plt.subplots()\n    for i in range(n_walks):\n        x_vals = np.linspace(-20, 120, n_steps)\n        y_vals = np.random.rand(n_steps) * 3 + np.sin(x_vals)\n        ax.plot(x_vals, y_vals, color=next(colors_cycle))\n    return ax", "compilation_passed": true, "time": 0.002017974853515625, "tests_passed": false, "error": "ValueError"}
{"code": "# Checking valid input values\n    if not isinstance(n_walks, int):\n        raise TypeError(f'n_walks must be of type int. Got {type(n_walks)} instead.')\n    if not isinstance(n_steps, int):\n        raise TypeError(f'n_steps must be of type int. Got {type(n_steps)} instead.')\n    if n_walks <= 0:\n        raise ValueError('n_walks must be a positive integer.')\n    if n_steps <= 0:\n        raise ValueError('n_steps must be a positive integer.')\n\n    # Generating random walks\n    np.random.seed(seed)\n    random_walks = [np.random.uniform(low=-1, high=1, size=(n_steps, 2)) for _ in range(n_walks)]\n\n    # Plotting the random walks\n    ax = plt.gca()\n    ax.set_xlabel(\"x\")\n    ax.set_ylabel(\"y\")\n    ax.set_xlim(-1.2", "compilation_passed": false, "time": 0.00024700164794921875, "tests_passed": false, "error": "SyntaxError"}
{"code": "# Generate random number generator object with given seed\n    random_generator = np.random.Generator(np.random.MT19937(seed))\n    colors = itertools.cycle(\n        ['b', 'g', 'r', 'c', 'm', 'y', 'k']\n    )\n\n    for _ in range(n_walks):\n        # Generate n_steps number of random steps for the current walk\n        random_walk = random_generator.normal(size=n_steps)\n        # Plot the random walk with different color for each walk\n        color = next(colors)\n        # Plot the walk, add axes labels and title, then show the plot\n        ax = plt.plot(random_walk, color=color)\n        ax.set(xlabel='Steps', ylabel='Random WALK')\n        ax.set_title('Random walk for n={} steps'.format(n_steps))\n        plt.show()\n\n    return ax", "compilation_passed": true, "time": 0.004288911819458008, "tests_passed": false, "error": "AttributeError"}
{"code": "np.random.seed(seed)\n    if n_walks <= 0 or n_steps <= 0:\n        print(\"Both n_walks and n_steps must be greater than 0!\")\n        return\n    colors = itertools.cycle(['b', 'g', 'r', 'c', 'm', 'y', 'k'])\n    x = np.random.uniform(0, 20, size=n_steps)\n    y = np.random.uniform(0, 20, size=n_steps)\n    plt.scatter(x, y, c=colors, s=1, edgecolors='w', alpha=0.5, lw=0.5, rasterized=True, zorder=5)\n    for tl in plt.gca().get_xticklabels():\n        tl.set_ha('left')\n    plt.gca().set_aspect(1, 'box', 'equal')\n    return plt.gca()", "compilation_passed": true, "time": 0.004269838333129883, "tests_passed": false, "error": "TypeError"}
