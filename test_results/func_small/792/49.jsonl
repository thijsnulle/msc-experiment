{"code": "feature_col = df[feature]\n    target_col = df[target]\n    # \u68c0\u67e5\u6307\u5b9a\u5217\u5728 DataFrame \u4e2d\u662f\u5426\u5305\u542b\n    if not all(col in df for col in [feature, target]):\n        raise ValueError(f\"{feature} and {target} must be in df\")\n    # \u6784\u5efa\u7ebf\u6027\u56de\u5f52\u6a21\u578b\n    model = LinearRegression()\n    model.fit(feature_col.values.reshape(-1, 1), target_col.values)\n    residuals = np.absolute(target_col - model.predict(feature_col.values.reshape(-1, 1)))\n    # \u5c06\u7ed3\u679c\u6839\u636e\u7edd\u5bf9\u503c\u964d\u5e8f\u6392\u5217\n    indices = np.argsort(residuals)[:n]\n    return indices, model", "compilation_passed": true, "time": 0.003014802932739258, "tests_passed": false, "error": "NameError"}
{"code": "residuals = []\n    indices = []\n    model = LinearRegression()\n\n    for idx, row in df.iterrows():\n        model.fit(df[[feature]], df[target])\n        residuals.append(model.resid_sum_squares / len(df))\n        indices.append(idx)\n    indices.sort(key=lambda x: residuals[x], reverse=True)\n    indices = indices[:n]\n    return indices, model", "compilation_passed": true, "time": 0.003522157669067383, "tests_passed": false, "error": "AttributeError"}
{"code": "if feature not in df or target not in df:\n        raise ValueError(\n            f\"Feature or target not in DataFrame.\\n\\n\"\n            f\"Columns in df: {list(df.columns)}\\n\\n\"\n            f\"feature: {feature}\\n\\ntarget: {target}\"\n        )\n\n    feature_arr = df[feature].values\n    target_arr = df[target].values\n    coef = LinearRegression().fit(feature_arr.reshape(-1, 1), target_arr)\n\n    residual_arr = (target_arr - coef.predict(feature_arr.reshape(-1, 1))).reshape(-1)\n    sorted_residual_indices = np.argsort(residual_arr)\n\n    return sorted_residual_indices[:n], coef", "compilation_passed": true, "time": 0.0030820369720458984, "tests_passed": false, "error": "NameError"}
{"code": "if feature not in df:\n        raise ValueError(\"The provided feature column not in the DataFrame.\")\n    if target not in df:\n        raise ValueError(\"The provided target column not in the DataFrame.\")\n    regr = LinearRegression().fit(df[[feature]], df[[target]])\n    residuals = abs(df[[feature]].to_numpy() - regr.predict(df[[feature]]))\n    sorted_indices = list(range(df.shape[0]))\n    heapq.heapify(sorted_indices)\n    while len(sorted_indices) > n:\n        heapq.heappop(sorted_indices)\n    return sorted_indices, regr", "compilation_passed": true, "time": 0.013804912567138672, "tests_passed": false, "error": "ValueError"}
{"code": "if not feature in df.columns:\n        raise ValueError(\"feature not in df.columns\")\n    if not target in df.columns:\n        raise ValueError(\"target not in df.columns\")\n\n    X = df[[feature]]\n    Y = df[[target]]\n    model = LinearRegression().fit(X, Y)\n\n    residuals = list(model.resid.values)\n    n_largest_indices = heapq.nlargest(n, range(len(residuals)), key=lambda i: residuals[i])\n\n    return n_largest_indices, model", "compilation_passed": true, "time": 0.0037698745727539062, "tests_passed": false, "error": "AttributeError"}
{"code": "res = df[target] - (df[feature] * model.coef_ + model.intercept_)\n    res = res.values\n    res = heapq.nlargest(n, range(len(res)), res.__getitem__)\n    return res, model", "compilation_passed": true, "time": 0.002602815628051758, "tests_passed": false, "error": "NameError"}
{"code": "assert isinstance(n, int), \"n should be an int\"\n    assert n >= 1, \"n should be >= 1\"\n\n    assert target in df.columns, \"target not in DataFrame\"\n    assert feature in df.columns, \"feature not in DataFrame\"\n    assert feature != target, \"feature and target cannot be the same column\"\n\n    df_copy = df.copy()\n    df_copy[target] = df_copy[target] / 10\n    df_copy[target] = df_copy[target] / 10\n\n    df_copy[target] = df_copy[target] / 10\n    df_copy[target] = df_copy[target] / 10\n\n    X = df_copy[[feature]].values\n    Y = df_copy[[target]].values\n\n    lr_model = LinearRegression()\n    lr_model.fit(X, Y)\n\n    model = lr_model\n\n    # 1. Get a list of residuals\n    residuals = []\n    for i, y in enumerate(", "compilation_passed": false, "time": 0.0002789497375488281, "tests_passed": false, "error": "SyntaxError"}
{"code": "if (feature not in df.columns) or (target not in df.columns):\n        raise ValueError(f\"{feature} or {target} is not in the DataFrame.\")\n\n    regr = LinearRegression()\n    model = regr.fit(df[[feature]], df[target])\n\n    # Note: This is not the correct way to get the largest residual.\n    # Instead, we should use the r2_score to get the largest residual, and then\n    # use it to get the indices of the largest residual.\n    residuals = df[target] - model.predict(df[[feature]])\n    indices = sorted(range(len(residuals)), key=lambda x: residuals[x])[:n]\n    return indices, model", "compilation_passed": true, "time": 0.010734081268310547, "tests_passed": true, "error": null}
{"code": "if not (feature in df and target in df):\n        raise ValueError(\"Columns not found in DataFrame\")\n\n    model = LinearRegression()\n    res = []\n\n    for i in range(len(df)):\n        X = np.array([df.loc[i, feature]])\n        y = np.array([df.loc[i, target]])\n        model.fit(X, y)\n        res.append(model.resid[i])\n\n    indices = heapq.nlargest(n, range(len(res)), key=res.__getitem__)\n    return indices, model", "compilation_passed": true, "time": 0.0027780532836914062, "tests_passed": false, "error": "NameError"}
{"code": "if feature not in df.columns or target not in df.columns:\n        raise ValueError(f\"{feature} and {target} columns are not in the DataFrame.\")\n\n    # fit linear regression model\n    model = LinearRegression()\n    model.fit(df[feature].values.reshape(-1, 1), df[target])\n    residuals = df[target].values.reshape(-1, 1) - model.predict(df[feature].values.reshape(-1, 1))\n    residuals_ordered = (-residuals).argsort()[:n]\n    return residuals_ordered, model", "compilation_passed": true, "time": 0.006078958511352539, "tests_passed": true, "error": null}
{"code": "if feature not in df:\n        raise ValueError(f\"{feature} not in df.\")\n    if target not in df:\n        raise ValueError(f\"{target} not in df.\")\n\n    X = df[feature].values.reshape(-1,1)\n    y = df[target].values\n\n    model = LinearRegression()\n    model.fit(X, y)\n\n    residuals = np.array([(r, i) for i, r in enumerate(np.abs(y-model.predict(X)))])\n\n    indices = heapq.nsmallest(n, residuals, key=lambda x: x[0])\n    return list(map(lambda x: x[1], indices)), model", "compilation_passed": true, "time": 0.002871990203857422, "tests_passed": false, "error": "NameError"}
{"code": "if not isinstance(df, DataFrame):\n        raise ValueError('df must be a DataFrame')\n    if feature not in df.columns:\n        raise ValueError('feature column not in the provided DataFrame')\n    if target not in df.columns:\n        raise ValueError('target column not in the provided DataFrame')\n    model = LinearRegression().fit(df[feature], df[target])\n    residuals = np.abs(df[target] - model.predict(df[feature]))\n    indices = np.argsort(-residuals)[:n]\n    return indices, model", "compilation_passed": true, "time": 0.002566099166870117, "tests_passed": false, "error": "NameError"}
{"code": "if feature not in df.columns:\n        raise ValueError(\"Feature not in DataFrame columns\")\n    if target not in df.columns:\n        raise ValueError(\"Target not in DataFrame columns\")\n\n    model = LinearRegression()\n    model.fit(df[[feature]], df[target])\n    indices = model.predict(df[[feature]]).argsort()[::-1]\n    return indices[:n], model", "compilation_passed": true, "time": 0.010163068771362305, "tests_passed": true, "error": null}
{"code": "if feature not in df.columns:\n        raise ValueError(f\"Column {feature} not found in dataframe.\")\n    if target not in df.columns:\n        raise ValueError(f\"Column {target} not found in dataframe.\")\n    df[target] = df[target].astype(np.float64)\n    df[feature] = df[feature].astype(np.float64)\n\n    # Sort by target column and return indices of top n elements\n    sorted_indices = np.argsort(-df.groupby(feature)[target].mean())[:n]\n    model = LinearRegression().fit(df[feature].values.reshape(-1, 1), df[target].values)\n\n    return sorted_indices, model", "compilation_passed": true, "time": 0.002657175064086914, "tests_passed": false, "error": "NameError"}
{"code": "# Task 1\n    residuals = df[feature] - df[target]\n    regression = LinearRegression()\n    regression.fit(df[[feature]], df[target])\n\n    # Task 2\n    indices = [i for i in range(n)]\n    for i in range(1, n):\n        for j in range(i):\n            if residuals[indices[j]] > residuals[indices[i]]:\n                indices[i], indices[j] = indices[j], indices[i]\n\n    return indices[0:n], regression", "compilation_passed": true, "time": 0.008487939834594727, "tests_passed": false, "error": "KeyError"}
{"code": "assert n <= len(df[feature])\n    if feature not in df.columns or target not in df.columns:\n        raise ValueError(f\"{feature} and {target} not in df columns\")\n\n    df.drop(columns=[feature, target], inplace=True)\n    df[feature] = df[feature].astype(float)\n    df[target] = df[target].astype(float)\n    model = LinearRegression().fit(df[feature].values.reshape(-1, 1), df[target].values.reshape(-1, 1))\n\n    return [i for i, _ in sorted(enumerate(model.resid), key=lambda x: x[1])][0:n], model", "compilation_passed": true, "time": 0.002939939498901367, "tests_passed": false, "error": "KeyError"}
{"code": "if feature not in df.columns:\n        raise ValueError('Specified column is not in the DataFrame.')\n    if target not in df.columns:\n        raise ValueError('Specified column is not in the DataFrame.')\n    residuals = []\n\n    for i in range(df.shape[0]):\n        reg = LinearRegression()\n        reg.fit(df.loc[i:i, [feature]], df.loc[i:i, [target]])\n        residuals.append(reg.predict(df.loc[i:i, [feature]]) - df.loc[i:i, [target]])\n    residuals = np.asarray(residuals)\n\n    indices = heapq.nsmallest(n, range(len(residuals)), key=lambda i: residuals[i])\n\n    return indices, model", "compilation_passed": true, "time": 0.1462998390197754, "tests_passed": false, "error": "NameError"}
{"code": "# Requirement: heapq\n    if feature not in df.columns:\n        raise ValueError(f\"{feature} not in DataFrame\")\n    if target not in df.columns:\n        raise ValueError(f\"{target} not in DataFrame\")\n\n    df_index = df.index\n    df_array = df[feature].values\n    model = LinearRegression().fit(X=df_array, y=df_array)\n\n    # Requirement: sklearn.linear_model\n    residual = model.predict(X=df_array) - df[target].values\n    sorted_residual = sorted(range(len(residual)), key=lambda i: residual[i])\n\n    if n < 0:\n        raise ValueError(\"n must be a positive value.\")\n    if n > len(residual):\n        raise ValueError(\"n must be smaller than or equal to length of residual.\")\n    residual = heapq.nsmallest(n, sorted_residual, key=lambda i: residual[i])\n\n    return list(res", "compilation_passed": false, "time": 0.0003070831298828125, "tests_passed": false, "error": "SyntaxError"}
{"code": "indices = []\n    model = LinearRegression()\n\n    if feature not in df.columns:\n        raise ValueError(\"'col1' is not in DataFrame columns\")\n    if target not in df.columns:\n        raise ValueError(\"'col2' is not in DataFrame columns\")\n    if n < 1:\n        raise ValueError(\"n should be greater than or equal to 1\")\n\n    for i in range(1, n+1):\n        model.fit(df[feature].iloc[i:n], df[target].iloc[i:n])\n        r_squared = model.score(df[feature].iloc[i:n], df[target].iloc[i:n])\n        if r_squared < 0:\n            break\n        else:\n            indices.append(i-1)\n    return indices, model", "compilation_passed": true, "time": 0.0031409263610839844, "tests_passed": false, "error": "ValueError"}
{"code": "if feature not in df.columns or target not in df.columns:\n        raise ValueError(\"Please provide columns that are in the DataFrame\")\n    df1 = df.copy()\n    df1.drop([feature, target], axis=1, inplace=True)\n    model = LinearRegression()\n    model.fit(df1.values, df[target])\n\n    # Initialize a priority queue for storing indices\n    pq = []\n    for i in range(len(df)):\n        residual = abs(model.predict(df1.iloc[i].values.reshape(1, -1))[0] - df[target][i])\n        pq.append((-residual, i))\n\n    # Sort pq based on residuals in descending order\n    heapq.heapify(pq)\n\n    # Get the n indices with largest residuals\n    largest_residuals = []\n    for _ in range(n):\n        residual, index = heapq.heappop(pq)\n        largest_residuals.append(index)\n    return largest_residuals, model", "compilation_passed": true, "time": 0.003103971481323242, "tests_passed": false, "error": "ValueError"}
{"code": "# check if specified columns are in the DataFrame\n    if feature not in df.columns or target not in df.columns:\n        raise ValueError(\n            \"Specified columns are not in the provided DataFrame.\")\n\n    # fit linear regression model\n    model = LinearRegression()\n    model.fit(df[feature].values.reshape(-1, 1), df[target].values)\n\n    # obtain residuals\n    residuals = np.abs(model.predict(df[feature].values.reshape(-1, 1)) - df[target].values)\n\n    # obtain indices of the n largest residuals\n    indices = np.argsort(residuals)[-n:][::-1]\n\n    return indices, model", "compilation_passed": true, "time": 0.0029528141021728516, "tests_passed": false, "error": "NameError"}
{"code": "model = LinearRegression()\n    residuals = []\n    for _ in range(n):\n        model.fit(df[feature].to_numpy().reshape(-1, 1), df[target].to_numpy())\n        residual = df[[feature, target]].iloc[0:1][[feature]].dot(model.coef_) - df[[target]].iloc[0:1][[target]].values[0]\n        residuals.append(residual)\n\n    indices = [i[0] for i in sorted(enumerate(residuals), key=lambda x: abs(x[1]), reverse=True)]\n    return indices, model", "compilation_passed": true, "time": 0.010025978088378906, "tests_passed": false, "error": "ValueError"}
{"code": "if (feature not in df.columns) or (target not in df.columns):\n        raise ValueError(\"Column not found\")\n\n    X = df[feature].values\n    y = df[target].values\n\n    model = LinearRegression()\n    model.fit(X, y)\n\n    residuals = model.predict(X) - y\n    residuals_array = np.array(residuals)\n    indices = np.argsort(residuals_array)[-n:]\n    indices.sort(reverse=False)\n    indices = list(indices)\n\n    return indices, model", "compilation_passed": true, "time": 0.0029649734497070312, "tests_passed": false, "error": "Reshape your data either using array.reshape(-1, 1) if your data has a single feature or array.reshape(1, -1) if it contains a single sample."}
{"code": "try:\n        df = df[df[feature].dtype == int]\n        df = df[df[target].dtype == int]\n        # df = df.dropna()\n        df.index = df.index\n        df.columns = df.columns\n        target = target.upper()\n        feature = feature.upper()\n        if target not in df.columns:\n            raise ValueError(\"Target column not found.\")\n        if feature not in df.columns:\n            raise ValueError(\"Feature column not found.\")\n    except Exception as e:\n        raise ValueError(\"Dataframe not suitable.\")\n\n    x_train = df[feature]\n    y_train = df[target]\n    regressor = LinearRegression().fit(x_train, y_train)\n    df.reset_index(drop=True, inplace=True)\n    df = df.sort_values(target, ascending=False)\n    # print(df)\n    indices = df.index\n    return indices[:n], regressor", "compilation_passed": true, "time": 0.0027959346771240234, "tests_passed": false, "error": "ValueError"}
{"code": "# Check if the specified columns are in the DataFrame\n    if feature not in df.columns or target not in df.columns:\n        raise ValueError(f\"Invalid feature or target column: {feature} or {target}\")\n\n    # Fit the linear regression model\n    model = LinearRegression()\n    model.fit([df[feature], df[target]], df[[target]])\n\n    # Get the residuals\n    residuals = [abs(y - model.predict([[x]])[0][0]) for x, y in zip(df[feature], df[target])]\n\n    # Sort residuals in descending order\n    sorted_indices = sorted(range(len(residuals)), key=lambda i: residuals[i], reverse=True)\n\n    # Get the indices of the n largest residuals\n    return sorted_indices[:n], model", "compilation_passed": true, "time": 0.003340005874633789, "tests_passed": false, "error": "ValueError"}
{"code": "model = LinearRegression()\n    model.fit(df[[feature, target]], df[target])\n    residuals = [\n        np.linalg.norm(df[[feature, target]][i].values -\n                       model.predict(df[[feature, target]][i].values))\n        for i in range(len(df))]\n    indices = [i for i in range(len(residuals)) if i not in range(n, 0, -1)]\n\n    return indices, model", "compilation_passed": true, "time": 0.0033071041107177734, "tests_passed": false, "error": "NameError"}
{"code": "if feature not in df.columns:\n        raise ValueError(f\"Column '{feature}' not found.\")\n    if target not in df.columns:\n        raise ValueError(f\"Column '{target}' not found.\")\n    x = df.pop(feature)\n    y = df.pop(target)\n    model = LinearRegression()\n    model.fit(x, y)\n    residuals = [model.resid_sum_squares / model.coef_.shape[0]]\n    residuals.extend(sorted(range(len(residuals)), key=lambda i: residuals[i])[:n])\n    return residuals, model", "compilation_passed": true, "time": 0.003111124038696289, "tests_passed": false, "error": "ValueError"}
{"code": "residuals = []\n    model = LinearRegression()\n    indices = []\n    for row in range(df.shape[0]):\n        x = df.iloc[row][feature]\n        y = df.iloc[row][target]\n        model.fit([[x]], [y])\n        residuals.append(model.resid)\n    # 2. \u6309\u7167\u6b8b\u5dee\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u83b7\u5f97\u7d22\u5f15\u5217\u8868\n    residuals.sort()\n    for i in range(n):\n        indices.append(residuals.index(residuals[i]))\n    indices.sort()\n    return indices, model", "compilation_passed": true, "time": 0.0028066635131835938, "tests_passed": false, "error": "AttributeError"}
{"code": "if feature not in df.columns or target not in df.columns:\n        raise ValueError(\"Feature and target columns must be present in the DataFrame.\")\n\n    # Sort the DataFrame based on the specified target column in ascending order\n    sorted_df = df.sort_values(target)\n\n    # Initialize an empty list to store the indices of the n largest residuals\n    indices = []\n\n    # Fit a linear regression model using the first n rows of the sorted DataFrame\n    model = LinearRegression()\n    model.fit(sorted_df[feature][:n].reshape(-1, 1), sorted_df[target].iloc[:n])\n\n    # Calculate the residuals for each row in the sorted DataFrame\n    residuals = sorted_df[target] - model.predict(sorted_df[feature].iloc[:n].reshape(-1, 1))\n\n    # Append the indices of the n largest residuals to the indices list\n    for i in range(n):\n        max_residual = np.max(residuals[i:])\n        indices", "compilation_passed": true, "time": 0.0029060840606689453, "tests_passed": false, "error": "AttributeError"}
{"code": "if feature not in df.columns:\n        raise ValueError(f\"Feature '{feature}' not found in DataFrame.\")\n    if target not in df.columns:\n        raise ValueError(f\"Target '{target}' not found in DataFrame.\")\n\n    model = LinearRegression()\n    residuals = []\n    for i in range(n):\n        model.fit(df[[feature, target]].to_numpy(), df[target].to_numpy())\n        residuals.append(model.predict(df[[feature, target]].to_numpy()) - df[target].to_numpy())\n\n    indices = heapq.nsmallest(n, range(len(residuals)), key=lambda x: residuals[x])\n\n    return indices, model", "compilation_passed": true, "time": 0.006868839263916016, "tests_passed": false, "error": "ValueError"}
