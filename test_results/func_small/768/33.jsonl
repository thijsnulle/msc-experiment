{"code": "if not os.path.exists(dir_path):\n        raise ValueError(f'Directory {dir_path} does not exist!')\n\n    pattern = re.compile(r'(?i)\\berror\\b')\n    text_paths = glob.glob(f'{dir_path}/**/*.txt', recursive=True)\n\n    occurrences = {}\n\n    for path in text_paths:\n        with open(path, 'r') as f:\n            line_count = 0\n            occurrence_count = 0\n            for line in f:\n                line_count += 1\n                if re.search(pattern, line):\n                    occurrence_count += 1\n        if occurrence_count:\n            occurrences[os.path.relpath(path, dir_path)] = occurrence_count\n    return occurrences", "compilation_passed": true, "time": 0.004273891448974609, "tests_passed": true, "error": null}
{"code": "if not os.path.isdir(dir_path):\n        raise ValueError(\"Directory does not exist.\")\n    regex = r\"error\"\n    result_dict = {}\n\n    file_paths = glob.glob(f\"{dir_path}/*.txt\", recursive=True)\n    for file_path in file_paths:\n        with open(file_path, encoding=\"utf-8\") as f:\n            content = f.read()\n        matches = re.findall(regex, content, re.I)\n        if matches:\n            result_dict[os.path.relpath(file_path, dir_path)] = len(matches)\n\n    return result_dict", "compilation_passed": true, "time": 0.0018451213836669922, "tests_passed": true, "error": null}
{"code": "if not os.path.isdir(dir_path):\n        raise ValueError(\"dir_path is not a directory!\")\n\n    file_paths = glob.glob(os.path.join(dir_path, \"**/*.txt\"), recursive=True)\n\n    result = {}\n\n    # For every file path, read the content and check for occurrences\n    for file_path in file_paths:\n        with open(file_path, 'r') as f:\n            content = f.read().lower()\n            result[os.path.relpath(file_path, dir_path)] = len(re.findall(r'error', content))\n\n    return result", "compilation_passed": true, "time": 0.004791736602783203, "tests_passed": true, "error": null}
{"code": "if not os.path.exists(dir_path):\n        raise ValueError(\"Directory does not exist: \" + dir_path)\n\n    text_files = glob.glob(os.path.join(dir_path, \"**/*.txt\"), recursive=True)\n    matches = {}\n\n    for file in text_files:\n        with open(file, \"r\") as f:\n            contents = f.read()\n            matches[file] = len(re.findall(r\"error\", contents, re.IGNORECASE))\n\n    return matches", "compilation_passed": true, "time": 0.00202178955078125, "tests_passed": true, "error": null}
{"code": "if not os.path.isdir(dir_path):\n        raise ValueError('Directory in dir_path does not exist')\n    files_dict = {}\n    for f in glob.glob(os.path.join(dir_path, '**/*.txt'), recursive=True):\n        if os.path.isfile(f):\n            with open(f) as fd:\n                files_dict[f] = len(re.findall(r'\\berror\\b', fd.read(), re.IGNORECASE))\n    return files_dict", "compilation_passed": true, "time": 0.001837015151977539, "tests_passed": true, "error": null}
{"code": "try:\n        os.path.isdir(dir_path)\n        # get all text file paths in the directory\n        file_paths = glob.glob(os.path.join(dir_path, \"**/*.txt\"), recursive=True)\n    except FileNotFoundError:\n        print(f\"Error: {dir_path} is not a directory!\")\n        exit()\n\n    result = {}\n\n    for file_path in file_paths:\n        # get relative file path\n        relative_file_path = os.path.relpath(file_path, start=dir_path)\n\n        # load content of the text file as string\n        with open(file_path, \"r\") as file:\n            content = file.read()\n\n        # get number of occurrences of the word \"error\"\n        num_occurrences = len(re.findall(\"error\", content, re.IGNORECASE))\n\n        if num_occurrences > 0:\n            result[relative_file_path] = num_occurrences\n\n    return result", "compilation_passed": true, "time": 0.00467991828918457, "tests_passed": true, "error": null}
{"code": "if not os.path.isdir(dir_path):\n        raise ValueError(\"Directory does not exist\")\n\n    regex = re.compile(r\"error\", re.IGNORECASE)\n    text_file_paths = glob.glob(dir_path + '/*.txt')\n    relative_file_paths = [os.path.relpath(path, dir_path) for path in text_file_paths]\n    occurrences_counter = {}\n\n    for path in relative_file_paths:\n        with open(path, 'r') as f:\n            text = f.read()\n            match_count = len(regex.findall(text))\n            if match_count:\n                occurrences_counter[path] = match_count\n\n    return occurrences_counter", "compilation_passed": true, "time": 0.0019698143005371094, "tests_passed": true, "error": null}
{"code": "if not os.path.isdir(dir_path):\n        raise ValueError(f\"Error: {dir_path} is not a valid directory.\")\n\n    pattern = re.compile(r\"error\", re.IGNORECASE)\n    text_files = glob.glob(os.path.join(dir_path, \"**/*.txt\"), recursive=True)\n\n    occurrences = {}\n    for file_path in text_files:\n        with open(file_path, 'r') as file:\n            content = file.read()\n            match_count = len(pattern.findall(content))\n            if match_count:\n                rel_file_path = os.path.relpath(file_path, start=dir_path)\n                occurrences[rel_file_path] = match_count\n\n    return occurrences", "compilation_passed": true, "time": 0.004396915435791016, "tests_passed": true, "error": null}
{"code": "try:\n        file_list = glob.glob(os.path.join(dir_path, '**/*.txt'), recursive=True)\n    except FileNotFoundError:\n        raise ValueError(f\"Directory not found in dir_path: {dir_path}\")\n\n    words = ['Error', 'ERROR', 'err', 'Err', 'Er', 'e']\n\n    results = {}\n\n    for f_path in file_list:\n        with open(f_path, 'r', encoding=\"utf-8\") as f:\n            text = f.read()\n            for word in words:\n                count = len(re.findall(r'\\b%s\\b' % re.escape(word), text, re.IGNORECASE))\n                results[f_path] = count\n\n    return results", "compilation_passed": true, "time": 0.0023081302642822266, "tests_passed": true, "error": null}
{"code": "assert isinstance(dir_path, str), f'dir_path ({dir_path}) must be str'\n    assert os.path.exists(dir_path), f'Directory \"{dir_path}\" does not exist'\n    assert not os.path.isdir(dir_path), f'Directory \"{dir_path}\" is a directory'\n    assert dir_path[-1] == os.sep, f'dir_path ({dir_path}) must end with \"/\"'\n\n    text_files = glob.glob(dir_path + \"*.txt\")\n    assert text_files, 'There are no files with extension \".txt\" in \"{}\"'.format(dir_path)\n\n    result = {}\n    for fp in text_files:\n        with open(fp, \"r\") as f:\n            lines = f.read().splitlines()\n            count = sum([1 for line in lines if \"error\" in line.lower()])\n            result[os.path.relpath(fp, dir_path)] = count\n    return result", "compilation_passed": true, "time": 0.0017766952514648438, "tests_passed": true, "error": null}
{"code": "count = {}\n\n    if not os.path.isdir(dir_path):\n        raise ValueError(\"The directory %s does not exist.\" % dir_path)\n\n    for subdir in glob.glob(os.path.join(dir_path, \"**\", \"*.txt\"), recursive=True):\n        with open(subdir, 'r', encoding='utf-8') as file:\n            for line in file:\n                line = line.lower()\n                matches = re.findall(r'\\berror\\b', line)\n                for match in matches:\n                    if match not in count:\n                        count[match] = 1\n                    else:\n                        count[match] += 1\n\n    return count", "compilation_passed": true, "time": 0.0019741058349609375, "tests_passed": true, "error": null}
{"code": "assert os.path.exists(dir_path)\n\n    errors = []\n\n    # 1. Get list of all .txt files in the directory and its subdirectories.\n    files_txt = glob.glob(os.path.join(dir_path, \"*.txt\"))\n\n    # 2. Search each file for occurrences of the word \"error\".\n    for file_path_txt in files_txt:\n        with open(file_path_txt, 'r') as file:\n            for line in file:\n                matches = re.findall(r'error', line)\n                if matches:\n                    errors.append(file_path_txt)\n                    break\n\n    return {relative_path(file_path_txt): len(matches) for file_path_txt in errors}", "compilation_passed": true, "time": 0.0017821788787841797, "tests_passed": true, "error": null}
{"code": "if not os.path.isdir(dir_path):\n        raise ValueError(f\"{dir_path} is not a directory.\")\n\n    pattern = re.compile(r\"error\", re.IGNORECASE)\n\n    file_paths = glob.glob(os.path.join(dir_path, \"*.txt\"))\n    file_paths.extend(glob.glob(os.path.join(dir_path, \"**\", \"*.txt\")))\n\n    result = {}\n    for file_path in file_paths:\n        with open(file_path, encoding='utf-8') as file:\n            count = sum(\n                1 for line in file if pattern.search(line)\n            )\n            if count:\n                result[os.path.relpath(file_path, start=dir_path)] = count\n    return result", "compilation_passed": true, "time": 0.001912832260131836, "tests_passed": true, "error": null}
{"code": "if os.path.exists(dir_path):\n        file_paths = glob.glob(os.path.join(dir_path, '*.txt'))\n        occurrences = {}\n        for fp in file_paths:\n            with open(fp, 'r', encoding='utf-8') as f:\n                count = re.findall(r'\\berror\\b', f.read(), re.IGNORECASE)\n                occurrences[os.path.relpath(fp, dir_path)] = len(count)\n    else:\n        raise ValueError('Directory does not exist.')\n    return occurrences", "compilation_passed": true, "time": 0.00173187255859375, "tests_passed": true, "error": null}
{"code": "# TODO: Implement me\n    if not os.path.isdir(dir_path):\n        raise ValueError(f\"{dir_path} is not a valid directory!\")\n    pattern = re.compile(r\".*?\\.(txt|md)\")\n    paths = glob.glob(os.path.join(dir_path, \"*\"), recursive=True)\n    path_dict = {}\n    for path in paths:\n        if not pattern.match(path):\n            continue\n        with open(path, encoding=\"utf-8\") as f:\n            content = f.read()\n        count = len(re.findall(r\"error|error\\b\", content, re.I))\n        path_dict[os.path.relpath(path, dir_path)] = count\n    return path_dict", "compilation_passed": true, "time": 0.001953125, "tests_passed": true, "error": null}
{"code": "if not os.path.exists(dir_path):\n        raise ValueError(f\"Directory '{dir_path}' not found!\")\n\n    # Get all text files in directory\n    file_paths = glob.glob(f\"{dir_path}/**/*.txt\", recursive=True)\n\n    # Create a dictionary to store the number of occurrences of each word\n    word_counts = {}\n\n    # Loop through each text file path\n    for file_path in file_paths:\n        with open(file_path, 'r', encoding='utf-8') as file:\n            content = file.read()\n\n        # Extract all occurrences of 'error' case-insensitive\n        pattern = r\"error\"\n        matches = re.findall(pattern, content, re.IGNORECASE)\n\n        # Count number of occurrences\n        num_matches = len(matches)\n\n        # If file path not already in dictionary, add it with 1 occurrence\n        if file_path not in word_counts:\n            word_counts[file_path] = 1\n        # Otherwise, add 1", "compilation_passed": true, "time": 0.0019729137420654297, "tests_passed": true, "error": null}
{"code": "# Check if the directory exists\n    if not os.path.isdir(dir_path):\n        raise ValueError(f\"{dir_path} is not a directory or not accessible.\")\n\n    # Create a dictionary to store relative file paths and their occurrence counts\n    occurrences_dict = {}\n\n    # Get all text files within the directory and subdirectories\n    file_paths = glob.glob(os.path.join(dir_path, \"**/*.txt\"), recursive=True)\n\n    # Iterate over all text files\n    for file_path in file_paths:\n        # Open the file in read mode and read its content\n        with open(file_path, \"r\", encoding=\"utf-8\") as file:\n            content = file.read()\n\n        # Remove any lines that have more than one space or tab,\n        # which are typically used for formatting or comments\n        content = \" \".join(line.split() for line in content.splitlines())\n\n        # Create a pattern to match the word \"error\"\n        pattern = re.compile(r\"error\"", "compilation_passed": false, "time": 0.0001888275146484375, "tests_passed": false, "error": "SyntaxError"}
{"code": "if not os.path.isdir(dir_path):\n        raise ValueError(f\"Directory {dir_path} does not exist!\")\n\n    file_paths = glob.glob(os.path.join(dir_path, \"*.txt\"))\n    occurrences = {}\n\n    for file_path in file_paths:\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                for line in f:\n                    if \"error\" in line.lower():\n                        relative_file_path = os.path.relpath(file_path, dir_path)\n                        occurrences[relative_file_path] = occurrences.get(\n                            relative_file_path, 0) + 1\n        except UnicodeDecodeError as e:\n            print(\"Encountered an error when processing file:\", file_path, \"- skipping.\")\n            print(\"Error details:\", e)\n\n    return occurrences", "compilation_passed": true, "time": 0.001744985580444336, "tests_passed": true, "error": null}
{"code": "try:\n        # check if directory exists\n        if not os.path.exists(dir_path):\n            raise ValueError(\"The directory does not exist.\")\n        else:\n            # collect file paths and iterate over them\n            all_files = glob.glob(dir_path + \"/text*.txt\")\n            error_dict = {}\n\n            for file in all_files:\n                with open(file, \"r\") as f:\n                    text = f.read()\n                    if text.find(\"error\") != -1:\n                        relative_path = os.path.relpath(file, dir_path)\n                        error_dict[relative_path] = text.count(\"error\")\n            return error_dict\n    except Exception as e:\n        print(\"Exception found\", e)", "compilation_passed": true, "time": 0.0018177032470703125, "tests_passed": true, "error": null}
{"code": "result = dict()\n    regex_pattern = re.compile(r\"error\", re.IGNORECASE)\n\n    for subdir, dirs, files in os.walk(dir_path):\n        for file in glob.glob(os.path.join(subdir, \"*.txt\")):\n            with open(file, \"r\") as f:\n                content = f.read()\n                if regex_pattern.findall(content):\n                    relative_file_path = os.path.relpath(file, dir_path)\n                    result[relative_file_path] = sum(regex_pattern.findall(content))\n\n    return result", "compilation_passed": true, "time": 0.001995086669921875, "tests_passed": false, "error": "TypeError"}
{"code": "# Check that the directory exists.\n    if not os.path.exists(dir_path):\n        raise ValueError(\"Directory does not exist.\")\n\n    # Check that there is a text file extension in the file name.\n    file_names = glob.glob(os.path.join(dir_path, \"*.txt\"))\n    if len(file_names) == 0:\n        raise ValueError(\"There are no text files in this directory.\")\n\n    # Retrieve all text files in the directory\n    relative_file_paths = [\n        os.path.relpath(fname, start=os.path.abspath(dir_path))\n        for fname in file_names\n    ]\n\n    # Initialize regex pattern.\n    regex_pattern = re.compile(r\"error\", re.I)\n\n    # Initialize a dictionary for storing counts.\n    counts = {}\n\n    # Iterate over all file paths, counting occurrences of the regular expression pattern in each file.\n    for file_path in relative_file_paths:\n        with open(file_path, \"", "compilation_passed": false, "time": 0.00010800361633300781, "tests_passed": false, "error": "SyntaxError"}
{"code": "if not os.path.isdir(dir_path):\n        raise ValueError(\"Specified path is not a directory.\")\n\n    matches = {}\n\n    # Get all files that have the .txt extension\n    file_paths = glob.glob(os.path.join(dir_path, '*.txt'))\n\n    # Iterate through the files and match \"error\" case-insensitively\n    for file_path in file_paths:\n        with open(file_path, 'r') as f:\n            text = f.read()\n            matches[file_path] = len(re.findall('error', text, re.IGNORECASE))\n\n    return matches", "compilation_passed": true, "time": 0.0020208358764648438, "tests_passed": true, "error": null}
{"code": "if not os.path.isdir(dir_path):\n        raise ValueError(\"Directory path not found.\")\n\n    file_paths = glob.glob(os.path.join(dir_path, \"**/*.txt\"), recursive=True)\n    result = {}\n\n    for file_path in file_paths:\n        # Convert Windows path separators to Unix-style separators.\n        file_path = os.path.normpath(file_path)\n\n        if not os.path.exists(file_path):\n            continue\n\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as file:\n                content = file.read()\n        except UnicodeDecodeError:\n            continue\n\n        word_counts = {}\n\n        for word in [\"error\", \"Error\", \"ErRoR\"]:\n            pattern = fr\"\\b{word}\\b\"\n            matches = re.findall(pattern, content, re.IGNORECASE)\n            word_counts[word] = len(matches)\n\n        result[", "compilation_passed": false, "time": 0.0002448558807373047, "tests_passed": false, "error": "SyntaxError"}
{"code": "# check whether directory exists and raise ValueError if not\n    if not os.path.isdir(dir_path):\n        raise ValueError(f\"Directory {dir_path} does not exist.\")\n\n    # retrieve relative paths of all text files with the extension .txt\n    # and subdirectories recursively\n    file_paths = glob.glob(os.path.join(dir_path, '**', '*.txt'),\n                           recursive=True)\n\n    # use regular expression pattern to find occurrences of \"error\"\n    # in text files\n    occurrences = {}\n    for file_path in file_paths:\n        with open(file_path, 'r') as f:\n            file_text = f.read()\n            num_errors = len(re.findall('error', file_text, re.I))\n            if num_errors:\n                occurrences[os.path.relpath(file_path, dir_path)] = num_errors\n\n    return occurrences", "compilation_passed": true, "time": 0.004395723342895508, "tests_passed": true, "error": null}
{"code": "# Check if directory in dir_path exists\n    if not os.path.isdir(dir_path):\n        raise ValueError(f\"Directory {dir_path} not found.\")\n\n    # Get relative file paths in the directory and its subdirectories\n    file_paths = glob.glob(os.path.join(dir_path, \"*\", \"*.txt\"))\n\n    # Initialize dictionary to store file paths as keys and occurrences as values\n    result = {}\n\n    for file_path in file_paths:\n        # Get the relative path of the file in the directory\n        rel_file_path = os.path.relpath(file_path, dir_path)\n\n        # Count occurrences of \"error\" in the file\n        with open(file_path, 'r', encoding='utf8') as f:\n            occurrences = sum(line.count('error') for line in f)\n\n        # Add to the result dictionary\n        result[rel_file_path] = occurrences\n\n    return result", "compilation_passed": true, "time": 0.0018818378448486328, "tests_passed": true, "error": null}
{"code": "try:\n        file_paths = glob.glob(os.path.join(dir_path, '*.txt'))\n    except FileNotFoundError:\n        raise ValueError('The given directory does not exist.')\n\n    matches = []\n    for path in file_paths:\n        with open(path) as f:\n            content = f.read()\n            matches.extend(re.findall(r\"\\b(error|error\\b|error\\s)\\w*\", content))\n\n    relative_file_paths = [os.path.relpath(path, dir_path) for path in file_paths]\n\n    result = dict(zip(relative_file_paths, matches))\n    return result", "compilation_passed": true, "time": 0.0018398761749267578, "tests_passed": true, "error": null}
{"code": "file_paths = glob.glob(os.path.join(dir_path, \"**\", \"*.txt\"), recursive=True)\n    counter = {}\n\n    for file_path in file_paths:\n        try:\n            with open(file_path, \"r\", encoding=\"utf8\") as file:\n                text = file.read()\n                pattern = re.compile(r\"\\berror\\b\", re.I)\n                count = len(pattern.findall(text))\n                counter[os.path.relpath(file_path, start=dir_path)] = count\n        except UnicodeDecodeError:\n            # If an error occurs during decoding, skip the file and move\n            # to the next file\n            print(f\"Skipped: {file_path}\")\n        except FileNotFoundError:\n            # If an error occurs during file opening, skip the file and move\n            # to the next file\n            print(f\"Skipped: {file_path}\")\n        except PermissionError:\n            # If an error occurs during accessing the file, skip the file and", "compilation_passed": false, "time": 0.0002071857452392578, "tests_passed": false, "error": "IndentationError"}
{"code": "if os.path.isdir(dir_path):\n        file_paths = glob.glob(os.path.join(dir_path, \"**/*.txt\"), recursive=True)\n    else:\n        raise ValueError(\"Directory not found\")\n\n    matches_dict = {}\n\n    for file_path in file_paths:\n        if os.path.isfile(file_path) and file_path.endswith(\".txt\"):\n            try:\n                with open(file_path, 'r', encoding=\"utf-8\") as f:\n                    content = f.read()\n                    matches_count = len(re.findall(r\"error|err|er|er\", content, re.I))\n                    matches_dict[os.path.relpath(file_path, dir_path)] = matches_count\n            except UnicodeDecodeError:\n                print(\"Invalid file format or encoding. Skipping file...\")\n    return matches_dict", "compilation_passed": true, "time": 0.004586935043334961, "tests_passed": true, "error": null}
{"code": "# Make sure the provided path refers to a valid directory.\n    if not os.path.isdir(dir_path):\n        raise ValueError(f\"{dir_path} is not a directory.\")\n\n    # Find all text files in the directory and its subdirectories.\n    file_paths = [\n        f for f in glob.glob(f\"{dir_path}/**/*.txt\", recursive=True)\n        if os.path.isfile(f)\n    ]\n    # Use regex to find all occurrences of the word \"error\" in all text files.\n    words = re.findall(r\"error\", \" \".join(file_paths))\n\n    return {\n        os.path.relpath(f, dir_path): len(words)\n        for f in file_paths\n    }", "compilation_passed": true, "time": 0.0023870468139648438, "tests_passed": true, "error": null}
{"code": "if not os.path.isdir(dir_path):\n        raise ValueError(\"Directory not found.\")\n\n    # Get all relative file paths in the directory and subdirectories\n    file_paths = glob.glob(os.path.join(dir_path, \"**/*.txt\"), recursive=True)\n    # print(file_paths)\n\n    # Create an empty dictionary to store the count of occurrences\n    occurrence_counts = {}\n\n    # Iterate over the file paths\n    for file_path in file_paths:\n        # Open the file and read its contents\n        with open(file_path, 'r', encoding='utf-8') as file:\n            contents = file.read()\n\n        # Convert contents to lowercase\n        contents = contents.lower()\n        # print(contents)\n\n        # Perform pattern matching\n        pattern = re.compile(\"error\")\n        matches = pattern.findall(contents)\n\n        # Calculate the count of occurrences\n        num_matches = len(matches)\n\n        # Add the file path to the dictionary with the count\n        ", "compilation_passed": true, "time": 0.0019986629486083984, "tests_passed": true, "error": null}
