{"selected_lines": [43, 40, 57, 51, 42, 50, 58, 53, 46, 49, 55, 54, 45, 52, 44, 56, 59, 39, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filename).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 49, 53, 57, 54, 41, 52, 59, 39, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).exists():\n        raise FileNotFoundError(\"Source directory does not exist.\")\n    if not os.path.isdir(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}.{}\".format(filename, count, extension[1:])\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 44, 57, 48, 56, 40, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 57, 46, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + \"/**/*\" + extension, recursive=True)\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 55, 53, 48, 56, 57, 54, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 46, 53, 39, 55, 43, 40, 48, 42, 52, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, stem)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.007899045944213867, "tests_passed": true, "error": null}}
{"selected_lines": [57, 56, 54, 39, 42, 40, 59, 51, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 50, 53, 59, 51, 41, 43, 52, 48, 58, 45, 40, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"{source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in ('.txt', '.docx', '.xlsx', '.csv'):\n        filepaths = sorted(glob.glob(os.path.join(source_directory, f\"*{extension}\")))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 46, 43, 41, 58, 48, 56, 44, 51, 50, 45, 55, 57, 52, 54, 49, 40, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError('Source directory does not exist.')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 53, 51, 55, 58, 50, 44, 52, 42, 40, 48, 59, 39, 49, 46, 41, 45, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError('Source directory does not exist.')\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, stem)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 49, 46, 57, 51, 45, 55, 43, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, f\"**/*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, stem + extension)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 44, 40, 50, 43, 57, 54, 42, 49, 52, 46, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 46, 49, 52, 45, 53, 56, 44, 43, 50, 55, 54, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 52, 41, 59, 50, 43, 48, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filename).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028280019760131836, "tests_passed": true, "error": null}}
{"selected_lines": [43, 51, 59, 56, 42, 52, 44, 53, 40, 45, 49, 50, 55, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 44, 55, 46, 51, 43, 58, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ('.txt', '.docx', '.xlsx', '.csv'):\n        filepaths = glob.glob(\n            os.path.join(source_directory, '*.' + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 57, 55, 46, 51, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 46, 59, 40, 39, 55, 44, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 51, 53, 59, 56, 57, 55, 54, 49, 45, 50, 42, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}.{}\".format(filename, count, extension[1:])\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00024700164794921875, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [45, 39, 56, 42, 50, 41, 46, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source folder does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 50, 59, 58, 42, 39, 44, 49, 56, 57, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, stem)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.008047103881835938, "tests_passed": true, "error": null}}
{"selected_lines": [46, 44, 52, 43, 48, 59, 49, 51, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, \"**\", f\"*{extension}\"), recursive=True)\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 58, 49, 48, 50, 52, 39, 56, 53, 41, 40, 59, 57, 42, 54, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError('Source directory does not exist.')\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 51, 52, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 52, 59, 39, 51, 40, 41, 54, 48, 42, 43, 45, 57, 50, 53, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.iglob(os.path.join(source_directory, \"*\" + extension), recursive=True)\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 54, 50, 44, 40, 53, 46, 45, 58, 42, 43, 56, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True)\n            os.path.join(source_directory, '*' + extension), recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 53, 55, 58, 57, 59, 51, 52, 44, 49, 46, 56, 39, 54, 43, 41, 50, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + '/**/*' + extension, recursive=True)\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 40, 57, 46, 48, 43, 55, 51, 58, 44, 49, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 53, 55, 58, 48, 41, 54, 44, 40, 59, 49, 50, 52, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 57, 46, 54, 59, 50, 52, 41, 43, 44, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 58, 44, 41, 57, 59, 45, 43, 52, 51, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source folder does not exist\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + \"/**/*\" + extension, recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.027267932891845703, "tests_passed": true, "error": null}}
{"selected_lines": [42, 39, 54, 59, 40, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 58, 50, 55, 57, 52, 48, 43, 54, 45, 41, 39, 44, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 42, 51, 44, 57, 46, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, stem)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 46, 42, 57, 52, 43, 53, 55, 50, 56, 58, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source folder '{source_directory}' does not exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.008828878402709961, "tests_passed": true, "error": null}}
{"selected_lines": [59, 56, 46, 58, 45, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True)\n            os.path.join(source_directory, '*.' + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source folder does not exist\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028858184814453125, "tests_passed": true, "error": null}}
{"selected_lines": [56, 44, 46, 55, 50, 51, 59, 52, 39, 42, 57, 43, 40, 49, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 59, 57, 55, 44, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 46, 50, 55, 52, 53, 56, 49, 44, 48, 45, 57, 41, 58, 51, 59, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True))\n            os.path.join(source_directory, '*.' + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.018864870071411133, "tests_passed": true, "error": null}}
{"selected_lines": [52, 56, 46, 42, 51, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"**/*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 40, 57, 58, 45, 54, 50, 46, 55, 53, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.020402908325195312, "tests_passed": true, "error": null}}
{"selected_lines": [44, 56, 55, 49, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011987924575805664, "tests_passed": true, "error": null}}
{"selected_lines": [50, 46, 41, 58, 52, 54, 56, 53, 44, 39, 40, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.007361888885498047, "tests_passed": true, "error": null}}
{"selected_lines": [40, 53, 51, 44, 46, 48, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 39, 53, 49, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, '*.' + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0036351680755615234, "tests_passed": true, "error": null}}
{"selected_lines": [49, 46, 48, 54, 42, 59, 55, 50, 44, 39, 52, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}\".format(stem, count)\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.02999711036682129, "tests_passed": true, "error": null}}
{"selected_lines": [56, 50, 48, 55, 39, 57, 44, 40, 41, 58, 49, 45, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.iglob(os.path.join(source_directory, \"*\" + extension), recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 48, 54, 57, 45, 52, 53, 59, 51, 43, 40, 55, 46, 49, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 50, 52, 44, 41, 54, 53, 56, 51, 59, 45, 58, 55, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source folder does not exist\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(source_directory + os.sep + \"**/*\" + extension, recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 57, 50, 43, 45, 51, 44, 49, 58, 54, 48, 41, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True))\n            os.path.join(source_directory, f\"*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 41, 58, 45, 52, 55, 53, 40, 48, 46, 42, 49, 57, 56, 51, 39, 44, 54, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + \"/**/*\" + extension, recursive=True)\n            os.path.join(source_directory, \"**/*.\" + extension, recursive=True)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 59, 45, 44, 43, 58, 54, 57, 49, 55, 51, 56, 50, 39, 46, 42, 40, 48, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"**/*.\" + extension, recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filename).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 51, 46, 56, 59, 44, 57, 52, 40, 43, 48, 55, 42, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.03177213668823242, "tests_passed": true, "error": null}}
{"selected_lines": [41, 57, 55, 51, 39, 59, 44, 48, 49, 43, 46, 58, 40, 56, 42, 54, 53, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**/*.\" + extension, recursive=True)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 52, 55, 39, 53, 41, 51, 49, 54, 58, 50, 59, 40, 42, 44, 48, 57, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 53, 48, 49, 45, 55, 40, 42, 51, 59, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).is_dir():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**\", f\"*{extension}\"), recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 45, 46, 58, 51, 41, 48, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True))\n            os.path.join(source_directory, \"**/*.\" + extension, recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 51, 54, 57, 41, 42, 43, 59, 53, 40, 49, 45, 39, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**\", f\"*{extension}\"), recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028100967407226562, "tests_passed": true, "error": null}}
{"selected_lines": [46, 57, 55, 54, 43, 52, 42, 53, 48, 44, 58, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**/*.\" + extension, recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 56, 45, 49, 44, 53, 59, 39, 42, 43, 40, 41, 46, 52, 57, 54, 58, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\n    if not os.path.isdir(source_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 46, 53, 59, 41, 49, 40, 55, 54, 51, 39, 57, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True))\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.splitext(filepath)[0].split(\"/\")[-1]\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 55, 49, 59, 44, 57, 56, 46, 45, 53, 54, 50, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source folder {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, '*' + extension), recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 40, 41, 49, 53, 46, 50, 39, 42, 51, 56, 54, 48, 45, 58, 43, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source directory '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"*{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 40, 48, 54, 51, 55, 49, 41, 58, 53, 44, 57, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source folder {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, stem + extension)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 54, 42, 48, 50, 57, 51, 49, 45, 46, 53, 55, 56, 41, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'The source directory {source_directory} does not exist')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filename).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028155088424682617, "tests_passed": true, "error": null}}
{"selected_lines": [52, 57, 41, 55, 48, 42, 49, 40, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 45, 53, 52, 40, 46, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + '/**/*' + extension, recursive=True)\n            os.path.join(source_directory, f\"**/*{extension}\"),\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 53, 46, 41, 58, 45, 56, 52, 54, 55, 59, 40, 48, 39, 42, 57, 44, 51, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True))\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011224031448364258, "tests_passed": true, "error": null}}
{"selected_lines": [54, 45, 58, 46, 51, 55, 53, 49, 57, 56, 41, 40, 50, 52, 39, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.iglob(os.path.join(source_directory, \"*\" + extension), recursive=True)\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 55, 51, 41, 57, 45, 42, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'source directory {source_directory} not found')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 52, 39, 43, 40, 48, 49, 59, 45, 44, 54, 57, 51, 42, 50, 53, 41, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\n    if not os.path.isdir(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.iglob(os.path.join(source_directory, \"*\" + extension), recursive=True)\n            os.path.join(source_directory, f\"**/*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(os.path.join(source_directory, f\"*{extension}\")))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00024509429931640625, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [45, 40, 42, 59, 43, 56, 51, 58, 44, 48, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory, exist_ok=True)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 39, 59, 45, 50, 43, 57, 58, 53, 49, 44, 56, 55, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source folder does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 44, 48, 59, 42, 49, 54, 39, 46, 43, 45, 53, 51, 56, 50, 41, 58, 57, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"File not found: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.02888178825378418, "tests_passed": true, "error": null}}
{"selected_lines": [42, 59, 41, 58, 54, 40, 55, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.013362884521484375, "tests_passed": true, "error": null}}
{"selected_lines": [55, 40, 46, 57, 58, 59, 48, 39, 44, 49, 42, 43, 53, 54, 56, 50, 41, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 50, 49, 54, 45, 59, 41, 53, 39, 40, 51, 44, 58, 56, 55, 43, 57, 48, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [51, 46, 42, 58, 59, 50, 48, 56, 54, 40, 53, 52, 43, 39, 49, 45, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + '/**/*' + extension, recursive=True)\n            os.path.join(source_directory, '*.' + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, stem + extension)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 45, 52, 42, 56, 40, 59, 39, 54, 49, 53, 48, 58, 41, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"Source folder does not exist\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 49, 48, 57, 42, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'source directory {source_directory} not found')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011666059494018555, "tests_passed": true, "error": null}}
{"selected_lines": [54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.02888202667236328, "tests_passed": true, "error": null}}
{"selected_lines": [53, 52, 51, 59, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [59, 51, 44, 41, 42, 48, 46, 45, 50, 54, 49, 56, 39, 43, 58, 53, 57, 40, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []  # to count files\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filename).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.027434110641479492, "tests_passed": true, "error": null}}
{"selected_lines": [39, 44, 40, 50, 55, 48, 58, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.013910055160522461, "tests_passed": true, "error": null}}
{"selected_lines": [54, 44, 41, 49, 59, 42, 58, 56, 48, 51, 55, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 49, 58, 50, 46, 51, 44, 48, 56, 45, 40, 39, 53, 52, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 48, 40, 52, 55, 59, 51, 41, 54, 44, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 40, 52, 57, 53, 56, 51, 42, 59, 43, 55, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [57, 58, 46, 40, 42, 43, 39, 54, 48, 52, 56, 49, 55, 41, 53, 44, 45, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.isdir(source_directory):\n        os.mkdir(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True))\n            os.path.join(source_directory, \"**\", \"*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.03177213668823242, "tests_passed": true, "error": null}}
{"selected_lines": [49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.027267932891845703, "tests_passed": true, "error": null}}
{"selected_lines": [50, 56, 44, 41, 39, 55, 51, 40, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source folder does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011806964874267578, "tests_passed": true, "error": null}}
{"selected_lines": [51, 54, 55, 45, 40, 42, 39, 44, 52, 53, 48, 49, 58, 41, 43, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory does not exist: {source_directory}\")\n    if not os.path.isdir(source_directory):\n        os.mkdir(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.iglob(os.path.join(source_directory, \"*\" + extension), recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, stem)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 48, 50, 49, 59, 41, 45, 43, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**\", f\"*{extension}\"), recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 52, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}.{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [52, 58, 50, 44, 45, 41, 53, 59, 49, 51, 48, 57, 40, 56, 39, 54, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}\".format(stem, count)\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 56, 43, 54, 57, 58, 50, 41, 48, 45, 55, 40, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).is_dir():\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.iglob(os.path.join(source_directory, \"*\" + extension), recursive=True)\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.02722620964050293, "tests_passed": true, "error": null}}
{"selected_lines": [45, 58, 48, 40, 56, 55, 53, 57, 54, 52, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 52, 45, 41, 44, 40, 46, 50, 59, 56, 43, 57, 58, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f'source directory {source_directory} not found')\n    if not os.path.isdir(source_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 50, 52, 46, 51, 43, 41, 48, 40, 39, 49, 56, 55, 59, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f'*.{extension.lstrip(\".\")}')\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filename).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 50, 39, 52, 54, 46, 40, 51, 57, 55, 56, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 53, 40, 59, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.splitext(filepath)[0].split(\"/\")[-1]\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 56, 46, 53, 41, 52, 50, 59, 39, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source folder {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0062580108642578125, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, stem + extension)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.029744863510131836, "tests_passed": true, "error": null}}
{"selected_lines": [54, 45, 41, 55, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 46, 41, 48, 44, 57, 50, 53, 49, 59, 51, 56, 39, 58, 52, 55, 40, 54, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []  # to count files\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 48, 55, 59, 45, 40, 46, 42, 41, 56, 39, 51, 57, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"Source folder does not exist\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True))\n            os.path.join(source_directory, f\"**/*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 53, 55, 51, 58, 45, 48, 54, 44, 46, 40, 56, 39, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(source_directory + \"/**/*\" + extension, recursive=True)\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 54, 52, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 59, 39, 57, 53, 50, 56, 43, 41, 54, 42, 58, 52, 40, 49, 44, 46, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source folder {source_directory} not found.\")\n    if not os.path.isdir(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True)\n            os.path.join(source_directory, f\"*{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 41, 58, 50, 53, 51, 43, 49, 40, 56, 39, 52, 48, 46, 59, 42, 57, 45, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, \"**/*\" + extension), recursive=True)\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}.{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 41, 56, 40, 39, 53, 54, 58, 59, 49, 42, 43, 51, 46, 44, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = glob.glob(\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 49, 51, 57, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [39, 40, 43, 41, 48, 56, 44, 45, 46, 59, 55, 58, 50, 42, 53, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"File {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"*{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 49, 45, 55, 39, 54, 57, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}.{}\".format(filename, count, extension[1:])\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 45, 46, 40, 49, 50, 58, 51, 52, 41, 43, 55, 39, 56, 53, 54, 59, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source folder {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**\", f\"*{extension}\"), recursive=True)\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 44, 56, 55, 48, 43, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.014801025390625, "tests_passed": true, "error": null}}
{"selected_lines": [45, 40, 56, 46, 53, 39, 54, 50, 44, 42, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True))\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filename).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [45, 56, 41, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, stem)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.03135108947753906, "tests_passed": true, "error": null}}
{"selected_lines": [54, 49, 46, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}.{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.002975940704345703, "tests_passed": true, "error": null}}
{"selected_lines": [42, 58, 54, 57, 50, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.006390810012817383, "tests_passed": true, "error": null}}
{"selected_lines": [53, 55, 54, 39, 42, 57, 58, 45, 43, 50, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 57, 49, 43, 46, 54, 50, 45, 44, 52, 51, 58, 53, 42, 39, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011559009552001953, "tests_passed": false, "error": "FileNotFoundError"}}
{"selected_lines": [43, 49, 56, 50, 52, 59, 46, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.splitext(filepath)[0].split(\"/\")[-1]\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.006376981735229492, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [43, 44, 57, 39, 54, 53, 46, 41, 45, 48, 58, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source folder does not exist\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"**/*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 39, 52, 54, 56, 57, 46, 50, 49, 53, 55, 44, 58, 40, 41, 43, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"File {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filename).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.006965160369873047, "tests_passed": true, "error": null}}
{"selected_lines": [54, 41, 50, 48, 39, 55, 57, 42, 56, 43, 46, 40, 49, 44, 45, 58, 52, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"File not found: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f'*.{extension.lstrip(\".\")}')\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 54, 48, 45, 52, 41, 59, 46, 58, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 41, 56, 40, 39, 51, 42, 49, 46, 48, 55, 52, 44, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'The source directory {source_directory} does not exist')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028580904006958008, "tests_passed": true, "error": null}}
{"selected_lines": [43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.02999711036682129, "tests_passed": true, "error": null}}
{"selected_lines": [49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.031906843185424805, "tests_passed": true, "error": null}}
{"selected_lines": [54, 40, 42, 51, 55, 56, 53, 58, 48, 49, 52, 41, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 45, 49, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + os.sep + \"**/*\" + extension, recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 40, 44, 55, 42, 46, 48, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source folder '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, '*' + extension), recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.03228902816772461, "tests_passed": true, "error": null}}
{"selected_lines": [49, 54, 59, 52, 41, 42, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.013028144836425781, "tests_passed": true, "error": null}}
{"selected_lines": [39, 43, 59, 50, 49, 44, 54, 56, 55, 41, 57, 45, 40, 53, 52, 46, 58, 48, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source folder does not exist\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = [\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 52, 50, 55, 39, 43, 57, 45, 41, 54, 48, 46, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + os.sep + \"**/*\" + extension, recursive=True)\n            os.path.join(source_directory, f\"*{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filename).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 57, 39, 50, 46, 44, 55, 40, 42, 58, 59, 53, 45, 41, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True)\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 52, 46, 51, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 45, 55, 42, 54, 48, 59, 53, 52, 44, 43, 58, 51, 57, 46, 39, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 56, 48, 41, 45, 54, 52, 46, 40, 43, 51, 58, 39, 53, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, '*' + extension), recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, stem)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00025391578674316406, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [55, 39, 43, 41, 44, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.01174020767211914, "tests_passed": true, "error": null}}
{"selected_lines": [45, 43, 57, 54, 41, 39, 44, 58, 55, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'source directory {source_directory} not found')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ('.txt', '.docx', '.xlsx', '.csv'):\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 59, 50, 55, 44, 46, 41, 51, 39, 52, 54, 58, 43, 42, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**\", f\"*{extension}\"), recursive=True)\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 55, 41, 53, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 55, 45, 52, 51, 57, 53, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 56, 49, 58, 40, 41, 52, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.splitext(filepath)[0].split(\"/\")[-1]\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}\".format(stem, count)\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.013870000839233398, "tests_passed": true, "error": null}}
{"selected_lines": [40, 54, 51, 59, 49, 43, 44, 57, 46, 41, 42, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source folder does not exist\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 54, 55, 40, 53, 58, 42, 43, 39, 52, 56, 49, 59, 50, 44, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.00321197509765625, "tests_passed": true, "error": null}}
{"selected_lines": [51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, stem + extension)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.029744863510131836, "tests_passed": true, "error": null}}
{"selected_lines": [44, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00022101402282714844, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00028586387634277344, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [59, 48, 41, 43, 42, 56, 49, 39, 55, 53, 40, 57, 58, 44, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'The source directory {source_directory} does not exist')\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.006574869155883789, "tests_passed": true, "error": null}}
{"selected_lines": [43, 50, 56, 48, 39, 46, 45, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 46, 58, 56, 51, 43, 52, 49, 53, 50, 45, 54, 41, 39, 40, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(os.path.join(source_directory, f\"*{extension}\")))\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.031906843185424805, "tests_passed": true, "error": null}}
{"selected_lines": [44, 41, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011886119842529297, "tests_passed": true, "error": null}}
{"selected_lines": [51, 44, 43, 48, 55, 41, 45, 58, 52, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source folder {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 41, 55, 56, 45, 49, 39, 57, 50, 43, 51, 44, 52, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 56, 54, 57, 46, 39, 40, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.0002269744873046875, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [40, 43, 55, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 54, 40, 56, 57, 53, 48, 41, 58, 43, 59, 46, 45, 49, 55, 44, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}.{}\".format(filename, count, extension[1:])\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 55, 48, 42, 58, 41, 51, 56, 46, 54, 49, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filename).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 57, 51, 39, 50, 55, 49, 46, 53, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True)\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 43, 59, 41, 51, 49, 52, 53, 39, 42, 57, 45, 56, 48, 44, 50, 40, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 49, 43, 44, 46, 39, 42, 41, 45, 56, 58, 59, 54, 40, 57, 55, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, stem + extension)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.02888178825378418, "tests_passed": true, "error": null}}
{"selected_lines": [42, 57, 40, 43, 39, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError('Source directory does not exist.')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.029612064361572266, "tests_passed": true, "error": null}}
{"selected_lines": [58, 49, 46, 53, 52, 50, 48, 45, 43, 56, 51, 42, 41, 54, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}\".format(stem, count)\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 55, 42, 54, 46, 52, 45, 44, 41, 43, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**\", f\"*{extension}\"), recursive=True)\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filename).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source folder '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.02714395523071289, "tests_passed": true, "error": null}}
{"selected_lines": [39, 48, 49, 53, 44, 52, 56, 46, 43, 59, 51, 50, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 52, 41, 54, 56, 49, 48, 44, 42, 51, 58, 55, 46, 40, 45, 57, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [40, 59, 44, 55, 49, 46, 56, 43, 50, 58, 51, 42, 54, 41, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 46, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True))\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 52, 46, 56, 50, 55, 53, 48, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0030601024627685547, "tests_passed": true, "error": null}}
{"selected_lines": [42, 56, 45, 39, 52, 59, 50, 46, 53, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 57, 48, 54, 44, 50, 45, 41, 40, 51, 59, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 46, 50, 39, 55, 58, 59, 49, 52, 44, 56, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [59, 56, 44, 46, 40, 52, 42, 53, 50, 43, 55, 49, 58, 48, 41, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filename).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 44, 46, 57, 41, 49, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 41, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.013914108276367188, "tests_passed": true, "error": null}}
{"selected_lines": [53, 55, 56, 45, 54, 49, 43, 50, 59, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 57, 48, 42, 39, 59, 45, 53, 52, 55, 44, 54, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 46, 52, 51, 49, 39, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 51, 53, 46, 58, 57, 45, 44, 41, 52, 49, 55, 43, 59, 42, 48, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source folder {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 43, 58, 55, 42, 49, 44, 56, 40, 39, 53, 41, 51, 50, 59, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'The source directory {source_directory} does not exist')\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011837244033813477, "tests_passed": true, "error": null}}
{"selected_lines": [48, 51, 41, 40, 39, 56, 49, 59, 42, 57, 50, 44, 54, 45, 55, 53, 46, 52, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f'The source directory {source_directory} does not exist')\n    if not os.path.isdir(source_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, stem + extension)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 49, 57, 58, 54, 39, 46, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**/*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0012989044189453125, "tests_passed": true, "error": null}}
{"selected_lines": [40, 55, 58, 51, 46, 52, 49, 48, 50, 53, 44, 54, 42, 41, 43, 59, 57, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 48, 44, 51, 43, 46, 54, 40, 55, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 54, 43, 45, 50, 59, 40, 42, 57, 52, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filename).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 43, 42, 39, 51, 53, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [48, 54, 41, 44, 51, 53, 52, 40, 43, 58, 42, 55, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'The source directory {source_directory} does not exist')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 59, 53, 51, 55, 44, 46, 42, 40, 50, 41, 56, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 54, 42, 43, 40, 45, 57, 56, 58, 51, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}.{}\".format(filename, count, extension[1:])\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 55, 43, 49, 58, 46, 44, 59, 40, 51, 56, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).is_dir():\n        raise FileNotFoundError(f'source directory {source_directory} not found')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 53, 56, 42, 57, 46, 52, 45, 58, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory does not exist: {source_directory}\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**\", f\"*{extension}\"), recursive=True)\n            os.path.join(source_directory, f\"*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 56, 41, 44, 40, 46, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 59, 40, 51, 46, 50, 56, 49, 45, 44, 43, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, stem + extension)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 59, 41, 43, 50, 39, 44, 42, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 46, 53, 51, 57, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 55, 58, 57, 51, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 42, 53, 40, 48, 51, 49, 58, 43, 41, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"The source folder does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 46, 57, 39, 52, 55, 41, 40, 43, 56, 51, 53, 58, 49, 45, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**\", f\"*{extension}\"), recursive=True)\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.03149294853210449, "tests_passed": true, "error": null}}
{"selected_lines": [54, 43, 57, 42, 39, 45, 58, 49, 48, 44, 46, 52, 53, 55, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []  # to count files\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 43, 50, 39, 46, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"**/*{extension}\"),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 41, 59, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.012472867965698242, "tests_passed": true, "error": null}}
{"selected_lines": [58, 45, 57, 46, 50, 49, 44, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 39, 59, 57, 43, 53, 48, 42, 41, 50, 49, 40, 51, 46, 44, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []  # to count files\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**\", f\"*{extension}\"), recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.0002448558807373047, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [52, 57, 54, 44, 56, 55, 46, 42, 43, 58, 51, 59, 41, 53, 40, 39, 48, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 41, 39, 45, 48, 46, 49, 40, 52, 42, 58, 51, 57, 50, 56, 55, 43, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 49, 58, 45, 43, 56, 46, 41, 44, 52, 53, 39, 51, 48, 50, 40, 59, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**/*.\" + extension, recursive=True)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 51, 59, 49, 58, 43, 45, 44, 50, 53, 55, 48, 57, 39, 46, 52, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 40, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 52, 40, 49, 48, 46, 55, 53, 42, 44, 57, 59, 54, 56, 58, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 42, 52, 59, 50, 40, 58, 57, 48, 54, 45, 41, 55, 53, 49, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"Source folder does not exist\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028100967407226562, "tests_passed": true, "error": null}}
{"selected_lines": [51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00028586387634277344, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [55, 52, 45, 59, 42, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011224031448364258, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [48, 59, 46, 49, 58, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.007009029388427734, "tests_passed": true, "error": null}}
{"selected_lines": [52, 50, 53, 59, 51, 44, 45, 39, 49, 55, 48, 41, 43, 40, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filename).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [50, 40, 54, 51, 46, 43, 48, 42, 53, 39, 55, 41, 45, 44, 52, 57, 59, 49, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(f\"Source directory '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 48, 59, 51, 39, 55, 44, 50, 45, 46, 53, 42, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.splitext(filepath)[0].split(\"/\")[-1]\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 49, 55, 46, 43, 52, 53, 41, 39, 48, 59, 42, 51, 45, 50, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError('Source directory does not exist.')\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, \"**\", f\"*{extension}\"), recursive=True)\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 50, 40, 45, 52, 54, 44, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(f\"Source directory '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [42, 44, 53, 58, 56, 55, 51, 43, 45, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 55, 58, 46, 52, 49, 50, 56, 41, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'source directory {source_directory} not found')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, '*' + extension), recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 52, 55, 46, 50, 57, 56, 42, 59, 41, 53, 39, 43, 49, 45, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'source directory {source_directory} not found')\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + \"/**/*\" + extension, recursive=True)\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 58, 57, 50, 46, 51, 40, 52, 56, 45, 55, 48, 59, 53, 43, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, \"**/*\" + extension), recursive=True)\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 40, 57, 55, 56, 45, 43, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 59, 41, 39, 56, 42, 43, 50, 54, 40, 57, 55, 51, 46, 58, 49, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**/*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = os.path.splitext(filepath)[0].split(\"/\")[-1]\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, stem)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 49, 53, 40, 50, 54, 42, 46, 43, 59, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, '*' + extension), recursive=True)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.000244140625, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [41, 45, 51, 52, 50, 53, 58, 49, 42, 48, 43, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 53, 57, 52, 51, 45, 59, 49, 48, 58, 42, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + os.sep + \"**/*\" + extension, recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"File not found: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011828899383544922, "tests_passed": true, "error": null}}
{"selected_lines": [57, 53, 58, 48, 42, 45, 55, 50, 44, 43, 52, 46, 49, 59, 56, 41, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'The source directory {source_directory} does not exist')\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 39, 59, 45, 51, 48, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = [\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 49, 44, 53, 40, 52, 51, 41, 45, 59, 43, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"File not found: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 53, 43, 40, 58, 54, 56, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 59, 45, 52, 43, 42, 58, 40, 57, 46, 44, 50, 49, 53, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 59, 51, 57, 45, 52, 44, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.iglob(os.path.join(source_directory, \"*\" + extension), recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 53, 54, 51, 52, 49, 46, 57, 43, 58, 44, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 42, 59, 43, 45, 40, 39, 58, 52, 46, 57, 56, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + os.sep + \"**/*\" + extension, recursive=True)\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 55, 54, 58, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 56, 49, 44, 59, 42, 46, 50, 41, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 56, 58, 45, 40, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 40, 45, 46, 43, 49, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).is_dir():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 53, 39, 40, 44, 42, 59, 54, 56, 57, 49, 55, 41, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.006448984146118164, "tests_passed": true, "error": null}}
{"selected_lines": [40, 41, 55, 59, 53, 50, 45, 39, 48, 49, 58, 52, 44, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(os.path.join(source_directory, f\"*{extension}\")))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filename).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**/*\" + extension), recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00023293495178222656, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [45, 51, 43, 53, 46, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True))\n            os.path.join(source_directory, f'*.{extension.lstrip(\".\")}')\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00024700164794921875, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [57, 51, 49, 45, 46, 50, 52, 48, 42, 59, 41, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**/*\" + extension), recursive=True)\n            os.path.join(source_directory, '*.' + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.009660959243774414, "tests_passed": false, "error": "FileNotFoundError"}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**/*\" + extension), recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00023293495178222656, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [58, 44, 50, 52, 49, 56, 41, 54, 51, 40, 59, 48, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(source_directory + '/**/*' + extension, recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 42, 59, 45, 46, 53, 54, 55, 58, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True))\n            os.path.join(source_directory, f\"*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 49, 46, 52, 41, 45, 39, 44, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'source directory {source_directory} not found')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True))\n            os.path.join(source_directory, \"**/*.\" + extension, recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.027263164520263672, "tests_passed": true, "error": null}}
{"selected_lines": [58, 56, 51, 54, 43, 59, 46, 50, 42, 57, 53, 40, 48, 45, 49, 55, 39, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []  # to count files\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 44, 50, 55, 56, 53, 45, 59, 54, 48, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 49, 45, 58, 56, 54, 52, 39, 46, 40, 43, 51, 57, 42, 53, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 43, 51, 42, 52, 48, 40, 39, 50, 45, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(os.path.join(source_directory, f\"*{extension}\")))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 50, 45, 39, 42, 56, 57, 46, 58, 52, 48, 43, 55, 41, 49, 51, 44, 40, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 45, 51, 55, 57, 41, 42, 44, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.isdir(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 59, 46, 42, 41, 57, 40, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.002899169921875, "tests_passed": true, "error": null}}
{"selected_lines": [42, 41, 51, 50, 46, 49, 57, 58, 55, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError('Source directory does not exist.')\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 46, 44, 56, 59, 57, 39, 55, 43, 42, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError('Source directory does not exist.')\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, '*.' + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 43, 40, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}.{}\".format(filename, count, extension[1:])\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.013985157012939453, "tests_passed": true, "error": null}}
{"selected_lines": [44, 53, 54, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011812686920166016, "tests_passed": true, "error": null}}
{"selected_lines": [44, 46, 55, 43, 56, 51, 58, 48, 53, 50, 59, 52, 39, 49, 42, 41, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory, exist_ok=True)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 40, 49, 57, 50, 39, 59, 41, 52, 45, 55, 54, 58, 46, 51, 56, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filename).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 39, 48, 56, 55, 49, 46, 54, 41, 44, 57, 52, 42, 59, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 42, 55, 45, 41, 57, 39, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"File not found: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, f\"**/*{extension}\"),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 45, 51, 40, 52, 43, 41, 55, 39, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 59, 48, 39, 43, 46, 50, 56, 54, 45, 53, 44, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 52, 42, 43, 46, 48, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [58, 40, 52, 53, 43, 54, 48, 59, 44, 50, 45, 56, 55, 41, 42, 46, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filename).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 41, 44, 51, 40, 39, 48, 56, 57, 45, 42, 55, 49, 58, 59, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True))\n            os.path.join(source_directory, \"**\", \"*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}.{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.02999711036682129, "tests_passed": true, "error": null}}
{"selected_lines": [43, 40, 51, 56, 42, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 41, 44, 40, 49, 56, 55, 46, 42, 50, 57, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(f'The source directory {source_directory} does not exist')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 42, 55, 54, 45, 57, 43, 41, 59, 51, 44, 48, 39, 50, 52, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.0001971721649169922, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [44, 56, 59, 40, 51, 49, 53, 57, 43, 42, 55, 48, 41, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f'source directory {source_directory} not found')\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, stem + extension)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 51, 43, 56, 59, 46, 48, 52, 39, 41, 44, 57, 55, 50, 58, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'source directory {source_directory} not found')\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 45, 41, 42, 39, 58, 49, 53, 54, 55, 44, 56, 52, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"File {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.019958972930908203, "tests_passed": true, "error": null}}
{"selected_lines": [51, 59, 57, 52, 43, 50, 44, 55, 49, 56, 48, 41, 40, 58, 42, 46, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 45, 40, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).is_dir():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = [\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [44, 50, 42, 55, 45, 58, 39, 49, 51, 57, 52, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 54, 49, 51, 43, 45, 55, 41, 57, 59, 53, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source folder does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = [\n            os.path.join(source_directory, \"**\", \"*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 51, 45, 54, 58, 46, 48, 41, 59, 52, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 49, 50, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.012953996658325195, "tests_passed": true, "error": null}}
{"selected_lines": [46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**/*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0114898681640625, "tests_passed": true, "error": null}}
{"selected_lines": [58, 55, 50, 52, 46, 53, 45, 39, 43, 44, 56, 51, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 51, 41, 42, 52, 43, 45, 44, 57, 39, 49, 50, 56, 55, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 52, 59, 43, 51, 46, 44, 48, 40, 57, 58, 45, 41, 55, 53, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f'source directory {source_directory} not found')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory, exist_ok=True)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 50, 48, 45, 40, 56, 43, 57, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, \"**/*\" + extension), recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [56, 54, 51, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}.{}\".format(filename, count, extension[1:])\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 53, 39, 50, 51, 40, 58, 41, 57, 43, 44, 59, 46, 56, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"**/*{extension}\"),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 52, 44, 54, 45, 55, 48, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(source_directory + \"/**/*\" + extension, recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 41, 56, 40, 58, 48, 57, 51, 43, 46, 54, 45, 39, 59, 53, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"The source folder does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, stem + extension)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 43, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.iglob(os.path.join(source_directory, \"*\" + extension), recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 45, 46, 52, 57, 56, 54, 43, 44, 55, 51, 50, 41, 49, 40, 39, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}.{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 50, 45, 58, 43, 54, 55, 39, 44, 40, 46, 48, 53, 56, 49, 42, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, \"**\", f\"*{extension}\"), recursive=True)\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.02685093879699707, "tests_passed": true, "error": null}}
{"selected_lines": [51, 59, 45, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 51, 39, 59, 53, 42, 41, 54, 52, 58, 57, 48, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 55, 40, 50, 57, 48, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.012058019638061523, "tests_passed": true, "error": null}}
{"selected_lines": [56, 51, 58, 44, 39, 53, 52, 46, 57, 54, 45, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError('Source directory does not exist.')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 49, 43, 51, 42, 52, 53, 48, 41, 58, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0117340087890625, "tests_passed": true, "error": null}}
{"selected_lines": [51, 41, 52, 49, 50, 46, 54, 58, 57, 53, 55, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}.{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 46, 49, 41, 59, 51, 39, 53, 45, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + \"/**/*\" + extension, recursive=True)\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.019958972930908203, "tests_passed": true, "error": null}}
{"selected_lines": [48, 40, 44, 49, 45, 59, 56, 52, 50, 51, 53, 43, 57, 54, 42, 46, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).is_dir():\n        raise FileNotFoundError(f\"File {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(source_directory, f\"*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00023508071899414062, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [49, 52, 53, 51, 50, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 46, 42, 53, 41, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [45, 40, 57, 54, 46, 49, 50, 55, 44, 48, 53, 51, 52, 39, 59, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(os.path.join(source_directory, f\"*{extension}\")))\n            os.path.join(source_directory, \"**/*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 49, 51, 44, 45, 43, 39, 41, 58, 42, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, stem + extension)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 54, 55, 44, 42, 57, 40, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.007203102111816406, "tests_passed": true, "error": null}}
{"selected_lines": [44, 52, 45, 40, 58, 51, 50, 57, 46, 49, 59, 55, 54, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 55, 41, 56, 59, 48, 49, 52, 39, 40, 45, 51, 57, 46, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 51, 43, 40, 54, 53, 44, 46, 39, 48, 45, 42, 57, 58, 50, 49, 41, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(source_directory + '/**/*' + extension, recursive=True)\n            os.path.join(source_directory, f\"*{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [58, 55, 39, 52, 40, 45, 43, 49, 53, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 58, 50, 59, 56, 54, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filename).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 56, 44, 51, 43, 39, 45, 57, 55, 49, 58, 41, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError('Source directory does not exist.')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ('.txt', '.docx', '.xlsx', '.csv'):\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 59, 54, 41, 52, 39, 45, 51, 55, 40, 58, 53, 44, 57, 49, 56, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 44, 46, 59, 42, 56, 57, 41, 53, 55, 49, 52, 51, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 44, 59, 57, 46, 48, 42, 50, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filename).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 54, 39, 49, 44, 56, 40, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filename).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 54, 46, 48, 56, 49, 50, 58, 55, 44, 45, 52, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.0002269744873046875, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [39, 54, 49, 41, 57, 56, 46, 43, 48, 40, 52, 53, 59, 58, 50, 42, 51, 55, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"**/*{extension}\"),\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 57, 41, 52, 49, 54, 45, 58, 56, 40, 51, 55, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**\", f\"*{extension}\"), recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 40, 49, 44, 42, 39, 57, 52, 51, 54, 55, 45, 50, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.03177213668823242, "tests_passed": true, "error": null}}
{"selected_lines": [46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.020402908325195312, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [39, 46, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"File {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.006765127182006836, "tests_passed": true, "error": null}}
{"selected_lines": [50, 49, 42, 57, 55, 54, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}\".format(stem, count)\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011770009994506836, "tests_passed": true, "error": null}}
{"selected_lines": [51, 50, 44, 56, 54, 57, 40, 46, 49, 42, 41, 58, 55, 39, 48, 43, 59, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory, exist_ok=True)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, '*.' + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 51, 53, 45, 48, 40, 59, 56, 57, 58, 55, 44, 49, 43, 42, 46, 54, 52, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, f\"*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [49, 56, 51, 50, 54, 43, 41, 58, 46, 48, 55, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**/*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filename).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 51, 39, 52, 42, 40, 46, 53, 43, 44, 58, 56, 48, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 48, 51, 40, 49, 41, 50, 43, 53, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"The source folder does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 44, 39, 46, 59, 41, 53, 49, 57, 40, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 57, 46, 48, 44, 39, 53, 56, 43, 45, 49, 50, 40, 55, 52, 59, 58, 42, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ('.txt', '.docx', '.xlsx', '.csv'):\n        filepaths = glob.glob(source_directory + '/**/*' + extension, recursive=True)\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.0002269744873046875, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [51, 39, 49, 53, 44, 45, 43, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 58, 42, 51, 43, 54, 41, 39, 40, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if os.path.isfile(source_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}.{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 50, 59, 45, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + '/**/*' + extension, recursive=True)\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 39, 42, 45, 50, 41, 52, 54, 56, 46, 40, 49, 58, 43, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source folder does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 39, 49, 58, 54, 56, 51, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, stem)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.01329803466796875, "tests_passed": true, "error": null}}
{"selected_lines": [51, 54, 40, 57, 44, 41, 43, 39, 42, 58, 53, 46, 49, 55, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"**/*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 43, 44, 48, 56, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 56, 57, 48, 49, 59, 43, 41, 50, 51, 44, 40, 45, 39, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 44, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 54, 39, 56, 58, 46, 51, 52, 42, 49, 50, 53, 45, 59, 55, 57, 40, 41, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"The source folder does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory, exist_ok=True)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, f\"*{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 45, 43, 54, 39, 46, 59, 52, 55, 44, 50, 53, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source folder '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, '*' + extension), recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}.{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 44, 45, 55, 40, 50, 43, 53, 51, 56, 46, 49, 41, 59, 39, 42, 57, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"Source directory does not exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.03177213668823242, "tests_passed": true, "error": null}}
{"selected_lines": [41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.027803897857666016, "tests_passed": true, "error": null}}
{"selected_lines": [39, 51, 49, 58, 53, 54, 40, 41, 55, 42, 48, 56, 52, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"{source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**\", f\"*{extension}\"), recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}.{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 51, 43, 57, 39, 44, 52, 56, 41, 53, 45, 42, 54, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(source_directory)\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 52, 57, 54, 49, 41, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.012350082397460938, "tests_passed": true, "error": null}}
{"selected_lines": [54, 58, 55, 59, 52, 42, 53, 57, 48, 50, 44, 56, 39, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.0002269744873046875, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [58, 50, 46, 42, 59, 52, 40, 53, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 59, 50, 57, 49, 42, 52, 39, 53, 43, 45, 40, 55, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 40, 59, 56, 58, 57, 49, 51, 45, 39, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 55, 39, 50, 52, 49, 57, 46, 43, 58, 44, 48, 40, 42, 41, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"File not found: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 54, 50, 43, 46, 56, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}.{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.006357908248901367, "tests_passed": true, "error": null}}
{"selected_lines": [43, 42, 59, 55, 51, 41, 57, 45, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(os.path.join(source_directory, f\"*{extension}\")))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028750896453857422, "tests_passed": true, "error": null}}
{"selected_lines": [50, 40, 45, 56, 44, 49, 51, 42, 58, 55, 57, 53, 54, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**\", f\"*{extension}\"), recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}.{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 46, 59, 41, 55, 53, 40, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.006442070007324219, "tests_passed": true, "error": null}}
{"selected_lines": [57, 46, 42, 41, 49, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory, exist_ok=True)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 56, 54, 45, 51, 43, 53, 57, 42, 44, 39, 40, 49, 52, 59, 48, 41, 46, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = [\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 40, 48, 41, 45, 57, 56, 58, 55, 49, 54, 59, 39, 51, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = [\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 40, 49, 43, 39, 55, 59, 52, 41, 51, 58, 46, 50, 56, 44, 45, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True))\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 49, 56, 44, 41, 52, 51, 53, 48, 42, 43, 50, 55, 39, 54, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(\n            os.path.join(source_directory, f'*.{extension.lstrip(\".\")}')\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 49, 51, 40, 44, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 56, 40, 42, 46, 58, 53, 51, 45, 43, 55, 48, 50, 57, 44, 49, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ('.txt', '.docx', '.xlsx', '.csv'):\n        filepaths = glob.glob(os.path.join(source_directory, \"**\", f\"*{extension}\"), recursive=True)\n            os.path.join(source_directory, f'*.{extension.lstrip(\".\")}')\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError('Source directory does not exist.')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.029612064361572266, "tests_passed": true, "error": null}}
{"selected_lines": [46, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 41, 51, 43, 56, 55, 45, 57, 46, 59, 53, 42, 49, 54, 48, 58, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source folder does not exist\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, stem)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 53, 57, 43, 45, 56, 52, 58, 48, 54, 40, 39, 41, 50, 42, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**\", f\"*{extension}\"), recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.0002448558807373047, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [48, 45, 58, 49, 43, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + os.sep + \"**/*\" + extension, recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 59, 46, 42, 40, 57, 55, 43, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.009660959243774414, "tests_passed": false, "error": "FileNotFoundError"}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [41, 46, 45, 54, 50, 55, 44, 42, 52, 59, 53, 58, 43, 51, 49, 39, 48, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source folder '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 56, 43, 53, 46, 39, 49, 52, 45, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00034308433532714844, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [56, 51, 39, 59, 42, 50, 48, 55, 54, 41, 46, 45, 43, 58, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, '*.' + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 56, 41, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f'The source directory {source_directory} does not exist')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 55, 54, 52, 42, 49, 57, 53, 41, 51, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.027803897857666016, "tests_passed": true, "error": null}}
{"selected_lines": [42, 46, 40, 48, 59, 51, 44, 45, 53, 54, 43, 55, 52, 39, 57, 41, 56, 49, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, '*' + extension), recursive=True)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 44, 46, 45, 55, 43, 58, 42, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True))\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 55, 46, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 44, 55, 57, 54, 42, 53, 58, 41, 45, 46, 48, 39, 49, 43, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source folder {source_directory} not found.\")\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(source_directory + \"/**/*\" + extension, recursive=True)\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}.{}\".format(filename, count, extension[1:])\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 54, 52, 59, 49, 41, 45, 43, 48, 40, 44, 46, 53, 56, 58, 57, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"File {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.027957916259765625, "tests_passed": true, "error": null}}
{"selected_lines": [59, 40, 52, 53, 49, 42, 56, 54, 43, 45, 50, 51, 39, 55, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}\".format(stem, count)\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 40, 44, 48, 51, 52, 50, 59, 58, 45, 54, 56, 42, 46, 53, 55, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 54, 40, 51, 59, 48, 50, 55, 53, 44, 52, 45, 58, 57, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 50, 52, 53, 59, 39, 57, 49, 54, 55, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.013633966445922852, "tests_passed": true, "error": null}}
{"selected_lines": [40, 58, 55, 41, 39, 43, 45, 59, 51, 44, 54, 46, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"Source folder does not exist\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 50, 52, 53, 59, 39, 57, 49, 54, 55, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.013633966445922852, "tests_passed": true, "error": null}}
{"selected_lines": [46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.01863884925842285, "tests_passed": true, "error": null}}
{"selected_lines": [42, 50, 44, 52, 51, 55, 45, 56, 39, 57, 41, 54, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError('Source directory does not exist.')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = sorted(glob.glob(os.path.join(source_directory, f\"*{extension}\")))\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 43, 39, 51, 41, 48, 42, 50, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"Source directory does not exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filename).stem\n            target_filepath = Path(target_directory, stem)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011966943740844727, "tests_passed": true, "error": null}}
{"selected_lines": [46, 52, 40, 50, 44, 49, 54, 48, 51, 42, 59, 57, 55, 41, 56, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, '*' + extension), recursive=True)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 39, 54, 45, 48, 42, 40, 44, 51, 56, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 53, 40, 59, 51, 39, 42, 50, 43, 56, 49, 41, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.01316523551940918, "tests_passed": true, "error": null}}
{"selected_lines": [54, 58, 51, 53, 59, 55, 48, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 40, 43, 55, 54, 41, 45, 42, 56, 39, 46, 59, 51, 53, 50, 44, 58, 57, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.iglob(os.path.join(source_directory, \"*\" + extension), recursive=True)\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 57, 40, 42, 55, 52, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + \"/**/*\" + extension, recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 57, 46, 58, 45, 59, 39, 55, 49, 54, 43, 44, 48, 51, 41, 53, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in ('.txt', '.docx', '.xlsx', '.csv'):\n        filepaths = glob.glob(source_directory + '/**/*' + extension, recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 39, 55, 52, 41, 59, 48, 43, 56, 46, 54, 51, 45, 44, 49, 50, 40, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, stem + extension)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 48, 50, 45, 44, 59, 54, 56, 57, 39, 46, 51, 53, 41, 49, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"{source_directory} does not exist.\")\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 59, 46, 49, 51, 54, 45, 55, 56, 50, 40, 52, 53, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**/*\" + extension), recursive=True)\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 51, 43, 54, 55, 45, 53, 44, 39, 42, 57, 59, 50, 41, 46, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f'*.{extension.lstrip(\".\")}')\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 56, 49, 50, 48, 39, 52, 55, 46, 51, 42, 57, 58, 53, 41, 54, 44, 40, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source folder '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 52, 58, 42, 53, 40, 48, 55, 56, 49, 54, 45, 46, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [52, 40, 53, 50, 49, 45, 56, 42, 59, 55, 41, 48, 58, 51, 44, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filename).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00028586387634277344, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [58, 48, 41, 49, 53, 43, 54, 55, 46, 40, 50, 45, 51, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 49, 46, 56, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**/*.\" + extension, recursive=True)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 46, 56, 52, 40, 54, 50, 41, 51, 58, 53, 42, 59, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**/*.\" + extension, recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [53, 43, 48, 55, 51, 57, 59, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 41, 45, 52, 46, 57, 53, 48, 58, 42, 54, 40, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, '*' + extension), recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 54, 41, 59, 51, 42, 53, 43, 46, 39, 45, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"File {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + os.sep + \"**/*\" + extension, recursive=True)\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 55, 40, 46, 41, 44, 56, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f'The source directory {source_directory} does not exist')\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.006333112716674805, "tests_passed": true, "error": null}}
{"selected_lines": [59, 57, 39, 51, 46, 53, 41, 42, 44, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00024700164794921875, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [44, 50, 52, 53, 59, 39, 57, 49, 54, 55, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.013633966445922852, "tests_passed": true, "error": null}}
{"selected_lines": [58, 59, 54, 43, 39, 57, 51, 56, 41, 50, 40, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011844873428344727, "tests_passed": true, "error": null}}
{"selected_lines": [51, 42, 46, 39, 45, 52, 40, 50, 55, 44, 56, 54, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 44, 59, 48, 43, 56, 50, 52, 39, 40, 45, 49, 58, 42, 51, 57, 46, 54, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"**/*{extension}\"),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 48, 50, 42, 59, 44, 54, 41, 45, 43, 57, 55, 51, 52, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 57, 46, 43, 44, 39, 41, 42, 45, 56, 49, 50, 52, 40, 48, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"The source folder does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filename).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 42, 55, 48, 45, 41, 50, 56, 59, 57, 58, 44, 52, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.009660959243774414, "tests_passed": false, "error": "FileNotFoundError"}}
{"selected_lines": [46, 49, 57, 59, 56, 53, 40, 44, 51, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.006376028060913086, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [45, 59, 55, 49, 53, 48, 42, 51, 44, 39, 43, 46, 56, 58, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 57, 49, 44, 59, 50, 39, 41, 51, 45, 46, 58, 43, 40, 54, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f'source directory {source_directory} not found')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filename).stem\n            target_filepath = Path(target_directory, stem)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 40, 53, 42, 46, 41, 55, 48, 59, 51, 44, 49, 39, 56, 45, 52, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, f\"*{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.splitext(filepath)[0].split(\"/\")[-1]\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source folder does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.013835906982421875, "tests_passed": true, "error": null}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.0002269744873046875, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [48, 50, 44, 57, 42, 46, 56, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 42, 46, 55, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(source_directory)\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f'*.{extension.lstrip(\".\")}')\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.006500959396362305, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [58, 48, 43, 53, 54, 55, 39, 51, 46, 41, 57, 42, 44, 40, 52, 45, 50, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError('Source directory does not exist.')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True))\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 57, 46, 55, 52, 56, 53, 40, 49, 41, 48, 42, 59, 58, 54, 43, 39, 51, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"File not found: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 41, 48, 46, 54, 58, 45, 55, 44, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.03206586837768555, "tests_passed": true, "error": null}}
{"selected_lines": [50, 56, 55, 41, 57, 53, 49, 54, 43, 45, 44, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**\", f\"*{extension}\"), recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 58, 41, 56, 48, 45, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f'The source directory {source_directory} does not exist')\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + os.sep + \"**/*\" + extension, recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 59, 57, 41, 48, 46, 44, 58, 53, 43, 42, 50, 49, 51, 55, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"{source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}\".format(stem, count)\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 44, 43, 51, 39, 59, 54, 55, 46, 42, 56, 52, 53, 48, 40, 45, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"Source directory does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}.{}\".format(filename, count, extension[1:])\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 57, 59, 58, 51, 49, 40, 53, 41, 54, 46, 44, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, '*.' + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.009660959243774414, "tests_passed": false, "error": "FileNotFoundError"}}
{"selected_lines": [53, 55, 59, 49, 45, 52, 56, 57, 42, 39, 58, 48, 41, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(os.path.join(source_directory, f\"*{extension}\")))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 53, 48, 39, 40, 55, 45, 44, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = glob.glob(os.path.join(source_directory, \"**\", f\"*{extension}\"), recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}.{}\".format(filename, count, extension[1:])\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 41, 48, 52, 40, 55, 58, 59, 45, 44, 43, 51, 50, 42, 57, 46, 53, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 59, 49, 41, 45, 44, 46, 40, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + os.sep + \"**/*\" + extension, recursive=True)\n            os.path.join(source_directory, f\"*{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0301361083984375, "tests_passed": true, "error": null}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00024700164794921875, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00025272369384765625, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [51, 48, 49, 41, 53, 44, 43, 54, 45, 52, 50, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'The source directory {source_directory} does not exist')\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.027267932891845703, "tests_passed": true, "error": null}}
{"selected_lines": [53, 41, 52, 50, 45, 51, 39, 58, 56, 40, 57, 54, 42, 43, 59, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []  # to count files\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}.{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 50, 42, 53, 59, 39, 55, 58, 43, 51, 57, 46, 45, 41, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"File not found: {source_directory}\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**/*.\" + extension, recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 57, 49, 55, 43, 58, 46, 56, 45, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 53, 51, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 43, 56, 49, 48, 39, 51, 45, 44, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"**/*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 54, 44, 59, 51, 48, 58, 46, 42, 53, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.006403684616088867, "tests_passed": true, "error": null}}
{"selected_lines": [55, 43, 50, 42, 58, 45, 51, 48, 54, 44, 41, 46, 39, 40, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}\".format(stem, count)\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 50, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 43, 46, 53, 41, 58, 51, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source folder does not exist\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.006398916244506836, "tests_passed": true, "error": null}}
{"selected_lines": [41, 42, 55, 53, 56, 50, 54, 51, 39, 43, 52, 58, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 41, 53, 51, 39, 45, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 57, 50, 49, 53, 55, 41, 44, 40, 48, 54, 45, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 49, 42, 55, 48, 54, 45, 39, 50, 52, 59, 40, 56, 58, 43, 51, 41, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source folder '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, '*.' + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 42, 45, 51, 40, 50, 44, 53, 41, 55, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(source_directory + '/**/*' + extension, recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 59, 44, 49, 46, 45, 53, 43, 39, 57, 41, 55, 54, 50, 42, 56, 40, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**/*\" + extension), recursive=True)\n            os.path.join(source_directory, \"**/*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = os.path.splitext(filepath)[0].split(\"/\")[-1]\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 39, 41, 52, 54, 48, 58, 43, 42, 50, 55, 49, 56, 51, 59, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"File {source_directory} not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 56, 39, 40, 50, 51, 54, 42, 53, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).is_dir():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 56, 53, 49, 43, 54, 46, 39, 55, 42, 48, 51, 45, 58, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, stem + extension)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 44, 41, 42, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.013759851455688477, "tests_passed": true, "error": null}}
{"selected_lines": [39, 44, 56, 59, 40, 53, 48, 51, 43, 49, 46, 50, 57, 52, 42, 58, 55, 54, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 45, 58, 59, 54, 40, 57, 52, 41, 56, 44, 43, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.iglob(os.path.join(source_directory, \"*\" + extension), recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 50, 59, 43, 49, 54, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011713027954101562, "tests_passed": true, "error": null}}
{"selected_lines": [40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011459112167358398, "tests_passed": false, "error": "FileNotFoundError"}}
{"selected_lines": [54, 52, 51, 58, 39, 56, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, stem)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}.{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.012936115264892578, "tests_passed": true, "error": null}}
{"selected_lines": [41, 53, 52, 55, 48, 44, 46, 40, 58, 56, 51, 43, 49, 54, 57, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, '*.' + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 54, 57, 39, 50, 40, 48, 58, 51, 44, 53, 59, 42, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0125579833984375, "tests_passed": true, "error": null}}
{"selected_lines": [49, 41, 42, 59, 53, 43, 50, 55, 45, 52, 51, 56, 57, 46, 44, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory does not exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, '*' + extension), recursive=True)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 55, 48, 56, 44, 57, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 55, 49, 45, 53, 48, 56, 39, 51, 44, 42, 46, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.splitext(filepath)[0].split(\"/\")[-1]\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 51, 40, 43, 45, 39, 53, 56, 42, 49, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 57, 48, 44, 43, 41, 56, 39, 50, 55, 40, 54, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, '*' + extension), recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028074979782104492, "tests_passed": true, "error": null}}
{"selected_lines": [55, 46, 57, 45, 59, 42, 54, 56, 40, 43, 51, 39, 58, 52, 44, 49, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(source_directory + os.sep + \"**/*\" + extension, recursive=True)\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 59, 58, 50, 39, 48, 56, 57, 45, 43, 53, 40, 52, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 44, 57, 53, 43, 46, 51, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f'*.{extension.lstrip(\".\")}')\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 52, 40, 46, 49, 56, 53, 59, 50, 57, 39, 58, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 51, 42, 43, 41, 59, 44, 57, 46, 50, 40, 56, 49, 54, 53, 58, 52, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.isdir(source_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.iglob(os.path.join(source_directory, \"*\" + extension), recursive=True)\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 48, 45, 39, 57, 58, 54, 56, 55, 40, 49, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.000244140625, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [40, 59, 49, 56, 53, 54, 48, 42, 44, 45, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + \"/**/*\" + extension, recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 42, 50, 53, 58, 51, 56, 54, 48, 44, 59, 41, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.01863884925842285, "tests_passed": true, "error": null}}
{"selected_lines": [52, 59, 50, 49, 45, 55, 39, 42, 46, 41, 53, 54, 56, 57, 51, 58, 40, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"**/*{extension}\"),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filename).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []  # to count files\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.007776021957397461, "tests_passed": true, "error": null}}
{"selected_lines": [48, 40, 41, 54, 49, 42, 39, 50, 52, 53, 59, 55, 57, 46, 43, 58, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source folder '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filename).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 40, 45, 48, 58, 52, 44, 57, 42, 51, 43, 41, 50, 55, 49, 54, 56, 59, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source folder '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 39, 54, 51, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, '*' + extension), recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 50, 59, 46, 55, 49, 40, 48, 52, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"**/*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 40, 46, 57, 48, 54, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.006428956985473633, "tests_passed": true, "error": null}}
{"selected_lines": [39, 56, 42, 50, 45, 46, 51, 55, 49, 59, 41, 40, 52, 43, 58, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"File not found: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + \"/**/*\" + extension, recursive=True)\n            os.path.join(source_directory, f\"*{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 53, 41, 51, 50, 43, 57, 40, 59, 48, 44, 42, 55, 58, 46, 54, 39, 45, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, '*' + extension), recursive=True)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 44, 51, 46, 41, 56, 49, 57, 45, 43, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"File not found: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 59, 44, 55, 41, 39, 40, 50, 43, 46, 57, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(\n            os.path.join(source_directory, '*.' + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 58, 41, 39, 53, 59, 44, 55, 40, 46, 51, 52, 56, 54, 42, 48, 49, 57, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + \"/**/*\" + extension, recursive=True)\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 41, 52, 40, 57, 50, 59, 48, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**/*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0114898681640625, "tests_passed": true, "error": null}}
{"selected_lines": [58, 51, 41, 42, 44, 54, 48, 40, 43, 55, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 54, 40, 58, 42, 41, 57, 52, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 41, 55, 42, 51, 45, 54, 53, 44, 50, 46, 49, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.isdir(source_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filename).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 48, 53, 45, 59, 51, 52, 50, 39, 41, 58, 44, 56, 40, 55, 54, 46, 49, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 53, 50, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 57, 51, 41, 39, 42, 48, 44, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ('.txt', '.docx', '.xlsx', '.csv'):\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 55, 57, 48, 56, 59, 46, 42, 52, 41, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 46, 57, 55, 52, 58, 42, 43, 51, 48, 59, 53, 56, 54, 50, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory, exist_ok=True)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, '*' + extension), recursive=True)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 55, 48, 39, 58, 43, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0013430118560791016, "tests_passed": true, "error": null}}
{"selected_lines": [57, 46, 56, 55, 59, 48, 39, 51, 42, 52, 58, 44, 53, 50, 54, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 46, 57, 53, 59, 58, 39, 40, 50, 54, 41, 52, 49, 51, 44, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}\".format(stem, count)\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 45, 43, 49, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 43, 39, 58, 50, 40, 52, 46, 44, 45, 54, 55, 41, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).exists():\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}\".format(stem, count)\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 52, 43, 59, 45, 57, 49, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 59, 54, 42, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}.{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 59, 56, 57, 49, 46, 45, 50, 54, 55, 40, 58, 52, 51, 42, 53, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + '/**/*' + extension, recursive=True)\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 53, 40, 42, 52, 51, 50, 46, 56, 59, 48, 39, 44, 58, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 53, 43, 44, 52, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 40, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = [\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 54, 39, 58, 51, 53, 50, 44, 46, 57, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"File {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.006426811218261719, "tests_passed": true, "error": null}}
{"selected_lines": [44, 41, 55, 49, 51, 58, 54, 43, 50, 48, 42, 53, 45, 56, 46, 40, 39, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"{source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(source_directory + \"/**/*\" + extension, recursive=True)\n            os.path.join(source_directory, f\"**/*{extension}\"),\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [46, 50, 40, 54, 48, 41, 53, 51, 59, 52, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source directory '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"**/*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}\".format(stem, count)\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 51, 58, 44, 54, 55, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}.{}\".format(filename, count, extension[1:])\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 53, 43, 50, 57, 54, 59, 44, 51, 52, 49, 42, 45, 40, 39, 58, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 52, 41, 56, 50, 45, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.isdir(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 46, 52, 40, 53, 42, 57, 44, 45, 54, 59, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, f'*.{extension.lstrip(\".\")}')\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 57, 45, 59, 51, 53, 46, 48, 52, 49, 50, 54, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 51, 39, 41, 46, 59, 57, 54, 53, 45, 48, 50, 44, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.isdir(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"**/*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 51, 42, 56, 59, 54, 44, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.013941049575805664, "tests_passed": true, "error": null}}
{"selected_lines": [51, 43, 49, 56, 48, 53, 41, 45, 55, 39, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.isdir(source_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.splitext(filepath)[0].split(\"/\")[-1]\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, stem + extension)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**/*\" + extension), recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00023293495178222656, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [53, 45, 52, 49, 58, 57, 50, 54, 46, 56, 44, 41, 55, 51, 43, 40, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True))\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 46, 57, 49, 43, 51, 40, 48, 45, 53, 52, 54, 56, 55, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 57, 58, 55, 40, 49, 45, 53, 51, 41, 44, 52, 39, 56, 48, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**/*.\" + extension, recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 41, 51, 43, 48, 56, 46, 42, 50, 44, 59, 49, 57, 40, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True))\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 45, 55, 51, 57, 59, 53, 46, 42, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [40, 56, 49, 59, 48, 50, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 57, 48, 44, 52, 51, 50, 45, 40, 43, 46, 53, 59, 54, 58, 41, 39, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"File not found: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**/*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}.{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [39, 52, 50, 42, 43, 54, 41, 55, 49, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011617898941040039, "tests_passed": true, "error": null}}
{"selected_lines": [40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.009660959243774414, "tests_passed": false, "error": "FileNotFoundError"}}
{"selected_lines": [59, 55, 57, 40, 58, 51, 44, 45, 46, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 52, 56, 39, 57, 48, 54, 59, 53, 46, 55, 58, 51, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**/*.\" + extension, recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.010529041290283203, "tests_passed": false, "error": "TypeError"}}
{"selected_lines": [53, 59, 52, 43, 46, 49, 41, 42, 39, 40, 45, 48, 44, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**\", f\"*{extension}\"), recursive=True)\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 44, 58, 55, 56, 40, 57, 39, 54, 43, 53, 49, 52, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 49, 50, 43, 39, 42, 54, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory, exist_ok=True)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}.{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [51, 56, 46, 59, 55, 58, 40, 41, 52, 48, 57, 42, 50, 39, 49, 43, 45, 44, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).is_dir():\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + \"/**/*\" + extension, recursive=True)\n            os.path.join(source_directory, f\"**/*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, stem)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 43, 52, 58, 44, 49, 39, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.03126716613769531, "tests_passed": true, "error": null}}
{"selected_lines": [54, 39, 56, 58, 45, 40, 44, 51, 43, 46, 55, 50, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []  # to count files\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00034308433532714844, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [46, 43, 58, 49, 40, 54, 50, 59, 45, 44, 57, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, '*' + extension), recursive=True)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 43, 53, 58, 42, 46, 52, 59, 56, 54, 45, 50, 57, 41, 51, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(f'source directory {source_directory} not found')\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**/*.\" + extension, recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 48, 55, 46, 57, 45, 40, 41, 50, 59, 54, 58, 51, 44, 56, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError('Source directory does not exist.')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [52, 58, 50, 41, 59, 43, 44, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.012517929077148438, "tests_passed": true, "error": null}}
{"selected_lines": [51, 46, 59, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, '*' + extension), recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 52, 58, 51, 40, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.012835979461669922, "tests_passed": true, "error": null}}
{"selected_lines": [52, 50, 46, 42, 48, 41, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source directory does not exist: {source_directory}\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 53, 43, 50, 55, 48, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011833906173706055, "tests_passed": true, "error": null}}
{"selected_lines": [51, 50, 41, 56, 52, 40, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f'The source directory {source_directory} does not exist')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 41, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 48, 56, 41, 59, 57, 43, 52, 39, 46, 54, 51, 44, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'source directory {source_directory} not found')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True))\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}.{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 48, 43, 40, 46, 57, 56, 39, 44, 42, 50, 55, 53, 54, 58, 45, 41, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source folder does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**/*\" + extension), recursive=True)\n            os.path.join(source_directory, f'*.{extension.lstrip(\".\")}')\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 49, 51, 52, 58, 42, 45, 53, 40, 54, 44, 48, 43, 56, 46, 55, 41, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True))\n            os.path.join(source_directory, f\"**/*{extension}\"),\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 40, 41, 51, 59, 50, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 54, 44, 45, 55, 59, 49, 39, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 45, 59, 50, 43, 41, 42, 52, 48, 49, 39, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 55, 50, 41, 39, 46, 57, 54, 42, 43, 51, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 56, 40, 44, 41, 52, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(\"Source directory does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.013969182968139648, "tests_passed": true, "error": null}}
{"selected_lines": [42, 44, 51, 41, 54, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}.{}\".format(filename, count, extension[1:])\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 39, 51, 55, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filename).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011564254760742188, "tests_passed": true, "error": null}}
{"selected_lines": [55, 43, 44, 52, 49, 53, 46, 57, 59, 54, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.006391048431396484, "tests_passed": true, "error": null}}
{"selected_lines": [49, 56, 45, 48, 51, 55, 50, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(os.path.join(source_directory, f\"*{extension}\")))\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 58, 51, 54, 41, 43, 45, 56, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 39, 41, 56, 49, 42, 43, 52, 55, 45, 58, 50, 40, 44, 48, 54, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 46, 56, 43, 57, 59, 42, 45, 54, 41, 50, 51, 39, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory, exist_ok=True)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 54, 45, 49, 46, 58, 59, 55, 56, 52, 41, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 59, 48, 55, 57, 43, 56, 52, 50, 44, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.013937234878540039, "tests_passed": true, "error": null}}
{"selected_lines": [43, 58, 57, 42, 50, 59, 53, 52, 56, 41, 46, 44, 45, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 46, 52, 40, 51, 53, 39, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, '*.' + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, stem)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.002811908721923828, "tests_passed": true, "error": null}}
{"selected_lines": [52, 39, 59, 55, 49, 45, 58, 53, 42, 46, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 48, 39, 55, 59, 45, 53, 43, 41, 42, 46, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.0001971721649169922, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [41, 53, 44, 39, 40, 42, 59, 58, 54, 57, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []  # to count files\n    if Path(source_directory).exists():\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [40, 59, 54, 43, 49, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011709213256835938, "tests_passed": true, "error": null}}
{"selected_lines": [41, 49, 42, 57, 43, 53, 40, 59, 45, 51, 48, 54, 46, 58, 39, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source folder does not exist\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + '/**/*' + extension, recursive=True)\n            os.path.join(source_directory, f\"**/*{extension}\"),\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 42, 57, 45, 40, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 57, 53, 58, 54, 55, 50, 48, 42, 49, 43, 51, 52, 44, 46, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 50, 42, 45, 40, 54, 44, 39, 56, 51, 55, 41, 43, 59, 58, 48, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 39, 52, 43, 57, 54, 45, 46, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 55, 57, 49, 52, 41, 59, 42, 51, 50, 48, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.01285099983215332, "tests_passed": true, "error": null}}
{"selected_lines": [45, 44, 54, 49, 53, 59, 50, 55, 46, 51, 39, 57, 58, 43, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(source_directory + '/**/*' + extension, recursive=True)\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00025272369384765625, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.027267932891845703, "tests_passed": true, "error": null}}
{"selected_lines": [55, 41, 59, 42, 48, 53, 54, 51, 44, 58, 52, 56, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 44, 52, 41, 39, 42, 48, 54, 51, 45, 49, 58, 55, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.splitext(filepath)[0].split(\"/\")[-1]\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 44, 56, 55, 41, 58, 42, 46, 53, 39, 45, 50, 43, 49, 51, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**/*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 52, 53, 46, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.006592988967895508, "tests_passed": true, "error": null}}
{"selected_lines": [44, 39, 58, 49, 55, 53, 52, 51, 42, 40, 48, 59, 50, 57, 45, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + '/**/*' + extension, recursive=True)\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [45, 46, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 53, 42, 46, 50, 44, 58, 41, 54, 52, 48, 56, 45, 39, 57, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}\".format(stem, count)\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 44, 50, 49, 46, 41, 56, 53, 51, 42, 39, 48, 58, 59, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).is_dir():\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011224031448364258, "tests_passed": true, "error": null}}
{"selected_lines": [45, 46, 44, 50, 55, 51, 42, 53, 59, 57, 41, 48, 39, 54, 52, 49, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' does not exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"File not found: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 42, 52, 54, 45, 56, 50, 51, 41, 43, 49, 53, 40, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError('Source directory does not exist.')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 44, 40, 39, 42, 41, 59, 46, 57, 49, 56, 52, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 40, 48, 42, 51, 52, 54, 53, 39, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 43, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f'*.{extension.lstrip(\".\")}')\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.006541013717651367, "tests_passed": true, "error": null}}
{"selected_lines": [46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, '*.' + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011974811553955078, "tests_passed": true, "error": null}}
{"selected_lines": [41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.02737116813659668, "tests_passed": true, "error": null}}
{"selected_lines": [51, 49, 50, 55, 59, 48, 52, 44, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.03149294853210449, "tests_passed": true, "error": null}}
{"selected_lines": [54, 42, 39, 57, 45, 51, 46, 43, 58, 49, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**/*\" + extension), recursive=True)\n            os.path.join(source_directory, f\"**/*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 48, 59, 58, 41, 56, 49, 52, 55, 42, 57, 51, 53, 43, 44, 40, 46, 50, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.isdir(source_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = [\n            os.path.join(source_directory, f'*.{extension.lstrip(\".\")}')\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 57, 43, 54, 40, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011829137802124023, "tests_passed": true, "error": null}}
{"selected_lines": [41, 49, 57, 46, 42, 58, 52, 45, 51, 53, 55, 44, 40, 50, 59, 54, 43, 48, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(os.path.join(source_directory, f\"*{extension}\")))\n            os.path.join(source_directory, '*' + extension), recursive=True)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 48, 49, 43, 42, 54, 50, 55, 44, 52, 58, 39, 40, 45, 56, 53, 57, 59, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 40, 41, 42, 56, 51, 50, 55, 39, 49, 45, 59, 48, 58, 57, 46, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True)\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 55, 49, 44, 43, 50, 51, 54, 48, 52, 46, 41, 59, 45, 40, 56, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}.{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 42, 41, 40, 51, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError('Source directory does not exist.')\n    if not os.path.isdir(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 45, 41, 48, 59, 58, 56, 57, 54, 52, 42, 49, 55, 46, 39, 50, 43, 53, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.splitext(filepath)[0].split(\"/\")[-1]\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 46, 44, 45, 51, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.iglob(os.path.join(source_directory, \"*\" + extension), recursive=True)\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 52, 40, 45, 58, 50, 48, 46, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**/*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**/*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0114898681640625, "tests_passed": true, "error": null}}
{"selected_lines": [54, 40, 52, 42, 57, 45, 50, 43, 44, 59, 46, 56, 39, 53, 41, 51, 58, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(source_directory + os.sep + \"**/*\" + extension, recursive=True)\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.03149294853210449, "tests_passed": true, "error": null}}
{"selected_lines": [50, 45, 44, 53, 46, 54, 59, 58, 43, 41, 57, 51, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError('Source directory does not exist.')\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 55, 49, 48, 57, 43, 39, 41, 50, 58, 59, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, '*' + extension), recursive=True)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filename).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**/*.\" + extension, recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.010529041290283203, "tests_passed": false, "error": "TypeError"}}
{"selected_lines": [49, 40, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 45, 50, 51, 56, 55, 52, 44, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 52, 54, 44, 57, 51, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.013842105865478516, "tests_passed": true, "error": null}}
{"selected_lines": [42, 49, 41, 46, 40, 51, 57, 52, 45, 48, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, stem + extension)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 56, 50, 46, 59, 51, 41, 54, 48, 45, 57, 49, 39, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + os.sep + \"**/*\" + extension, recursive=True)\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 46, 53, 39, 40, 41, 45, 59, 55, 50, 57, 43, 54, 58, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 41, 46, 43, 57, 55, 39, 51, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source folder '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 53, 42, 56, 46, 57, 51, 41, 39, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"File not found: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"**/*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0015289783477783203, "tests_passed": true, "error": null}}
{"selected_lines": [51, 55, 57, 42, 40, 46, 54, 50, 43, 41, 56, 59, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 59, 56, 51, 43, 48, 57, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.isdir(source_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011939764022827148, "tests_passed": true, "error": null}}
{"selected_lines": [42, 45, 52, 43, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 58, 39, 50, 48, 43, 57, 51, 49, 42, 45, 46, 55, 59, 41, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + os.sep + \"**/*\" + extension, recursive=True)\n            os.path.join(source_directory, \"**/*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 52, 54, 58, 59, 43, 55, 48, 40, 56, 49, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.013132095336914062, "tests_passed": true, "error": null}}
{"selected_lines": [57, 55, 44, 49, 53, 51, 56, 52, 39, 46, 43, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 46, 56, 42, 54, 41, 45, 53, 40, 51, 39, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"File {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 53, 41, 56, 42, 43, 52, 55, 45, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"{source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(source_directory + '/**/*' + extension, recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [50, 49, 53, 52, 39, 59, 58, 41, 48, 56, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 43, 42, 52, 44, 46, 41, 51, 50, 56, 48, 57, 59, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source folder {source_directory} not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ('.txt', '.docx', '.xlsx', '.csv'):\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, stem + extension)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.006825923919677734, "tests_passed": true, "error": null}}
{"selected_lines": [41, 45, 52, 42, 50, 54, 51, 44, 40, 48, 39, 55, 53, 59, 56, 46, 58, 49, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**/*.\" + extension, recursive=True)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00028586387634277344, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [41, 46, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f'*.{extension.lstrip(\".\")}')\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.006447792053222656, "tests_passed": true, "error": null}}
{"selected_lines": [54, 57, 49, 44, 45, 48, 50, 51, 56, 59, 46, 42, 58, 39, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True)\n            os.path.join(source_directory, '*.' + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 51, 41, 53, 57, 42, 55, 43, 44, 52, 59, 56, 45, 48, 46, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source folder {source_directory} not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 39, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 50, 54, 56, 42, 45, 49, 44, 58, 39, 52, 59, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 58, 53, 56, 40, 41, 48, 55, 44, 49, 57, 42, 52, 59, 46, 50, 43, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source folder does not exist\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 53, 59, 49, 39, 40, 54, 52, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 45, 43, 46, 41, 59, 57, 58, 49, 48, 55, 56, 44, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f'The source directory {source_directory} does not exist')\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(os.path.join(source_directory, \"**/*\" + extension), recursive=True)\n            os.path.join(source_directory, f\"**/*{extension}\"),\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 51, 39, 57, 49, 50, 56, 43, 55, 44, 45, 58, 53, 52, 46, 54, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, f\"*{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 50, 44, 41, 49, 57, 39, 53, 51, 46, 42, 48, 52, 45, 54, 56, 55, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 44, 54, 46, 51, 43, 49, 50, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 48, 42, 59, 52, 39, 41, 45, 50, 46, 44, 56, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source folder '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = sorted(glob.glob(os.path.join(source_directory, f\"*{extension}\")))\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 50, 53, 41, 48, 43, 56, 40, 51, 52, 42, 49, 46, 45, 57, 58, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + \"/**/*\" + extension, recursive=True)\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 50, 57, 59, 43, 55, 54, 58, 45, 40, 46, 51, 44, 49, 56, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 40, 43, 55, 50, 58, 53, 45, 44, 57, 42, 41, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 46, 59, 48, 45, 50, 51, 52, 42, 57, 41, 49, 54, 53, 58, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.isdir(source_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 53, 44, 57, 41, 59, 46, 51, 39, 50, 40, 52, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"The source folder does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.006417989730834961, "tests_passed": true, "error": null}}
{"selected_lines": [49, 45, 57, 54, 58, 55, 46, 43, 44, 40, 56, 50, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"**/*.\" + extension, recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 40, 42, 56, 55, 39, 41, 44, 57, 58, 53, 52, 45, 49, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + \"/**/*\" + extension, recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.010027885437011719, "tests_passed": false, "error": "FileNotFoundError"}}
{"selected_lines": [42, 45, 51, 44, 52, 49, 48, 56, 46, 50, 54, 53, 39, 57, 58, 41, 43, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 39, 44, 40, 42, 59, 55, 51, 57, 49, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00023508071899414062, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [45, 57, 56, 59, 43, 52, 50, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 53, 46, 57, 41, 51, 45, 59, 58, 40, 54, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 54, 42, 39, 52, 51, 56, 43, 50, 58, 53, 48, 46, 40, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source folder {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 57, 44, 42, 41, 56, 43, 49, 48, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 53, 41, 54, 49, 44, 42, 46, 45, 59, 55, 40, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.isdir(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = sorted(glob.glob(os.path.join(source_directory, f\"*{extension}\")))\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 40, 53, 54, 50, 49, 51, 39, 41, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.03149294853210449, "tests_passed": true, "error": null}}
{"selected_lines": [42, 53, 52, 58, 40, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 43, 44, 45, 46, 57, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 53, 46, 56, 45, 50, 39, 44, 57, 43, 55, 48, 49, 52, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 52, 51, 57, 39, 41, 59, 46, 48, 40, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0029401779174804688, "tests_passed": true, "error": null}}
{"selected_lines": [52, 56, 42, 55, 48, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.027267932891845703, "tests_passed": true, "error": null}}
{"selected_lines": [40, 49, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 46, 39, 49, 43, 55, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"**/*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.splitext(filepath)[0].split(\"/\")[-1]\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.01385188102722168, "tests_passed": true, "error": null}}
{"selected_lines": [43, 46, 50, 39, 49, 57, 55, 54, 44, 56, 58, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 58, 45, 57, 48, 53, 54, 56, 43, 39, 42, 41, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f'The source directory {source_directory} does not exist')\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.iglob(os.path.join(source_directory, \"*\" + extension), recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.027267932891845703, "tests_passed": true, "error": null}}
{"selected_lines": [54, 40, 48, 49, 41, 58, 55, 42, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 56, 44, 42, 54, 48, 52, 49, 43, 55, 46, 50, 51, 59, 41, 57, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, '*.' + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filename).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 51, 44, 55, 48, 42, 57, 58, 59, 46, 50, 43, 45, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f'*.{extension.lstrip(\".\")}')\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 46, 50, 45, 43, 52, 58, 59, 54, 51, 42, 49, 57, 39, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 55, 39, 49, 58, 48, 57, 40, 53, 54, 56, 43, 46, 51, 52, 45, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = os.path.splitext(filepath)[0].split(\"/\")[-1]\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 42, 45, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 48, 42, 53, 54, 46, 45, 55, 51, 56, 43, 58, 49, 52, 41, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00027680397033691406, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [43, 57, 56, 53, 51, 55, 58, 50, 59, 41, 42, 40, 48, 49, 39, 45, 54, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' does not exist.\")\n    if not os.path.isdir(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [43, 50, 55, 52, 41, 51, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 59, 50, 43, 45, 56, 48, 39, 52, 58, 51, 53, 44, 41, 55, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 50, 56, 45, 51, 58, 57, 43, 46, 54, 41, 52, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = [\n            os.path.join(source_directory, f\"**/*{extension}\"),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 41, 44, 53, 42, 43, 59, 46, 55, 56, 50, 58, 57, 48, 51, 54, 49, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 58, 50, 43, 48, 45, 59, 46, 51, 53, 44, 57, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filename).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 57, 55, 48, 50, 52, 51, 42, 53, 39, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011902332305908203, "tests_passed": true, "error": null}}
{"selected_lines": [51, 50, 52, 54, 40, 57, 48, 44, 39, 53, 42, 55, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}\".format(stem, count)\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 49, 54, 51, 46, 40, 57, 45, 44, 59, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(os.path.join(source_directory, f\"*{extension}\")))\n            os.path.join(source_directory, \"**/*.\" + extension, recursive=True)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 53, 58, 49, 48, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 44, 48, 53, 51, 41, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.027803897857666016, "tests_passed": true, "error": null}}
{"selected_lines": [51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00028586387634277344, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [51, 58, 42, 41, 43, 52, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 41, 45, 55, 53, 40, 44, 46, 54, 52, 43, 56, 49, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True))\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 41, 54, 50, 59, 42, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f'source directory {source_directory} not found')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.01185297966003418, "tests_passed": true, "error": null}}
{"selected_lines": [45, 56, 43, 58, 46, 48, 59, 40, 52, 53, 51, 57, 39, 44, 54, 50, 49, 55, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 50, 42, 53, 43, 40, 45, 46, 54, 44, 55, 39, 58, 49, 48, 51, 59, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"Source folder does not exist\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 40, 46, 45, 54, 43, 59, 41, 50, 55, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"Source directory does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True)\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filename).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 55, 52, 57, 40, 42, 46, 43, 58, 51, 49, 48, 41, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**/*\" + extension), recursive=True)\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.03149294853210449, "tests_passed": true, "error": null}}
{"selected_lines": [56, 59, 46, 42, 53, 57, 41, 45, 50, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(f\"Source directory '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + os.sep + \"**/*\" + extension, recursive=True)\n            os.path.join(source_directory, \"**/*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 59, 56, 54, 41, 52, 58, 49, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source folder '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.013978004455566406, "tests_passed": true, "error": null}}
{"selected_lines": [39, 57, 48, 59, 43, 55, 42, 41, 58, 49, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source folder does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.splitext(filepath)[0].split(\"/\")[-1]\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 40, 45, 44, 59, 55, 51, 42, 54, 52, 48, 41, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source folder does not exist: {source_directory}\")\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 39, 58, 44, 57, 41, 55, 54, 52, 43, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError('Source directory does not exist.')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011858940124511719, "tests_passed": true, "error": null}}
{"selected_lines": [46, 56, 49, 45, 40, 50, 58, 39, 52, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + '/**/*' + extension, recursive=True)\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 55, 54, 51, 56, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = [\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 59, 42, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.027267932891845703, "tests_passed": true, "error": null}}
{"selected_lines": [57, 54, 39, 42, 44, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []  # to count files\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}.{}\".format(filename, count, extension[1:])\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.001399993896484375, "tests_passed": true, "error": null}}
{"selected_lines": [57, 48, 43, 44, 56, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.013364076614379883, "tests_passed": true, "error": null}}
{"selected_lines": [49, 46, 59, 58, 54, 50, 56, 51, 43, 45, 52, 41, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source folder '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filename).stem\n            target_filepath = Path(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 55, 53, 51, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 48, 45, 43, 44, 54, 58, 53, 50, 46, 56, 57, 42, 40, 49, 55, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 50, 58, 41, 43, 52, 45, 55, 53, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filename).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 53, 46, 42, 56, 44, 40, 43, 39, 49, 45, 50, 55, 48, 41, 58, 51, 57, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True))\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 39, 55, 42, 59, 44, 48, 54, 46, 58, 45, 53, 52, 43, 51, 40, 50, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [41, 57, 40, 42, 56, 53, 48, 59, 55, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 53, 50, 59, 48, 40, 42, 55, 41, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 45, 44, 57, 46, 51, 56, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 53, 48, 45, 59, 50, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 49, 58, 53, 50, 52, 45, 40, 48, 56, 44, 54, 51, 59, 57, 42, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(source_directory + os.sep + \"**/*\" + extension, recursive=True)\n            os.path.join(source_directory, f\"**/*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 52, 51, 59, 42, 45, 56, 40, 57, 58, 48, 41, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 42, 54, 43, 45, 46, 56, 44, 58, 55, 53, 39, 41, 48, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"File {source_directory} not found.\")\n    if not os.path.isdir(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00028586387634277344, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [42, 51, 58, 53, 49, 46, 54, 39, 50, 55, 56, 40, 44, 48, 52, 41, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + os.sep + \"**/*\" + extension, recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00022411346435546875, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [48, 59, 49, 56, 41, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011835813522338867, "tests_passed": true, "error": null}}
{"selected_lines": [44, 41, 45, 58, 42, 51, 49, 56, 53, 39, 52, 43, 55, 40, 50, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError('Source directory does not exist.')\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 56, 40, 48, 51, 49, 46, 50, 53, 41, 39, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source folder {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.006448030471801758, "tests_passed": true, "error": null}}
{"selected_lines": [41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source folder does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0271148681640625, "tests_passed": true, "error": null}}
{"selected_lines": [54, 49, 58, 51, 53, 50, 45, 48, 46, 56, 52, 57, 59, 40, 39, 42, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []  # to count files\n    if not Path(source_directory).is_dir():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(os.path.join(source_directory, f\"*{extension}\")))\n            os.path.join(source_directory, \"**/*.\" + extension, recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 48, 56, 42, 55, 57, 46, 45, 59, 49, 41, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError('Source directory does not exist.')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 43, 39, 48, 52, 42, 58, 59, 41, 54, 44, 51, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00027680397033691406, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [52, 43, 42, 50, 49, 46, 48, 44, 51, 55, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ('.txt', '.docx', '.xlsx', '.csv'):\n        filepaths = glob.glob(\n            os.path.join(source_directory, '*.' + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 39, 57, 41, 40, 53, 59, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source folder {source_directory} not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 56, 55, 48, 59, 51, 45, 39, 44, 42, 41, 49, 50, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"{source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [44, 42, 41, 43, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 50, 54, 56, 55, 39, 44, 53, 48, 59, 52, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(source_directory + \"/**/*\" + extension, recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filename).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 54, 44, 45, 50, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 48, 43, 40, 50, 54, 58, 56, 46, 39, 55, 45, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True))\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.027803897857666016, "tests_passed": true, "error": null}}
{"selected_lines": [49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.027267932891845703, "tests_passed": true, "error": null}}
{"selected_lines": [49, 52, 45, 48, 51, 56, 46, 58, 40, 39, 53, 50, 54, 44, 59, 41, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 52, 43, 51, 42, 48, 50, 57, 39, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 53, 56, 51, 42, 46, 39, 58, 59, 43, 54, 48, 50, 44, 49, 52, 41, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"File {source_directory} not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 41, 59, 58, 52, 45, 44, 50, 49, 55, 48, 43, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 51, 39, 53, 41, 44, 46, 59, 58, 54, 52, 45, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 58, 39, 51, 57, 56, 43, 48, 40, 53, 52, 55, 49, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [50, 45, 43, 44, 42, 40, 56, 49, 57, 53, 46, 41, 58, 39, 54, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [49, 59, 42, 44, 58, 39, 54, 48, 56, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 46, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f'*.{extension.lstrip(\".\")}')\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00034308433532714844, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [59, 45, 44, 46, 49, 40, 53, 48, 52, 54, 43, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**\", f\"*{extension}\"), recursive=True)\n            os.path.join(source_directory, f\"*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 59, 55, 42, 39, 46, 41, 40, 56, 58, 45, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).is_dir():\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 54, 52, 56, 55, 40, 44, 50, 45, 59, 53, 48, 49, 51, 42, 39, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(source_directory + \"/**/*\" + extension, recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 41, 57, 53, 51, 46, 52, 56, 43, 45, 49, 59, 54, 50, 39, 40, 42, 55, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f'source directory {source_directory} not found')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.0001971721649169922, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [49, 55, 51, 43, 56, 53, 50, 57, 40, 48, 54, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 48, 42, 40, 44, 39, 52, 53, 45, 50, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []  # to count files\n    if Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 59, 43, 41, 45, 57, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00028586387634277344, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [45, 50, 53, 46, 55, 52, 54, 48, 49, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + \"/**/*\" + extension, recursive=True)\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 41, 55, 45, 54, 40, 51, 48, 58, 56, 57, 39, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source folder '{source_directory}' does not exist.\")\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 55, 56, 46, 43, 40, 41, 54, 57, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [57, 56, 52, 40, 42, 43, 58, 46, 55, 53, 49, 59, 39, 48, 44, 50, 41, 45, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 44, 39, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 40, 55, 48, 39, 58, 42, 57, 51, 41, 45, 49, 43, 56, 53, 59, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(f\"Source folder '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 51, 55, 56, 54, 42, 50, 45, 48, 49, 43, 53, 58, 41, 39, 44, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory does not exist: {source_directory}\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 44, 48, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.splitext(filepath)[0].split(\"/\")[-1]\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.01318812370300293, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [59, 45, 55, 46, 53, 52, 54, 51, 39, 41, 56, 58, 49, 57, 40, 42, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source directory '{source_directory}' does not exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(source_directory, f\"**/*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 40, 52, 56, 59, 44, 48, 41, 54, 39, 45, 53, 58, 50, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 57, 39, 40, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 54, 58, 57, 56, 49, 46, 41, 39, 44, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**/*\" + extension), recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}.{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 49, 52, 40, 51, 55, 39, 57, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 39, 57, 55, 53, 56, 52, 48, 42, 51, 59, 43, 45, 46, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**/*\" + extension), recursive=True)\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 53, 49, 45, 48, 40, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + \"/**/*\" + extension, recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 43, 48, 53, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 44, 51, 52, 59, 43, 50, 57, 53, 56, 41, 45, 46, 48, 42, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"{source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"**/*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 53, 42, 56, 48, 49, 45, 50, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.splitext(filepath)[0].split(\"/\")[-1]\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 55, 58, 57, 46, 45, 39, 44, 49, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 43, 39, 40, 55, 53, 46, 51, 42, 48, 56, 49, 58, 45, 44, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, f\"*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 52, 44, 43, 42, 51, 48, 49, 58, 50, 57, 41, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 44, 55, 42, 54, 50, 40, 41, 46, 52, 39, 53, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.006470918655395508, "tests_passed": true, "error": null}}
{"selected_lines": [42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028627872467041016, "tests_passed": true, "error": null}}
{"selected_lines": [40, 42, 58, 39, 46, 49, 52, 53, 45, 44, 50, 55, 59, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 49, 41, 51, 45, 55, 39, 52, 50, 43, 57, 59, 46, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, '*' + extension), recursive=True)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 54, 58, 48, 39, 52, 42, 59, 44, 41, 55, 56, 40, 50, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source folder {source_directory} not found.\")\n    if not os.path.isdir(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, '*' + extension), recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 39, 46, 45, 55, 53, 57, 51, 42, 52, 59, 41, 54, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 58, 49, 44, 59, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).is_dir():\n        raise FileNotFoundError(f\"The source folder does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.011844158172607422, "tests_passed": true, "error": null}}
{"selected_lines": [43, 46, 57, 58, 52, 40, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**/*.\" + extension, recursive=True)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 51, 52, 42, 40, 41, 39, 49, 59, 45, 54, 48, 46, 50, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f'The source directory {source_directory} does not exist')\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = [\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 49, 41, 42, 45, 56, 40, 59, 51, 57, 44, 54, 53, 39, 48, 46, 50, 43, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f'The source directory {source_directory} does not exist')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 51, 50, 48, 41, 46, 39, 58, 45, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"File not found: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(os.path.join(source_directory, f\"*{extension}\")))\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 45, 42, 53, 44, 51, 55, 49, 43, 39, 58, 59, 48, 46, 57, 54, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, stem + extension)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{filename}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 57, 53, 55, 50, 46, 49, 52, 41, 45, 58, 48, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 46, 59, 45, 56, 49, 57, 54, 40, 58, 52, 39, 53, 41, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError('Source directory does not exist.')\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True))\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 45, 50, 46, 59, 48, 40, 56, 58, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"File {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, '*.' + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.000164031982421875, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [45, 56, 41, 57, 54, 51, 58, 39, 59, 42, 49, 40, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []  # to count files\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 48, 54, 45, 50, 52, 43, 51, 39, 58, 46, 59, 41, 42, 55, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory does not exist.\")\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 40, 53, 43, 48, 45, 52, 50, 59, 57, 54, 58, 49, 39, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = [\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 46, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, '*' + extension), recursive=True)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(os.path.join(source_directory, f\"*{extension}\")))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.00024509429931640625, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.027267932891845703, "tests_passed": true, "error": null}}
{"selected_lines": [40, 48, 51, 41, 39, 58, 49, 52, 56, 45, 43, 50, 44, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"The source folder does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filename).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 41, 46, 39, 45, 52, 55, 56, 49, 42, 43, 50, 53, 51, 44, 59, 40, 54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source folder does not exist\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True))\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 57, 52, 51, 43, 45, 39, 56, 54, 53, 40, 48, 59, 44, 58, 42, 50, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.iglob(os.path.join(source_directory, \"*\" + extension), recursive=True)\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 49, 50, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.012953996658325195, "tests_passed": true, "error": null}}
{"selected_lines": [42, 41, 40, 48, 58, 59, 39, 54, 44, 49, 55, 56, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 55, 41, 52, 48, 58, 43, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0031540393829345703, "tests_passed": true, "error": null}}
{"selected_lines": [56, 40, 44, 57, 51, 55, 45, 46, 48, 53, 54, 42, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = [\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 44, 43, 52, 59, 45, 58, 48, 49, 56, 53, 50, 55, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028627872467041016, "tests_passed": true, "error": null}}
{"selected_lines": [44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.03177213668823242, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [45, 48, 52, 50, 46, 54, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}\".format(stem, count)\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 50, 57, 55, 40, 45, 44, 51, 52, 56, 49, 41, 46, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\"txt\", \"docx\", \"xlsx\", \"csv\"):\n        filepaths = glob.glob(os.path.join(source_directory, \"**/*\" + extension), recursive=True)\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.splitext(filepath)[0].split(\"/\")[-1]\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.03177213668823242, "tests_passed": true, "error": null}}
{"selected_lines": [41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source folder '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.02714395523071289, "tests_passed": true, "error": null}}
{"selected_lines": [51, 50, 39, 48, 49, 40, 59, 42, 44, 41, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).is_dir():\n        raise FileNotFoundError(\"Source directory does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 51, 57, 59, 46, 50, 43, 49, 45, 48, 40, 55, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 54, 44, 40, 56, 43, 39, 55, 50, 58, 59, 57, 46, 53, 41, 45, 51, 52, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(source_directory + os.sep + \"**/*\" + extension, recursive=True)\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, stem + extension)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 45, 41, 44, 56, 49, 53, 42, 40, 43, 51, 46, 39, 48, 57, 58, 52, 59, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f'File not found: {source_directory}')\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ('.txt', '.docx', '.xlsx', '.csv'):\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 46, 48, 50, 58, 56, 55, 51, 43, 52, 59, 49, 44, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"*\" + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 43, 41, 55, 53, 59, 54, 48, 46, 42, 57, 49, 50, 44, 45, 40, 39, 56, 51], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(f\"File {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"**/*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 41, 44, 55, 56, 57, 51, 50, 40, 54, 48, 42, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, stem)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 59, 40, 56, 53, 55, 50, 51, 46, 45, 39, 54, 48, 52, 57, 44], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f'*.{extension.lstrip(\".\")}')\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filename).stem\n            target_filepath = os.path.join(target_directory, stem + extension)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 40, 49, 55, 39, 51, 54, 45, 52, 43, 59, 48, 53, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source folder does not exist\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 58, 56, 52, 59, 49, 42, 46, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0301361083984375, "tests_passed": true, "error": null}}
{"selected_lines": [54, 44, 39, 48, 56, 53, 40, 58, 59, 42, 55, 50, 43, 51, 52, 45, 41, 49, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 53, 52, 48, 54, 59, 57, 45, 50, 42, 41, 40, 43, 51, 56, 49, 46, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in (\".txt\", \".docx\", \".xlsx\", \".csv\"):\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = os.path.splitext(filepath)[0].split(\"/\")[-1]\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 43, 45, 42, 44, 54, 48, 58, 52, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(source_directory + '/**/*' + extension, recursive=True)\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 54, 42, 50, 46, 56, 44, 49, 45, 40, 57, 51, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, f\"**/*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 42, 39, 49, 58, 44, 43, 55, 54, 53, 56], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 55, 40, 50, 57, 48, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"Source directory not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.012058019638061523, "tests_passed": true, "error": null}}
{"selected_lines": [41, 42, 44, 50, 56, 55, 49, 53, 58, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"File {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.014018058776855469, "tests_passed": true, "error": null}}
{"selected_lines": [51, 46, 41, 59, 54, 45, 48, 56, 43, 53, 58, 39, 50, 44, 57, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(source_directory + \"/**/*\" + extension, recursive=True)\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 57, 58, 44, 46, 45, 59, 52, 55, 51, 49, 39, 50, 53, 56, 42, 54, 41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ('.txt', '.docx', '.xlsx', '.csv'):\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, '*.' + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 41, 58, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source folder '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [49, 40, 43, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [59, 40, 46, 56, 48, 54, 58, 44, 51, 57, 43, 50, 42, 41, 49, 53, 45, 52], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ('.txt', '.docx', '.xlsx', '.csv'):\n        filepaths = glob.iglob(os.path.join(source_directory, \"*\" + extension), recursive=True)\n            os.path.join(source_directory, f\"*.{extension.strip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filename).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 46, 40, 52, 51, 41, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"*{extension}\"), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 56, 48, 44, 54, 57, 42, 46, 49, 58], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**/*\" + extension),\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0030031204223632812, "tests_passed": true, "error": null}}
{"selected_lines": [45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": false, "time": 0.0002269744873046875, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [39, 59, 43, 54, 58, 52, 44, 46, 51, 42, 41, 49, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"Source directory does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**/*.\" + extension, recursive=True)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = Path(target_directory, stem)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 49, 44, 52, 57, 40, 58, 42, 43, 41, 51, 45, 46, 48, 55, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**/*\" + extension), recursive=True)\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 41, 51, 42, 52, 54, 40, 57, 53, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).exists():\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 54, 59, 45, 43, 56, 52, 44, 42, 40, 58, 49, 41, 55, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).is_dir():\n        raise FileNotFoundError(f\"The source directory {source_directory} does not exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory, exist_ok=True)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}\".format(stem, count)\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 45, 56, 59, 52, 40, 41, 46, 49, 50, 43, 55, 42, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).exists():\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, f\"*.{extension.lstrip('.')}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 45, 56, 51, 41, 42, 49, 39, 46, 40, 54, 50, 58, 44, 55], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, \"**\", f\"*{extension}\"), recursive=True)\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"{source_directory} does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.027109861373901367, "tests_passed": true, "error": null}}
{"selected_lines": [45, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if Path(source_directory).exists():\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(os.path.join(source_directory, f\"*.{extension}\"))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 54, 52, 46, 56, 42], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f\"**/*{extension}\"),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename.split('.')[-1]}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.002981901168823242, "tests_passed": true, "error": null}}
{"selected_lines": [45, 44, 42, 49, 52, 57, 40], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 46, 56, 55, 57, 39], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, f'*.{extension.lstrip(\".\")}')\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 55, 43, 58, 56, 52, 48, 44, 42, 50, 45, 53, 41, 54, 51, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' does not exist.\")\n    if os.path.isfile(source_directory):\n        os.mkdir(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True))\n            os.path.join(source_directory, '*.' + extension)\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filename).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.03153705596923828, "tests_passed": true, "error": null}}
{"selected_lines": [56, 59, 44, 43, 50, 57, 52, 54, 42, 49, 55, 45, 48, 51, 46], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.isdir(source_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(source_directory, f\"**/*{extension}\"),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).stem\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 0\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.028088092803955078, "tests_passed": true, "error": null}}
{"selected_lines": [54, 45, 58, 49, 51, 56, 44, 50, 59, 40, 46, 43, 55, 41, 57, 48], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if os.path.isdir(source_directory):\n        raise FileNotFoundError(f\"Source folder '{source_directory}' does not exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"*.{extension}\")\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filename).stem\n            target_filepath = Path(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 59, 40, 55, 45, 42, 53, 49, 54, 41, 44, 51, 56, 39, 46, 57, 48, 52, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if not Path(source_directory).is_dir():\n        raise FileNotFoundError(f\"The source folder does not exist: {source_directory}\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['txt', 'docx', 'xlsx', 'csv']:\n        filepaths = glob.glob(f\"{source_directory}/**/*{extension}\", recursive=True)\n            os.path.join(source_directory, '*.' + extension)\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 44, 51, 48, 52, 56, 43, 54, 46, 57, 59, 45, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = []\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, f\"**/*{extension}\"),\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 42, 55, 54, 41, 45, 58, 46, 49], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if os.path.isfile(source_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = sorted(glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True))\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = \"{}-{}.{}\".format(filename, count, extension[1:])\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 42, 58, 53, 46, 51, 43, 59, 45, 55, 40, 50], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.isdir(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\"txt\", \"docx\", \"xlsx\", \"csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/*{extension}\")\n            os.path.join(source_directory, \"*\" + extension))\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 48, 39, 46, 45, 44, 58, 57, 54, 56, 43], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 51, 45, 49, 41, 44, 57, 50, 54, 42, 59], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory '{source_directory}' not found.\")\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in ['.txt', '.docx', '.xlsx', '.csv']:\n        filepaths = glob.glob(os.path.join(source_directory, \"*\" + extension))\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = os.path.basename(filepath)\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 41, 46, 50, 56, 43, 58, 40, 53], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(source_directory)\n    if not os.path.exists(target_directory):\n        os.mkdir(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 59, 54, 56, 43, 45, 52, 58, 40, 41, 50, 57], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(f\"Source directory {source_directory} not found.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory, exist_ok=True)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.iglob(f\"{source_directory}/*{extension}\", recursive=True)\n            os.path.join(source_directory, \"**\", \"*\" + extension), recursive=True\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(target_directory, filename)\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}.{filename}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [55, 46, 51, 43, 53, 40, 45], "result": {"code": "import os\nfrom pathlib import Path\nimport glob\nimport shutil\n\n\ndef task_func(source_directory: str, target_directory: str):\n    \"\"\"\n    Moves files with specific extensions from a source directory to a target directory,\n    handling naming conflicts by renaming duplicates.\n\n    Parameters:\n    - source_directory (str): The absolute or relative path of the source directory.\n    - target_directory (str): The absolute or relative path of the target directory.\n                              This function will create it if it does not exist.\n\n    Returns:\n    - int: The number of files successfully moved.\n\n    Raises:\n    - FileNotFoundError: If source_directory does not exist.\n\n    Requirements:\n    - os\n    - pathlib\n    - glob\n    - shutil\n\n    Notes:\n    - This function scans the source directory recursively to find files.\n    - Files are filtered by the extensions: \".txt\", \".docx\", \".xlsx\", \".csv\".\n    - Renaming of files due to naming conflicts follows the pattern '<original_name>-n.<extension>'.\n\n    Examples:\n    >>> task_func('./source_folder', './target_folder')\n    3\n    >>> task_func('./empty_folder', './target_folder')\n    0\n    \"\"\"\n    moved_files = 0\n    if not os.path.exists(source_directory):\n        raise FileNotFoundError(\"source_directory must exist.\")\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    for extension in [\".txt\", \".docx\", \".xlsx\", \".csv\"]:\n        filepaths = glob.glob(f\"{source_directory}/**/*.{extension}\", recursive=True)\n            os.path.join(\n        )\n        for filepath in filepaths:\n            filename = Path(filepath).name\n            stem = Path(filepath).stem\n            target_filepath = os.path.join(\n            count = 1\n            while os.path.exists(target_filepath):\n                new_filename = f\"{stem}-{count}{extension}\"\n                target_filepath = os.path.join(target_directory, new_filename)\n                count += 1\n            shutil.move(filepath, target_filepath)\n            moved_files += 1\n    return moved_files", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
