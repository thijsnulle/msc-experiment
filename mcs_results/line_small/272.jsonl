{"selected_lines": [57, 59, 34, 29, 41, 44, 60, 39, 35, 37, 52, 31, 47, 48, 49, 33, 53, 58, 56, 38, 45, 54, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Set status code as 400, Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 44, 46, 57, 31, 35, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.Handler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.015188932418823242, "tests_passed": true, "error": null}}
{"selected_lines": [46, 59, 35, 53, 60, 41, 44, 33, 39, 47, 43, 37, 48, 40, 29, 38, 54, 45, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Return a 400 error response\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>class MyCalc:", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 45, 37, 46, 57, 58, 39, 60, 43, 35, 54, 53, 49, 59, 31, 56, 34, 48, 29, 52, 40, 41, 38, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'Content-Type header is not application/json'})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('UTF-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful response\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/python", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 31, 29, 40, 45, 49, 53, 56, 47, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = f\"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0030400753021240234, "tests_passed": true, "error": null}}
{"selected_lines": [31, 33, 40, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 37, 33, 46, 41, 56, 49, 35, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/env python3", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 47, 44, 53, 56, 35, 37, 34, 52, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if not 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.004662036895751953, "tests_passed": true, "error": null}}
{"selected_lines": [38, 48, 59, 49, 43, 58, 31, 47, 41, 35, 44, 39, 29, 57, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.003495931625366211, "tests_passed": true, "error": null}}
{"selected_lines": [45, 29, 44, 31, 34, 54, 59, 40, 41, 39, 33, 60, 49, 35, 56, 57, 38, 48, 37, 47, 43, 46, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps(\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Content-Length', str(len(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 39, 38, 47, 58, 53, 31, 45, 54, 60, 43, 49, 33, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps(\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 44, 46, 47, 31, 49, 52, 58, 57, 48, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import math", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 29, 35, 33, 46, 39, 45, 52, 54, 47, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 29, 49, 31, 38, 44, 33, 56, 58, 54, 34, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid request.\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Content-length', len(json.dumps(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 39, 31, 41, 52, 33, 29, 47, 48, 56, 53, 45, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid Content-Type. Please send JSON data.\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Content-Length', str(len(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 54, 33, 46, 52, 45, 31, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 46, 34, 52, 41, 54, 57, 38, 56, 47, 40, 49, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Return a 400 error response\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0030100345611572266, "tests_passed": true, "error": null}}
{"selected_lines": [39, 38, 41, 57, 29, 52, 49, 46, 31, 34, 59, 43, 35, 53, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 means \"Bad Request\", a generic status code\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002736806869506836, "tests_passed": true, "error": null}}
{"selected_lines": [57, 43, 39, 44, 56, 48, 41, 37, 35, 29, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Invalid content type. Expected application/json.'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002463817596435547, "tests_passed": true, "error": null}}
{"selected_lines": [49, 33, 35, 38, 48, 53, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 53, 35, 56, 48, 34, 29, 49, 44, 57, 39, 58, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0028498172760009766, "tests_passed": true, "error": null}}
{"selected_lines": [40, 35, 54, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0025501251220703125, "tests_passed": true, "error": null}}
{"selected_lines": [45, 31, 38, 59, 43, 39, 56, 47, 54, 40, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002560853958129883, "tests_passed": true, "error": null}}
{"selected_lines": [29, 48, 56, 31, 60, 39, 57, 58, 54, 43, 53, 46, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 59, 46, 45, 29, 58, 40, 52, 47, 31, 41, 48, 38, 57, 33, 56, 53, 60, 35, 37, 44, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the request success\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [34, 54, 56, 47, 35, 59, 31, 40, 43, 45, 29, 49, 57, 39, 53, 37, 58, 33, 60, 46, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length')) if 'Content-Length' in self.headers else 0\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Content-Length', str(len(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023827552795410156, "tests_passed": true, "error": null}}
{"selected_lines": [40, 57, 31, 47, 45, 34, 56, 44, 48, 58, 29, 35, 52, 59, 46, 41, 43, 54, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0025718212127685547, "tests_passed": true, "error": null}}
{"selected_lines": [37, 35, 43, 29, 53, 31, 56, 59, 44, 49, 52, 58, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid HTTP request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0024499893188476562, "tests_passed": true, "error": null}}
{"selected_lines": [43, 29, 48, 57, 40, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPServer.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0024366378784179688, "tests_passed": true, "error": null}}
{"selected_lines": [49, 37, 33, 57, 56, 59, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':  # If Content-Type is not application/json, respond with an error\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 41, 59, 29, 46, 60, 54, 52, 49, 43, 37, 34, 44, 38, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022270679473876953, "tests_passed": true, "error": null}}
{"selected_lines": [46, 56, 54, 39, 29, 44, 49, 37, 38, 58, 43, 48, 57, 59, 34, 41, 47, 35, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0024099349975585938, "tests_passed": true, "error": null}}
{"selected_lines": [33, 46, 56, 45, 40, 58, 59, 44, 43, 60, 35, 29, 39, 53, 47, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import math", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [35, 53, 58, 40, 43, 29, 45, 48, 49, 60, 54, 31, 41, 37, 44, 47, 46, 34, 56, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Content-Length', str(len(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022399425506591797, "tests_passed": true, "error": null}}
{"selected_lines": [45, 41, 49, 31, 37, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002408266067504883, "tests_passed": true, "error": null}}
{"selected_lines": [60, 59, 31, 49, 58, 52, 45, 37, 44, 33, 56, 40, 48, 35, 34, 57, 54, 41, 38, 53, 39, 43, 29, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':  # If Content-Type is not application/json, respond with an error\n                self.send_response(400)  # Return a 400 error response\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful processing\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002275228500366211, "tests_passed": true, "error": null}}
{"selected_lines": [43, 56, 35, 48, 52, 31, 59, 33, 49, 60, 29, 46, 45, 54, 44, 38, 37, 39, 53, 34, 58, 41, 40, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [37, 44, 33, 46, 31, 47, 59, 40, 41, 54, 38, 58, 29, 39, 35, 34, 48, 56, 57, 45, 60, 43, 53, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = self.headers.getheaders('content-type')\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Invalid HTTP request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful processing\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [29, 56, 49, 34, 33, 43, 44, 57, 48, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid content type, expected application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 58, 35, 37, 57, 56, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0024459362030029297, "tests_passed": true, "error": null}}
{"selected_lines": [57, 45, 31, 39, 60, 41, 43, 37, 56, 44, 34, 33, 38, 49, 52, 54, 46, 59, 35, 29, 58, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the request success\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002290010452270508, "tests_passed": true, "error": null}}
{"selected_lines": [45, 29, 46, 58, 53, 43, 39, 35, 44, 38, 40, 48, 31, 33, 57, 41, 37, 60, 34, 54, 56, 47, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length')) if 'Content-Length' in self.headers else 0\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Content-length', len(json.dumps(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023758411407470703, "tests_passed": true, "error": null}}
{"selected_lines": [40, 31, 54, 43, 45, 34, 52, 59, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002259969711303711, "tests_passed": true, "error": null}}
{"selected_lines": [58, 47, 54, 37, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Content-Length', str(len(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0024080276489257812, "tests_passed": true, "error": null}}
{"selected_lines": [60, 49, 34, 44, 57, 35, 56, 48, 59, 31, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 31, 57, 60, 40, 45, 38, 44, 35, 49, 59, 41, 37, 33, 29, 53, 58, 39, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid JSON request.',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002233743667602539, "tests_passed": true, "error": null}}
{"selected_lines": [44, 54, 41, 43, 34, 46, 40, 37, 57, 49, 53, 60, 33, 38, 47, 35, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'No data received'})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)  # HTTP 400 - Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the request success\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 58, 49, 34, 60, 38, 59, 57, 40, 37, 54, 31, 45, 29, 44, 46, 48, 39, 33, 43, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps(\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.019624948501586914, "tests_passed": true, "error": null}}
{"selected_lines": [39, 49, 47, 31, 48, 54, 34, 40, 59, 56, 52, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0027027130126953125, "tests_passed": true, "error": null}}
{"selected_lines": [47, 33, 59, 48, 45, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 35, 44, 34, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002318859100341797, "tests_passed": true, "error": null}}
{"selected_lines": [52, 38, 29, 31, 45, 60, 48, 34, 53, 44, 46, 56, 37, 57, 43, 58, 54, 40, 39, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 means \"Bad Request\", a generic status code\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 38, 48, 57, 44, 60, 45, 35, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023300647735595703, "tests_passed": true, "error": null}}
{"selected_lines": [44, 46, 40, 60, 45, 41, 34, 48, 54, 53, 39, 33, 37, 52, 59, 56, 47, 57, 29, 49, 58, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPServer.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid request.\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 31, 53, 59, 60, 33, 40, 38, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {'status': 'error', 'message': 'Content-Type header is not application/json'}\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 means \"Bad Request\", a generic status code\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import math", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017239093780517578, "tests_passed": true, "error": null}}
{"selected_lines": [38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.022901058197021484, "tests_passed": true, "error": null}}
{"selected_lines": [46, 33, 52, 37, 39, 56, 60, 45, 48, 29, 38, 34, 47, 49, 41, 35, 44, 57, 54, 59, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022749900817871094, "tests_passed": true, "error": null}}
{"selected_lines": [57, 43, 38, 46, 49, 56, 34, 52, 53, 48, 31, 40, 39, 45, 33, 44, 60, 37, 47, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if not 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [39, 46, 60, 40, 48, 56, 35, 58, 47, 41, 37, 43, 52, 54, 33, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = f\"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>class MyCalc:", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 47, 45, 57, 38, 46, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>class MyCalc:", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 57, 49, 38, 43, 37, 58, 52, 46, 35, 56, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023500919342041016, "tests_passed": true, "error": null}}
{"selected_lines": [43, 52, 38, 29, 31, 56, 35, 39, 47, 59, 60, 49, 54, 40, 58, 53, 37, 48, 44, 45, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Invalid content type. Expected application/json.'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Content-length', len(json.dumps(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002300262451171875, "tests_passed": true, "error": null}}
{"selected_lines": [58, 52, 38, 44, 31, 29, 45, 60, 33, 46, 41, 47, 53, 59, 40, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid request.\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 29, 38, 46, 54, 44, 41, 33, 59, 39, 53, 57, 49, 47, 40, 37, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':  # Handle case when Content-Type header is not 'application/json'\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode('utf-8')\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 33, 31, 35, 43, 53, 54, 48, 59, 52, 38, 37, 47, 44, 29, 58, 45, 49, 60, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>class MyCalc:", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 31, 43, 49, 60, 29, 37, 48, 54, 40, 53, 33, 47, 59, 41, 56, 38, 44, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid content type, expected application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers['content-length'])\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 57, 39, 45, 38, 54, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023229122161865234, "tests_passed": true, "error": null}}
{"selected_lines": [38, 47, 43, 35, 40, 52, 29, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [33, 54, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid request.\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful processing\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01810312271118164, "tests_passed": true, "error": null}}
{"selected_lines": [43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017935991287231445, "tests_passed": true, "error": null}}
{"selected_lines": [58, 41, 31, 29, 57, 40, 33, 43, 52, 59, 56, 45, 44, 34, 54, 53, 35, 47, 38, 46, 37, 48, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Content-length', len(json.dumps(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 34, 37, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022058486938476562, "tests_passed": true, "error": null}}
{"selected_lines": [49, 46, 34, 60, 39, 48, 41, 40, 45, 59, 56, 44, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023870468139648438, "tests_passed": true, "error": null}}
{"selected_lines": [37, 52, 40, 59, 29, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':  # Handle case when Content-Type header is not 'application/json'\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002264261245727539, "tests_passed": true, "error": null}}
{"selected_lines": [37, 39, 52, 35, 53, 60, 59, 49, 41, 29, 44, 56, 45, 34, 48, 38, 33, 58, 57, 47, 31, 54, 40, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPServer.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'No data received'})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017567157745361328, "tests_passed": true, "error": null}}
{"selected_lines": [33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": false, "time": 0.00047707557678222656, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [60, 57, 35, 54, 56, 49, 41, 29, 58, 44, 43, 37, 46, 59, 40, 48, 33, 52, 34, 45, 31, 38, 53, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002276182174682617, "tests_passed": true, "error": null}}
{"selected_lines": [39, 38, 46, 59, 40, 49, 37, 54, 35, 48, 47, 53, 52, 57, 45, 60, 56, 29, 44, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>class MyCalc:", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 54, 40, 29, 57, 56, 37, 41, 39, 45, 46, 49, 60, 53, 48, 31, 38, 52, 43, 59, 47, 58, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Return a 400 error response\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers['content-length'])\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [29, 31, 46, 54, 59, 35, 49, 33, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.Handler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the request success\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31, 43, 35, 59, 40, 48, 54, 57, 56, 33, 39, 45, 46, 53, 60, 49, 58, 38, 41, 34, 37, 52, 44, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode('utf-8')\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful processing\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 44, 49, 52, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [34, 46, 45, 48, 29, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0024390220642089844, "tests_passed": true, "error": null}}
{"selected_lines": [53, 59, 39, 31, 38, 46, 29, 57, 45, 35, 40, 44, 54, 48, 56, 43, 47, 60, 37, 34, 49, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = self.headers.getheaders('content-type')\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid content type. Content-Type: application/json is required.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0026428699493408203, "tests_passed": true, "error": null}}
{"selected_lines": [60, 33, 29, 56, 41, 35, 54, 49, 53, 34, 37, 58, 44, 47, 59, 45, 31, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023889541625976562, "tests_passed": true, "error": null}}
{"selected_lines": [52, 46, 49, 33, 39, 35, 45, 58, 43, 54, 47, 31, 57, 53, 29, 38, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 49, 44, 39, 59, 31, 45, 58, 43, 29, 34, 41, 54, 57, 53, 37, 38, 60, 35, 48, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful response\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002549886703491211, "tests_passed": true, "error": null}}
{"selected_lines": [56, 48, 44, 57, 37, 31, 59, 49, 60, 45, 58, 35, 43, 41, 39, 34, 29, 53, 46, 38, 54, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.Handler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/env python3", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 47, 39, 54, 43, 57, 35, 56, 58, 53, 46, 45, 48, 40, 33, 60, 31, 49, 34, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = f\"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 59, 29, 31, 38, 56, 37, 52, 47, 33, 35, 40, 49, 44, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002329111099243164, "tests_passed": true, "error": null}}
{"selected_lines": [43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017452001571655273, "tests_passed": true, "error": null}}
{"selected_lines": [47, 41, 52, 46, 48, 44, 39, 33, 58, 49, 40, 29, 43, 59, 60, 37, 31, 34, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid Content-Type. Please send JSON data.\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 38, 40, 41, 37, 56, 53, 39, 35, 60, 47, 34, 48, 52, 45, 33, 43, 46, 29, 31, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid Content-Type. Please send JSON data.\"})\n                'status': 'error',\n                'message': 'Invalid HTTP request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 54, 39, 29, 35, 38, 53, 57, 46, 56, 33, 58, 60, 52, 45, 37, 34, 47, 43, 49, 59, 31, 41, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = self.headers.getheaders('content-type')\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid request.\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 47, 35, 46, 40, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0024771690368652344, "tests_passed": true, "error": null}}
{"selected_lines": [47, 43, 45, 49, 31, 44, 58, 53, 35, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.00251007080078125, "tests_passed": true, "error": null}}
{"selected_lines": [38, 45, 33, 34, 52, 59, 57, 49, 47, 37, 29, 53, 46, 54, 31, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid Content-Type. Please send JSON data.\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the request success\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [35, 54, 38, 52, 53, 49, 46, 45, 40, 48, 43, 47, 41, 29, 37, 56, 34, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if self.path == '/':  # if the path is '/' (the root directory),\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Invalid content type. Expected application/json.'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0025179386138916016, "tests_passed": true, "error": null}}
{"selected_lines": [43, 59, 57, 41, 33, 54, 34, 48, 44, 56, 53, 46, 52, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002331972122192383, "tests_passed": true, "error": null}}
{"selected_lines": [34, 49, 43, 58, 33, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0024750232696533203, "tests_passed": true, "error": null}}
{"selected_lines": [58, 46, 56, 45, 57, 31, 35, 47, 33, 41, 43, 52, 49, 40, 34, 48, 39, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023450851440429688, "tests_passed": true, "error": null}}
{"selected_lines": [31, 41, 48, 53, 33, 44, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0026102066040039062, "tests_passed": true, "error": null}}
{"selected_lines": [57, 53, 33, 47, 40, 59, 56, 52, 45, 37, 34, 43, 31, 46, 41, 54, 58, 39, 48, 38, 49, 29, 60, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'No data received'})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 46, 31, 33, 35, 47, 58, 44, 43, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023741722106933594, "tests_passed": true, "error": null}}
{"selected_lines": [35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017130136489868164, "tests_passed": true, "error": null}}
{"selected_lines": [29, 40, 46, 53, 49, 52, 35, 43, 45, 38, 57, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002807140350341797, "tests_passed": true, "error": null}}
{"selected_lines": [35, 47, 29, 45, 56, 59, 31, 41, 49, 46, 39, 52, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid JSON request.',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002425670623779297, "tests_passed": true, "error": null}}
{"selected_lines": [48, 40, 49, 45, 35, 54, 60, 59, 37, 29, 34, 58, 56, 44, 31, 53, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002424955368041992, "tests_passed": true, "error": null}}
{"selected_lines": [47, 37, 57, 44, 46, 56, 54, 58, 34, 33, 40, 45, 39, 48, 31, 29, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'Content-Type header is not application/json'})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 49, 34, 52, 43, 29, 35, 54, 33, 56, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022017955780029297, "tests_passed": true, "error": null}}
{"selected_lines": [37, 47, 45, 29, 34, 57, 56, 43, 38, 41, 40, 31, 59, 35, 46, 52, 58, 44, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import cgi", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [29, 52, 45, 60, 34, 56, 41, 33, 58, 38, 35, 44, 48, 54, 39, 53, 40, 37, 31, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid request.\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 40, 37, 58, 39, 47, 43, 29, 60, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [37, 38, 45, 54, 43, 52, 35, 31, 48, 46, 47, 39, 58, 49, 60, 29, 34, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid Content-Type: {}, Expected: application/json'.format(ctype)\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002310037612915039, "tests_passed": true, "error": null}}
{"selected_lines": [58, 59, 43, 29, 38, 54, 41, 46, 47, 53, 31, 57, 49, 37, 56, 60, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful response\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002173900604248047, "tests_passed": true, "error": null}}
{"selected_lines": [35, 45, 57, 46, 59, 53, 41, 48, 44, 54, 38, 58, 52, 43, 33, 37, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if not isinstance(message, dict):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023920536041259766, "tests_passed": true, "error": null}}
{"selected_lines": [33, 34, 37, 54, 31, 39, 58, 29, 49, 46, 43, 38, 60, 35, 48, 57, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length')) if 'Content-Length' in self.headers else 0\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 31, 53, 40, 43, 47, 33, 59, 41, 39, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = f\"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002315044403076172, "tests_passed": true, "error": null}}
{"selected_lines": [31, 33, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid request.\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [29, 31, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.00226593017578125, "tests_passed": true, "error": null}}
{"selected_lines": [37, 48, 56, 33, 53, 35, 29, 52, 54, 34, 31, 44, 47, 41, 43, 45, 59, 46, 40, 38, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Invalid Content-Type: {}, Expected: application/json'.format(ctype)\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Invalid content type. Expected application/json.'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31, 59, 52, 39, 34, 45, 44, 49, 43, 54, 47, 35, 56, 41, 60, 33, 38, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # HTTP 400 - Bad Request\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/env python3", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 59, 57, 35, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid Content-Type header'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002196073532104492, "tests_passed": true, "error": null}}
{"selected_lines": [57, 44, 43, 38, 56, 34, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023648738861083984, "tests_passed": true, "error": null}}
{"selected_lines": [34, 54, 57, 39, 44, 45, 60, 40, 59, 56, 29, 43, 37, 53, 38, 47, 46, 35, 52, 31, 33, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {'status': 'error', 'message': 'Content-Type header is not application/json'}\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 34, 37, 48, 38, 53, 54, 33, 46, 41, 49, 44, 43, 29, 35, 47, 57, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Invalid Content-Type header'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)  # 400 means \"Bad Request\", a generic status code\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 47, 53, 54, 43, 44, 60, 34, 29, 46, 37, 33, 39, 52, 56, 38, 49, 58, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful response\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/python", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [37, 53, 29, 41, 60, 34, 35, 40, 56, 45, 59, 52, 43, 38, 49, 46, 44, 39, 54, 58, 33, 47, 31, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid HTTP request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022592544555664062, "tests_passed": true, "error": null}}
{"selected_lines": [58, 29, 59, 48, 45, 52, 44, 54, 57, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023500919342041016, "tests_passed": true, "error": null}}
{"selected_lines": [44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01810312271118164, "tests_passed": true, "error": null}}
{"selected_lines": [33, 39, 34, 37, 54, 47, 35, 48, 43, 56, 46, 44, 60, 59, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':  # If Content-Type is not application/json, respond with an error\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 54, 34, 41, 35, 49, 60, 53, 33, 43, 58, 29, 46, 39, 44, 31, 40, 45, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {'status': 'error', 'message': 'Content-Type header is not application/json'}\n                'status': 'error',\n                'message': 'Invalid content type. Content-Type: application/json is required.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 57, 34, 41, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022590160369873047, "tests_passed": true, "error": null}}
{"selected_lines": [45, 60, 56, 38, 33, 46, 40, 48, 54, 52, 47, 57, 58, 49, 34, 44, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # HTTP 400 - Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful processing\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Content-length', len(json.dumps(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023381710052490234, "tests_passed": true, "error": null}}
{"selected_lines": [39, 48, 35, 34, 52, 53, 47, 43, 37, 33, 56, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 29, 38, 57, 56, 41, 37, 53, 52, 48, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022459030151367188, "tests_passed": true, "error": null}}
{"selected_lines": [45, 47, 48, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022830963134765625, "tests_passed": true, "error": null}}
{"selected_lines": [35, 56, 34, 45, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002177000045776367, "tests_passed": true, "error": null}}
{"selected_lines": [34, 38, 41, 45, 37, 49, 47, 40, 43, 56, 54, 57, 59, 35, 33, 53, 31, 60, 48, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Invalid Content-Type: {}, Expected: application/json'.format(ctype)\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [35, 44, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid HTTP request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022699832916259766, "tests_passed": true, "error": null}}
{"selected_lines": [33, 35, 47, 46, 34, 44, 39, 56, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 56, 48, 49, 40, 41, 29, 37, 59, 38, 57, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002135038375854492, "tests_passed": true, "error": null}}
{"selected_lines": [53, 52, 57, 45, 46, 43, 54, 39, 60, 48, 33, 40, 44, 58, 29, 59, 47, 49, 41, 35, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022840499877929688, "tests_passed": true, "error": null}}
{"selected_lines": [45, 56, 49, 54, 44, 46, 38, 60, 31, 39, 41, 29, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = self.headers.getheaders('content-type')\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002207040786743164, "tests_passed": true, "error": null}}
{"selected_lines": [60, 40, 41, 47, 43, 49, 46, 48, 56, 59, 52, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002293109893798828, "tests_passed": true, "error": null}}
{"selected_lines": [58, 29, 38, 47, 41, 45, 46, 35, 37, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if self.path == '/':  # if the path is '/' (the root directory),\n                self.send_response(400)  # Return a 400 error response\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002157926559448242, "tests_passed": true, "error": null}}
{"selected_lines": [37, 53, 60, 57, 48, 34, 56, 39, 46, 58, 31, 49, 29, 40, 45, 47, 41, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Content-Length', str(len(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>class MyCalc:", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 47, 54, 41, 34, 35, 46, 56, 38, 58, 33, 44, 48, 45, 43, 37, 59, 39, 57, 40, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 39, 45, 31, 44, 43, 37, 33, 40, 47, 29, 58, 46, 60, 54, 52, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPServer.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import cgi", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [34, 35, 41, 43, 58, 54, 59, 48, 47, 29, 56, 37, 33, 38, 52, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002626657485961914, "tests_passed": true, "error": null}}
{"selected_lines": [56, 35, 46, 43, 59, 52, 44, 37, 33, 49, 34, 31, 47, 39, 57, 45, 29, 38, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002187967300415039, "tests_passed": true, "error": null}}
{"selected_lines": [29, 49, 54, 45, 43, 38, 53, 44, 41, 37, 33, 52, 46, 35, 34, 31, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 46, 33, 58, 53, 39, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [34, 37, 59, 54, 53, 57, 31, 47, 40, 38, 49, 29, 39, 56, 46, 43, 60, 33, 52, 58, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid request.\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/env python3", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 41, 29, 60, 46, 44, 33, 43, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import cgi", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [29, 46, 39, 59, 53, 47, 41, 60, 37, 54, 40, 31, 43, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = self.headers.getheaders('content-type')\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002285003662109375, "tests_passed": true, "error": null}}
{"selected_lines": [31, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.00220489501953125, "tests_passed": true, "error": null}}
{"selected_lines": [37, 45, 29, 57, 43, 46, 49, 38, 53, 44, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':  # Handle case when Content-Type header is not 'application/json'\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length')) if 'Content-Length' in self.headers else 0\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002315998077392578, "tests_passed": true, "error": null}}
{"selected_lines": [47, 59, 37, 53, 38, 56, 31, 54, 34, 41, 45, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)  # HTTP 400 - Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022509098052978516, "tests_passed": true, "error": null}}
{"selected_lines": [45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017239093780517578, "tests_passed": true, "error": null}}
{"selected_lines": [44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01810312271118164, "tests_passed": true, "error": null}}
{"selected_lines": [48, 39, 53, 33, 52, 34, 35, 37, 41, 29, 56, 31, 57, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid content type, expected application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if self.path == '/':  # if the path is '/' (the root directory),\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [38, 58, 47, 57, 54, 40, 46, 31, 39, 56, 34, 37, 43, 52, 35, 49, 53, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = f\"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023441314697265625, "tests_passed": true, "error": null}}
{"selected_lines": [57, 37, 44, 45, 29, 52, 31, 54, 46, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002146005630493164, "tests_passed": true, "error": null}}
{"selected_lines": [46, 57, 52, 44, 37, 35, 34, 41, 58, 56, 39, 54, 53, 40, 49, 45, 31, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if self.path == '/':  # if the path is '/' (the root directory),\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022940635681152344, "tests_passed": true, "error": null}}
{"selected_lines": [45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017239093780517578, "tests_passed": true, "error": null}}
{"selected_lines": [35, 41, 31, 46, 33, 47, 53, 37, 56, 34, 57, 38, 48, 60, 43, 58, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017130136489868164, "tests_passed": true, "error": null}}
{"selected_lines": [54, 60, 37, 43, 58, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers['content-length'])\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/python", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [34, 59, 52, 60, 48, 49, 56, 41, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>class MyCalc:", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 43, 39, 53, 59, 40, 33, 47, 35, 31, 56, 48, 60, 44, 49, 37, 52, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Invalid JSON request.',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import math", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 41, 45, 54, 29, 60, 34, 43, 56, 46, 33, 31, 47, 49, 57, 40, 35, 53, 38, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'}\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [37, 59, 47, 29, 60, 57, 56, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002207040786743164, "tests_passed": true, "error": null}}
{"selected_lines": [40, 41, 53, 44, 56, 52, 43, 48, 49, 31, 34, 33, 57, 47, 45, 54, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023369789123535156, "tests_passed": true, "error": null}}
{"selected_lines": [60, 56, 49, 59, 43, 58, 38, 35, 41, 54, 57, 53, 48, 40, 29, 39, 34, 46, 33, 52, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022170543670654297, "tests_passed": true, "error": null}}
{"selected_lines": [43, 59, 29, 34, 60, 53, 57, 52, 38, 58, 47, 48, 46, 35, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Content-length', len(json.dumps(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023071765899658203, "tests_passed": true, "error": null}}
{"selected_lines": [38, 59, 45, 54, 47, 48, 41, 43, 29, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002246856689453125, "tests_passed": true, "error": null}}
{"selected_lines": [58, 57, 39, 45, 38, 54, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023229122161865234, "tests_passed": true, "error": null}}
{"selected_lines": [44, 31, 45, 57, 43, 37, 41, 48, 59, 53, 54, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002296924591064453, "tests_passed": true, "error": null}}
{"selected_lines": [37, 44, 54, 41, 40, 48, 29, 47, 60, 39, 49, 34, 31, 43, 53, 38, 58, 57, 52, 35, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022199153900146484, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [41, 33, 43, 48, 53, 58, 40, 54, 39, 31, 44, 56, 34, 49, 46, 29, 38, 37, 60, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid HTTP request'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023260116577148438, "tests_passed": true, "error": null}}
{"selected_lines": [37, 47, 40, 60, 31, 44, 41, 43, 58, 39, 38, 29, 46, 52, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [35, 52, 37, 46, 45, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if self.headers.get('content-type') != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002223968505859375, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [60, 44, 43, 33, 53, 59, 54, 57, 46, 38, 37, 41, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 60, 52, 56, 54, 34, 37, 44, 40, 47, 35, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode('utf-8')\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023162364959716797, "tests_passed": true, "error": null}}
{"selected_lines": [60, 33, 44, 58, 40, 57, 35, 46, 38, 49, 59, 41, 39, 52, 48, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import math", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 58, 38, 46, 29, 60, 39, 45, 48, 49, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022139549255371094, "tests_passed": true, "error": null}}
{"selected_lines": [54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.02033519744873047, "tests_passed": true, "error": null}}
{"selected_lines": [29, 47, 43, 48, 44, 49, 39, 41, 60, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002310037612915039, "tests_passed": true, "error": null}}
{"selected_lines": [29, 39, 54, 45, 35, 40, 53, 52, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid content type. Content-Type: application/json is required.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022268295288085938, "tests_passed": true, "error": null}}
{"selected_lines": [44, 57, 48, 54, 35, 29, 45, 46, 60, 41, 53, 33, 56, 39, 47, 38, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful processing\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002228975296020508, "tests_passed": true, "error": null}}
{"selected_lines": [41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.016691923141479492, "tests_passed": true, "error": null}}
{"selected_lines": [53, 37, 31, 34, 35, 40, 60, 41, 52, 59, 29, 56, 49, 48, 58, 38, 46, 44, 39, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = self.headers.getheaders('content-type')\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid Content-Type header'\n            }\n            if ctype != 'application/json':  # If Content-Type is not application/json, respond with an error\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021986961364746094, "tests_passed": true, "error": null}}
{"selected_lines": [39, 34, 46, 58, 33, 53, 40, 52, 44, 35, 29, 47, 56, 38, 37, 57, 43, 54, 48, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002553701400756836, "tests_passed": true, "error": null}}
{"selected_lines": [33, 31, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {'status': 'error', 'message': 'Content-Type header is not application/json'}\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 58, 56, 34, 46, 38, 43, 33, 57, 35, 48, 49, 60, 44, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid Content-Type: {}, Expected: application/json'.format(ctype)\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import math", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [34, 54, 44, 56, 43, 40, 49, 39, 48, 38, 41, 29, 47, 57, 31, 35, 53, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 means \"Bad Request\", a generic status code\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002259969711303711, "tests_passed": true, "error": null}}
{"selected_lines": [35, 43, 39, 60, 58, 57, 31, 53, 47, 48, 40, 49, 34, 38, 45, 59, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023047924041748047, "tests_passed": true, "error": null}}
{"selected_lines": [54, 38, 53, 45, 44, 46, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021741390228271484, "tests_passed": true, "error": null}}
{"selected_lines": [39, 54, 44, 57, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022406578063964844, "tests_passed": true, "error": null}}
{"selected_lines": [45, 39, 41, 53, 43, 29, 44, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = self.headers.getheaders('content-type')\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002178192138671875, "tests_passed": true, "error": null}}
{"selected_lines": [29, 59, 31, 58, 46, 54, 41, 47, 43, 60, 52, 40, 38, 57, 45, 35, 48, 37, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = self.headers.getheaders('content-type')\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid Content-Type: {}, Expected: application/json'.format(ctype)\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful response\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import math", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 52, 31, 38, 53, 56, 46, 40, 34, 49, 33, 58, 47, 59, 48, 43, 39, 35, 41, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid Content-Type header'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023238658905029297, "tests_passed": true, "error": null}}
{"selected_lines": [57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.018255949020385742, "tests_passed": true, "error": null}}
{"selected_lines": [45, 35, 58, 48, 53, 59, 31, 41, 60, 57, 43, 39, 52, 44, 38, 37, 40, 34, 47, 29, 33, 56, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid request.\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Set status code as 400, Bad Request\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 46, 52, 37, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021829605102539062, "tests_passed": true, "error": null}}
{"selected_lines": [40, 49, 44, 45, 33, 53, 48, 47, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps(\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 38, 29, 54, 37, 31, 46, 53, 43, 52, 60, 44, 59, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Content-length', len(json.dumps(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/python", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 43, 46, 35, 49, 41, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022940635681152344, "tests_passed": true, "error": null}}
{"selected_lines": [35, 29, 58, 59, 47, 40, 41, 49, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002197742462158203, "tests_passed": true, "error": null}}
{"selected_lines": [29, 49, 45, 44, 33, 43, 60, 47, 59, 39, 35, 38, 53, 46, 48, 54, 56, 34, 37, 58, 52, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Set status code as 400, Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023741722106933594, "tests_passed": true, "error": null}}
{"selected_lines": [54, 53, 37, 34, 47, 29, 48, 44, 40, 46, 56, 33, 60, 52, 49, 59, 41, 38, 58, 39, 31, 43, 57, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if not isinstance(message, dict):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002192974090576172, "tests_passed": true, "error": null}}
{"selected_lines": [34, 59, 60, 35, 37, 43, 46, 38, 40, 44, 54, 56, 57, 49, 29, 48, 31, 52, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022857189178466797, "tests_passed": true, "error": null}}
{"selected_lines": [52, 31, 44, 46, 40, 41, 35, 33, 47, 43, 49, 45, 54, 34, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 31, 38, 41, 60, 58, 40, 59, 49, 44, 48, 47, 35, 54, 33, 29, 34, 45, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {'status': 'error', 'message': 'Content-Type header is not application/json'}\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 45, 49, 44, 53, 35, 33, 43, 38, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers['content-length'])\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022232532501220703, "tests_passed": true, "error": null}}
{"selected_lines": [53, 60, 59, 31, 48, 39, 38, 40, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 means \"Bad Request\", a generic status code\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022859573364257812, "tests_passed": true, "error": null}}
{"selected_lines": [56, 29, 35, 54, 41, 60, 31, 38, 57, 48, 52, 53, 49, 43, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'}\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 59, 34, 29, 33, 54, 46, 38, 48, 52, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [33, 46, 56, 43, 37, 60, 53, 57, 47, 38, 44, 39, 52, 48, 29, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 52, 44, 48, 54, 33, 41, 38, 46, 47, 37, 39, 43, 56, 49, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022351741790771484, "tests_passed": true, "error": null}}
{"selected_lines": [53, 59, 57, 52, 47, 58, 48, 40, 37, 29, 46, 43, 38, 49, 35, 45, 60, 54, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid HTTP request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002262115478515625, "tests_passed": true, "error": null}}
{"selected_lines": [35, 47, 37, 38, 39, 56, 52, 29, 31, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid HTTP request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022089481353759766, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [52, 35, 33, 44, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps(\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 57, 54, 58, 38, 60, 49, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022382736206054688, "tests_passed": true, "error": null}}
{"selected_lines": [46, 49, 40, 59, 35, 34, 44, 45, 54, 37, 60, 29, 38, 58, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid JSON request.',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022101402282714844, "tests_passed": true, "error": null}}
{"selected_lines": [43, 34, 56, 58, 33, 41, 40, 47, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Content-length', len(json.dumps(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 57, 34, 35, 52, 58, 44, 53, 40, 56, 29, 31, 38, 60, 37, 48, 47, 33, 54, 39, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps(\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful response\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01810312271118164, "tests_passed": true, "error": null}}
{"selected_lines": [47, 49, 34, 60, 38, 44, 43, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Return a 400 error response\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023560523986816406, "tests_passed": true, "error": null}}
{"selected_lines": [46, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/env python3", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [34, 49, 43, 58, 33, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0024750232696533203, "tests_passed": true, "error": null}}
{"selected_lines": [33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": false, "time": 0.00023126602172851562, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [46, 43, 41, 58, 59, 60, 37, 47, 35, 52, 33, 38, 40, 56, 53, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/python", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31, 34, 58, 47, 56, 52, 39, 29, 57, 48, 60, 59, 49, 46, 44, 41, 43, 37, 33, 54, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Content-length', len(json.dumps(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022110939025878906, "tests_passed": true, "error": null}}
{"selected_lines": [48, 52, 57, 56, 43, 29, 44, 54, 33, 47, 39, 53, 59, 34, 40, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31, 53, 38, 37, 54, 57, 47, 56, 59, 58, 29, 40, 45, 49, 46, 39, 41, 48, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31, 47, 48, 58, 40, 46, 39, 60, 52, 43, 38, 53, 34, 41, 44, 29, 56, 45, 35, 33, 49, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {'status': 'error', 'message': 'Content-Type header is not application/json'}\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.018255949020385742, "tests_passed": true, "error": null}}
{"selected_lines": [44, 46, 57, 40, 29, 38, 47, 60, 54, 33, 37, 56, 49, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [39, 53, 58, 46, 56, 43, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers['content-length'])\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023250579833984375, "tests_passed": true, "error": null}}
{"selected_lines": [35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017130136489868164, "tests_passed": true, "error": null}}
{"selected_lines": [33, 29, 41, 47, 40, 38, 49, 52, 35, 43, 53, 60, 46, 37, 54, 57, 44, 39, 34, 48, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length')) if 'Content-Length' in self.headers else 0\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 60, 47, 33, 57, 52, 41, 53, 46, 43, 58, 48, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'No data received'})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.019032001495361328, "tests_passed": true, "error": null}}
{"selected_lines": [48, 49, 54, 46, 39, 31, 41, 59, 38, 52, 43, 58, 40, 60, 57, 45, 29, 35, 33, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 39, 41, 37, 59, 38, 48, 56, 52, 40, 46, 60, 34, 58, 47, 33, 31, 54, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import math", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 38, 29, 31, 44, 33, 47, 60, 52, 48, 59, 35, 34, 43, 40, 37, 56, 57, 49, 54, 45, 53, 58, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid HTTP POST request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Invalid content type. Expected application/json.'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002218961715698242, "tests_passed": true, "error": null}}
{"selected_lines": [44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01810312271118164, "tests_passed": true, "error": null}}
{"selected_lines": [53, 52, 59, 39, 34, 33, 43, 46, 41, 38, 57, 47, 54, 60, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps(\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 44, 47, 35, 52, 40, 31, 33, 58, 37, 45, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002546072006225586, "tests_passed": true, "error": null}}
{"selected_lines": [57, 58, 37, 47, 31, 34, 49, 44, 43, 46, 59, 54, 56, 38, 39, 41, 40, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002218008041381836, "tests_passed": true, "error": null}}
{"selected_lines": [34, 54, 44, 31, 53, 37, 41, 59, 43, 48, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = self.headers.getheaders('content-type')\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022249221801757812, "tests_passed": true, "error": null}}
{"selected_lines": [53, 47, 38, 59, 46, 60, 54, 43, 56, 49, 39, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021791458129882812, "tests_passed": true, "error": null}}
{"selected_lines": [38, 57, 34, 59, 58, 46, 60, 49, 29, 37, 53, 33, 31, 47, 48, 40, 56, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid Content-Type. Please send JSON data.\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 35, 41, 57, 58, 53, 54, 39, 43, 40, 45, 33, 44, 60, 52, 46, 37, 34, 31, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Content-Length', str(len(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023391246795654297, "tests_passed": true, "error": null}}
{"selected_lines": [33, 57, 38, 29, 53, 47, 45, 46, 48, 58, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Content-length', len(json.dumps(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022199153900146484, "tests_passed": true, "error": null}}
{"selected_lines": [31, 34, 53, 54, 48, 47, 38, 57, 49, 29, 35, 59, 56, 46, 37, 40, 52, 45, 44, 33, 60, 41, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 33, 49, 52, 37, 34, 43, 56, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 39, 56, 38, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002274036407470703, "tests_passed": true, "error": null}}
{"selected_lines": [52, 48, 40, 35, 33, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps(\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [35, 47, 38, 48, 54, 57, 34, 44, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid HTTP POST request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021681785583496094, "tests_passed": true, "error": null}}
{"selected_lines": [58, 35, 60, 45, 44, 49, 52, 38, 53, 56, 34, 41, 39, 43, 29, 54, 57, 48, 59, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import cgi", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 52, 37, 39, 29, 48, 34, 38, 47, 41, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022499561309814453, "tests_passed": true, "error": null}}
{"selected_lines": [31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01890420913696289, "tests_passed": true, "error": null}}
{"selected_lines": [41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.022449016571044922, "tests_passed": true, "error": null}}
{"selected_lines": [39, 53, 54, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022127628326416016, "tests_passed": true, "error": null}}
{"selected_lines": [54, 60, 47, 29, 52, 59, 48, 45, 41, 57, 34, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import cgi", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 38, 41, 35, 54, 29, 45, 40, 39, 56, 48, 58, 33, 44, 49, 46, 53, 34, 59, 57, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid Content-Type: {}, Expected: application/json'.format(ctype)\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023407936096191406, "tests_passed": true, "error": null}}
{"selected_lines": [43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017935991287231445, "tests_passed": true, "error": null}}
{"selected_lines": [40, 44, 56, 49, 47, 58, 46, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002255678176879883, "tests_passed": true, "error": null}}
{"selected_lines": [48, 41, 53, 34, 29, 31, 33, 39, 46, 43, 40, 54, 49, 52, 35, 44, 59, 56, 58, 60, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'No data received'})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 46, 44, 35, 53, 45, 47, 57, 59, 37, 34, 29, 48, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.Handler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002302885055541992, "tests_passed": true, "error": null}}
{"selected_lines": [41, 40, 39, 33, 47, 34, 52, 48, 43, 37, 35, 59, 31, 29, 54, 49, 53, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers['content-length'])\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.02212381362915039, "tests_passed": true, "error": null}}
{"selected_lines": [29, 52, 35, 53, 54, 41, 37, 57, 48, 31, 43, 39, 56, 58, 40, 34, 59, 49, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':  # If Content-Type is not application/json, respond with an error\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Invalid content type. Expected application/json.'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002276182174682617, "tests_passed": true, "error": null}}
{"selected_lines": [49, 39, 46, 45, 40, 38, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Invalid content type. Expected application/json.'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002379894256591797, "tests_passed": true, "error": null}}
{"selected_lines": [47, 46, 38, 54, 31, 40, 53, 49, 56, 48, 41, 59, 29, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022780895233154297, "tests_passed": true, "error": null}}
{"selected_lines": [29, 58, 41, 45, 34, 57, 46, 43, 38, 39, 33, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [34, 59, 41, 47, 54, 60, 35, 58, 39, 43, 45, 48, 38, 52, 37, 31, 46, 49, 29, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':  # If Content-Type is not application/json, respond with an error\n                self.send_response(400)  # Set status code as 400, Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.018255949020385742, "tests_passed": true, "error": null}}
{"selected_lines": [37, 45, 48, 58, 38, 47, 52, 59, 41, 39, 31, 40, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)  # Bad Request\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Invalid content type. Expected application/json.'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002863168716430664, "tests_passed": true, "error": null}}
{"selected_lines": [48, 52, 37, 31, 47, 58, 49, 60, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0046689510345458984, "tests_passed": true, "error": null}}
{"selected_lines": [41, 43, 53, 59, 57, 33, 60, 45, 54, 48, 47, 58, 56, 37, 46, 44, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Content-length', len(json.dumps(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 45, 41, 43, 48, 31, 39, 40, 57, 60, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import cgi", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.016691923141479492, "tests_passed": true, "error": null}}
{"selected_lines": [59, 39, 56, 49, 43, 52, 38, 53, 35, 47, 48, 54, 44, 33, 31, 57, 46, 37, 60, 45, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Invalid content type. Expected application/json.'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful processing\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.003921031951904297, "tests_passed": true, "error": null}}
{"selected_lines": [49, 35, 48, 41, 53, 31, 47, 56, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid Content-Type: {}, Expected: application/json'.format(ctype)\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0030410289764404297, "tests_passed": true, "error": null}}
{"selected_lines": [56, 46, 52, 43, 58, 39, 31, 29, 40, 45, 44, 33, 34, 48, 57, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Invalid content type. Expected application/json.'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.02008795738220215, "tests_passed": true, "error": null}}
{"selected_lines": [31, 38, 39, 35, 59, 43, 46, 49, 53, 33, 37, 41, 60, 47, 54, 56, 45, 44, 29, 52, 58, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid request.\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful response\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [35, 38, 43, 53, 31, 33, 49, 57, 40, 60, 48, 37, 59, 56, 45, 29, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Invalid HTTP POST request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31, 38, 40, 39, 34, 49, 57, 59, 54, 41, 52, 35, 45, 53, 44, 48, 47, 56, 60, 37, 29, 58, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = f\"Content-Type header is not application/json\"\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0027036666870117188, "tests_passed": true, "error": null}}
{"selected_lines": [31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.018212080001831055, "tests_passed": true, "error": null}}
{"selected_lines": [41, 29, 47, 34, 38, 54, 49, 52, 59, 39, 33, 53, 60, 48, 35, 43, 58, 56, 40, 46, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'Content-Type header is not application/json'})\n                'status': 'error',\n                'message': 'Invalid HTTP request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # HTTP 400 - Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 52, 46, 47, 41, 57, 39, 59, 58, 34, 38, 60, 48, 31, 37, 56, 45, 29, 35, 43, 53, 49, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [35, 29, 33, 37, 31, 43, 44, 49, 47, 46, 45, 34, 38, 59, 57, 40, 52, 39, 60, 41, 48, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = self.headers.getheaders('content-type')\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/env python3", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 41, 60, 54, 29, 48, 38, 49, 59, 53, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.Handler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002541065216064453, "tests_passed": true, "error": null}}
{"selected_lines": [44, 59, 54, 45, 38, 43, 29, 31, 34, 46, 52, 56, 37, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length).decode()\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002526998519897461, "tests_passed": true, "error": null}}
{"selected_lines": [40, 56, 41, 35, 46, 53, 45, 39, 34, 52, 47, 57, 48, 43, 33, 59, 44, 58, 29, 38, 31, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid Content-Type. Please send JSON data.\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('UTF-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode('utf-8')\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Content-Length', str(len(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 52, 37, 33, 34, 35, 45, 40, 57, 41, 46, 59, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [37, 40, 38, 34, 41, 45, 54, 43, 47, 57, 52, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002371072769165039, "tests_passed": true, "error": null}}
{"selected_lines": [35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.018169641494750977, "tests_passed": true, "error": null}}
{"selected_lines": [60, 53, 41, 56, 43, 37, 29, 58, 54, 59, 39, 47, 31, 38, 57, 46, 45, 48, 34, 49, 44, 40, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/python", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017567157745361328, "tests_passed": true, "error": null}}
{"selected_lines": [29, 52, 37, 35, 46, 59, 43, 58, 53, 54, 34, 39, 38, 33, 31, 48, 44, 56, 60, 41, 49, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the request success\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 45, 53, 34, 41, 44, 52, 58, 59, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.003172159194946289, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [41, 31, 34, 58, 60, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023810863494873047, "tests_passed": true, "error": null}}
{"selected_lines": [40, 46, 59, 53, 49, 41, 57, 48, 58, 39, 44, 43, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017935991287231445, "tests_passed": true, "error": null}}
{"selected_lines": [54, 56, 48, 46, 34, 37, 40, 38, 39, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002585172653198242, "tests_passed": true, "error": null}}
{"selected_lines": [31, 48, 33, 41, 38, 49, 44, 46, 37, 39, 47, 53, 40, 52, 45, 57, 58, 59, 34, 60, 29, 56, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Return a 400 error response\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 54, 46, 57, 58, 41, 38, 45, 60, 49, 40, 44, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if not 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002390146255493164, "tests_passed": true, "error": null}}
{"selected_lines": [48, 56, 58, 53, 41, 57, 49, 33, 31, 52, 44, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid Content-Type. Please send JSON data.\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 40, 33, 49, 54, 31, 29, 35, 39, 58, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Invalid Content-Type header'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 53, 33, 49, 39, 57, 47, 37, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 31, 45, 38, 46, 47, 53, 35, 60, 59, 40, 49, 29, 54, 34, 44, 37, 56, 57, 48, 39, 52, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0025322437286376953, "tests_passed": true, "error": null}}
{"selected_lines": [41, 58, 45, 44, 39, 56, 38, 46, 35, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0025420188903808594, "tests_passed": true, "error": null}}
{"selected_lines": [43, 57, 54, 59, 31, 41, 38, 48, 35, 56, 44, 33, 40, 34, 37, 39, 53, 47, 49, 52, 60, 58, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [34, 40, 47, 31, 43, 48, 57, 54, 35, 49, 44, 41, 37, 39, 45, 29, 53, 60, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':  # Handle case when Content-Type header is not 'application/json'\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful response\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002445220947265625, "tests_passed": true, "error": null}}
{"selected_lines": [39, 45, 33, 48, 57, 29, 47, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 54, 45, 58, 37, 29, 31, 33, 34, 48, 41, 53, 46, 49, 38, 56, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'No data received'})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':  # If Content-Type is not application/json, respond with an error\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful response\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [34, 57, 43, 40, 29, 59, 31, 53, 45, 44, 56, 39, 41, 37, 33, 60, 58, 54, 38, 46, 49, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {'status': 'error', 'message': 'Content-Type header is not application/json'}\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/env python3", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [40, 44, 53, 34, 56, 45, 60, 43, 54, 52, 38, 37, 46, 57, 58, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)  # Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>class MyCalc:", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 41, 45, 39, 29, 35, 52, 40, 37, 58, 47, 54, 59, 43, 46, 56, 49, 31, 44, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid Content-Type header'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002228975296020508, "tests_passed": true, "error": null}}
{"selected_lines": [58, 49, 38, 54, 40, 44, 39, 45, 57, 52, 46, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if self.path == '/':  # if the path is '/' (the root directory),\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = f\"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002338886260986328, "tests_passed": true, "error": null}}
{"selected_lines": [43, 47, 35, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid Content-Type header'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length')) if 'Content-Length' in self.headers else 0\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021991729736328125, "tests_passed": true, "error": null}}
{"selected_lines": [38, 37, 34, 40, 43, 52, 29, 56, 49, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if self.headers.get('content-type') != 'application/json':\n                self.send_response(400)  # HTTP 400 - Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023009777069091797, "tests_passed": true, "error": null}}
{"selected_lines": [29, 54, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002214193344116211, "tests_passed": true, "error": null}}
{"selected_lines": [40, 43, 29, 49, 54, 58, 53, 45, 39, 47, 59, 48, 57, 35, 33, 38, 56, 34, 31, 52, 60, 44, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = f\"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.00228118896484375, "tests_passed": true, "error": null}}
{"selected_lines": [40, 58, 38, 49, 59, 60, 33, 56, 48, 39, 31, 41, 37, 29, 46, 35, 53, 34, 44, 43, 57, 54, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 means \"Bad Request\", a generic status code\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/python", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 29, 56, 48, 40, 31, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 46, 53, 56, 60, 34, 38, 31, 44, 45, 47, 35, 37, 40, 41, 57, 33, 43, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid request.\"})\n                'status': 'error',\n                'message': 'Invalid content type. Content-Type: application/json is required.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [37, 53, 31, 34, 38, 48, 33, 43, 39, 40, 45, 49, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002170085906982422, "tests_passed": true, "error": null}}
{"selected_lines": [59, 44, 57, 54, 49, 31, 38, 37, 33, 43, 53, 39, 47, 41, 40, 45, 29, 52, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode('utf-8')\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002315998077392578, "tests_passed": true, "error": null}}
{"selected_lines": [39, 52, 56, 54, 45, 43, 35, 49, 47, 34, 38, 46, 59, 53, 37, 60, 57, 58, 48, 29, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid JSON request.',\n            }\n            if self.headers.get('content-type') != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/python", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 52, 47, 39, 57, 59, 46, 48, 37, 31, 41, 40, 35, 45, 53, 54, 29, 60, 33, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Invalid content type. Content-Type: application/json is required.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 31, 33, 58, 39, 38, 60, 40, 43, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Content-length', len(json.dumps(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 45, 48, 31, 35, 44, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022611618041992188, "tests_passed": true, "error": null}}
{"selected_lines": [48, 43, 53, 37, 39, 44, 59, 57, 46, 45, 52, 60, 47, 54, 40, 38, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'No data received'})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = f\"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.018372774124145508, "tests_passed": true, "error": null}}
{"selected_lines": [39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.024684906005859375, "tests_passed": true, "error": null}}
{"selected_lines": [33, 49, 53, 40, 29, 35, 31, 60, 43, 52, 45, 41, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Invalid content type. Content-Type: application/json is required.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/env python3", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 59, 45, 57, 58, 47, 34, 49, 29, 54, 35, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023109912872314453, "tests_passed": true, "error": null}}
{"selected_lines": [29, 37, 46, 56, 45, 44, 31, 53, 59, 54, 33, 57, 39, 35, 41, 58, 49, 48, 40, 60, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if not isinstance(message, dict):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021369457244873047, "tests_passed": true, "error": null}}
{"selected_lines": [37, 29, 46, 54, 44, 57, 47, 60, 58, 41, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022678375244140625, "tests_passed": true, "error": null}}
{"selected_lines": [58, 53, 46, 34, 45, 38, 31, 54, 48, 43, 40, 57, 47, 44, 60, 39, 41, 49, 52, 29, 59, 35, 33, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 46, 49, 33, 59, 48, 41, 39, 29, 56, 35, 53, 52, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'No data received'})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 38, 41, 33, 47, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {'status': 'error', 'message': 'Content-Type header is not application/json'}\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 31, 52, 54, 37, 46, 38, 40, 29, 44, 49, 43, 57, 56, 48, 59, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = f\"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002187967300415039, "tests_passed": true, "error": null}}
{"selected_lines": [38, 56, 49, 46, 59, 37, 57, 29, 40, 58, 53, 31, 52, 39, 35, 43, 54, 45, 34, 44, 41, 48, 60, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # HTTP 400 - Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023190975189208984, "tests_passed": true, "error": null}}
{"selected_lines": [49, 54, 59, 33, 46, 53, 60, 39, 58, 43, 47, 35, 40, 38, 52, 31, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful response\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 49, 31, 43, 52, 39, 53, 54, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021920204162597656, "tests_passed": true, "error": null}}
{"selected_lines": [48, 45, 56, 59, 60, 43, 44, 31, 35, 47, 52, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002316713333129883, "tests_passed": true, "error": null}}
{"selected_lines": [47, 39, 44, 53, 54, 29, 57, 59, 33, 52, 60, 46, 31, 41, 49, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.Handler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('UTF-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 56, 31, 48, 35, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021610260009765625, "tests_passed": true, "error": null}}
{"selected_lines": [37, 52, 58, 29, 38, 33, 35, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Invalid JSON request.',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 59, 48, 54, 29, 47, 49, 45, 40, 56, 52, 46, 39, 44, 33, 60, 34, 31, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful processing\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 37, 46, 52, 40, 49, 34, 58, 33, 44, 47, 43, 29, 56, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid content type, expected application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers['content-length'])\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 60, 41, 40, 46, 56, 57, 58, 35, 29, 34, 33, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'No data received'})\n                'status': 'error',\n                'message': 'Invalid HTTP request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>class MyCalc:", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31, 29, 58, 54, 34, 39, 53, 33, 57, 35, 38, 41, 43, 45, 48, 52, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # HTTP 400 - Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0026068687438964844, "tests_passed": true, "error": null}}
{"selected_lines": [39, 57, 31, 49, 35, 40, 53, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022220611572265625, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [40, 52, 38, 29, 44, 45, 46, 47, 56, 53, 49, 54, 48, 59, 35, 43, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = f\"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002271890640258789, "tests_passed": true, "error": null}}
{"selected_lines": [48, 60, 58, 44, 52, 35, 37, 29, 45, 39, 46, 31, 49, 33, 34, 54, 41, 59, 40, 53, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'No data received'})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json.'\n            }\n            if ctype != 'application/json':  # Handle case when Content-Type header is not 'application/json'\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.00220489501953125, "tests_passed": true, "error": null}}
{"selected_lines": [47, 49, 60, 57, 46, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/python", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.019624948501586914, "tests_passed": true, "error": null}}
{"selected_lines": [57, 33, 44, 31, 38, 48, 52, 59, 56, 41, 35, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [31, 60, 49, 29, 37, 52, 33, 39, 48, 54, 57, 34, 58, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022051334381103516, "tests_passed": true, "error": null}}
{"selected_lines": [59, 43, 57, 52, 46, 53, 47, 39, 58, 33, 35, 44, 38, 49, 45, 48, 54, 40, 60, 56, 41, 29, 34, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)  # Bad Request\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 40, 59, 49, 33, 34, 46, 45, 57, 56, 60, 37, 43, 41, 35, 47, 38, 39, 54, 58, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid content type, expected application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)  # Return a 400 error response\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017935991287231445, "tests_passed": true, "error": null}}
{"selected_lines": [49, 58, 41, 31, 43, 29, 54, 53, 39, 44, 34, 57, 47, 52, 45, 59, 33, 37, 35, 38, 40, 56, 48, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps(\n                'status': 'error',\n                'message': 'Invalid HTTP POST request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 48, 38, 39, 44, 59, 60, 56, 46, 41, 47, 58, 35, 45, 57, 54, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('UTF-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022509098052978516, "tests_passed": true, "error": null}}
{"selected_lines": [57, 29, 60, 58, 43, 48, 39, 44, 56, 31, 52, 59, 34, 53, 38, 47, 35, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021839141845703125, "tests_passed": true, "error": null}}
{"selected_lines": [48, 46, 34, 44, 31, 33, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'Content-Type header is not application/json'})\n                'status': 'error',\n                'message': 'Invalid Content-Type header'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 45, 37, 43, 60, 29, 52, 38, 41, 57, 56, 49, 47, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':  # If Content-Type is not application/json, respond with an error\n                self.send_response(400)  # Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023000240325927734, "tests_passed": true, "error": null}}
{"selected_lines": [44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01810312271118164, "tests_passed": true, "error": null}}
{"selected_lines": [33, 29, 56, 48, 59, 39, 60, 41, 34, 40, 38, 58, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [33, 52, 45, 34, 49, 37, 56, 57, 47, 38, 60, 44, 46, 54, 53, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful processing\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022232532501220703, "tests_passed": true, "error": null}}
{"selected_lines": [59, 39, 47, 58, 29, 45, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002268075942993164, "tests_passed": true, "error": null}}
{"selected_lines": [34, 45, 59, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002179861068725586, "tests_passed": true, "error": null}}
{"selected_lines": [39, 53, 29, 45, 31, 35, 34, 54, 33, 47, 48, 37, 59, 41, 49, 52, 56, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.Handler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'Content-Type header is not application/json'})\n                'status': 'error',\n                'message': 'Invalid content type. Content-Type: application/json is required.'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful response\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 33, 39, 58, 41, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('UTF-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 40, 29, 60, 34, 58, 56, 54, 41, 31, 52, 38, 59, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002301931381225586, "tests_passed": true, "error": null}}
{"selected_lines": [33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'No data received'})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": false, "time": 0.0002219676971435547, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [60, 56, 38, 47, 44, 52, 43, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002165079116821289, "tests_passed": true, "error": null}}
{"selected_lines": [48, 46, 43, 35, 29, 38, 54, 45, 52, 57, 44, 59, 49, 39, 60, 40, 41, 56, 34, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002293109893798828, "tests_passed": true, "error": null}}
{"selected_lines": [41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.02172398567199707, "tests_passed": true, "error": null}}
{"selected_lines": [46, 59, 47, 37, 44, 33, 39, 56, 52, 38, 45, 29, 57, 40, 43, 31, 58, 35, 53, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31, 35, 52, 43, 34, 33, 59, 37, 44, 53, 48, 40, 39, 57, 47, 56, 46, 29, 54, 60, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = f\"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021648406982421875, "tests_passed": true, "error": null}}
{"selected_lines": [48, 43, 54, 33, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022919178009033203, "tests_passed": true, "error": null}}
{"selected_lines": [29, 60, 33, 41, 40, 43, 46, 53, 35, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import cgi", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 46, 34, 59, 60, 41, 47, 40, 37, 45, 54, 33, 53, 38, 56, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid request.\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if self.headers.get('content-type') != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful processing\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 31, 43, 40, 41, 46, 52, 48, 29, 56, 38, 49, 34, 44, 59, 45, 35, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPServer.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002134084701538086, "tests_passed": true, "error": null}}
{"selected_lines": [47, 33, 29, 40, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [38, 35, 59, 56, 48, 60, 57, 37, 58, 43, 49, 53, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':  # If Content-Type is not application/json, respond with an error\n                self.send_response(400)  # HTTP 400 - Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/env python3", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 56, 52, 31, 44, 34, 46, 40, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023310184478759766, "tests_passed": true, "error": null}}
{"selected_lines": [34, 43, 53, 59, 60, 37, 57, 41, 49, 56, 46, 40, 33, 54, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid request.\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/python", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 52, 34, 54, 56, 29, 38, 37, 46, 57, 33, 39, 45, 53, 49, 60, 43, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid Content-Type. Please send JSON data.\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 33, 45, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 48, 31, 60, 49, 35, 41, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002199888229370117, "tests_passed": true, "error": null}}
{"selected_lines": [40, 43, 45, 54, 60, 58, 39, 38, 59, 48, 57, 49, 37, 33, 29, 35, 44, 41, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'Content-Type header is not application/json'})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful processing\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 33, 29, 38, 41, 58, 39, 35, 37, 45, 59, 34, 57, 44, 56, 40, 54, 47, 43, 48, 52, 31, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Return a 400 error response\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers['content-length'])\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 52, 33, 47, 48, 56, 59, 57, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 31, 59, 46, 54, 57, 48, 38, 29, 43, 49, 52, 53, 41, 34, 39, 58, 40, 33, 35, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Invalid content type. Expected application/json.'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if not isinstance(message, dict):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [34, 45, 41, 31, 40, 39, 35, 59, 37, 43, 52, 60, 56, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length')) if 'Content-Length' in self.headers else 0\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002343893051147461, "tests_passed": true, "error": null}}
{"selected_lines": [52, 34, 48, 49, 44, 58, 29, 37, 57, 60, 47, 39, 59, 56, 46, 33, 38, 35, 43, 53, 45, 31, 54, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps(\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':  # Handle case when Content-Type header is not 'application/json'\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [38, 35, 44, 33, 29, 40, 39, 43, 57, 59, 47, 52, 34, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021581649780273438, "tests_passed": true, "error": null}}
{"selected_lines": [52, 60, 31, 54, 33, 34, 38, 56, 46, 58, 47, 53, 37, 41, 49, 29, 39, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 39, 47, 46, 34, 29, 49, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002293109893798828, "tests_passed": true, "error": null}}
{"selected_lines": [57, 38, 47, 48, 59, 39, 33, 41, 35, 31, 56, 49, 46, 40, 44, 45, 43, 54, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length')) if 'Content-Length' in self.headers else 0\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 33, 46, 40, 45, 37, 41, 49, 53, 31, 57, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('UTF-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 53, 40, 33, 56, 59, 47, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid Content-Type. Please send JSON data.\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 60, 29, 33, 35, 44, 54, 46, 58, 53, 48, 31, 41, 45, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'}\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful response\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [35, 59, 47, 45, 48, 52, 41, 56, 38, 46, 37, 29, 39, 49, 33, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # HTTP 400 - Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 43, 40, 59, 56, 48, 34, 29, 52, 44, 60, 35, 38, 47, 41, 53, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad request\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002227783203125, "tests_passed": true, "error": null}}
{"selected_lines": [45, 37, 44, 60, 54, 53, 34, 52, 46, 43, 35, 59, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002238035202026367, "tests_passed": true, "error": null}}
{"selected_lines": [44, 59, 31, 41, 39, 37, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021729469299316406, "tests_passed": true, "error": null}}
{"selected_lines": [43, 29, 31, 60, 34, 56, 46, 48, 45, 44, 35, 41, 53, 49, 59, 54, 47, 52, 37, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid Content-Type: {}, Expected: application/json'.format(ctype)\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0025489330291748047, "tests_passed": true, "error": null}}
{"selected_lines": [34, 45, 37, 52, 47, 58, 44, 56, 54, 33, 57, 46, 39, 29, 59, 38, 31, 53, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 34, 44, 46, 48, 54, 59, 31, 38, 53, 57, 33, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021860599517822266, "tests_passed": true, "error": null}}
{"selected_lines": [45, 34, 59, 49, 52, 39, 54, 29, 58, 33, 47, 56, 60, 43, 41, 37, 57, 44, 46, 48, 31, 53, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [35, 31, 58, 37, 40, 44, 43, 39, 56, 46, 60, 53, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/python", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [29, 48, 41, 59, 60, 34, 44, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('UTF-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023040771484375, "tests_passed": true, "error": null}}
{"selected_lines": [34, 37, 40, 60, 41, 59, 52, 35, 47, 46, 38, 49, 57, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002192974090576172, "tests_passed": true, "error": null}}
{"selected_lines": [44, 45, 48, 59, 39, 31, 34, 41, 43, 54, 47, 37, 35, 46, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022852420806884766, "tests_passed": true, "error": null}}
{"selected_lines": [59, 45, 46, 40, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid request.\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [29, 33, 58, 49, 53, 40, 35, 39, 38, 52, 56, 45, 31, 46, 34, 48, 44, 60, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/env python3", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import cgi", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [38, 56, 33, 40, 49, 34, 41, 47, 45, 60, 48, 54, 31, 52, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = self.headers.getheaders('content-type')\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [33, 41, 31, 39, 37, 46, 53, 54, 43, 34, 57, 59, 58, 49, 38, 47, 29, 45, 52, 48, 56, 60, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful processing\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/python", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 58, 34, 45, 35, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid content type. Content-Type: application/json is required.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Return a 400 error response\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Content-Length', str(len(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002198934555053711, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [49, 52, 59, 33, 38, 44, 57, 54, 31, 39, 40, 43, 46, 56, 60, 41, 45, 47, 35, 53, 29, 34, 58, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {'status': 'error', 'message': 'Content-Type header is not application/json'}\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length')) if 'Content-Length' in self.headers else 0\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 37, 45, 48, 34, 40, 54, 46, 33, 58, 59, 41, 31, 57, 49, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':  # Handle case when Content-Type header is not 'application/json'\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not isinstance(message, dict):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Content-Length', str(len(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023059844970703125, "tests_passed": true, "error": null}}
{"selected_lines": [52, 60, 39, 40, 53, 48, 35, 54, 58, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002201080322265625, "tests_passed": true, "error": null}}
{"selected_lines": [47, 58, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Content-length', len(json.dumps(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002264738082885742, "tests_passed": true, "error": null}}
{"selected_lines": [58, 56, 39, 45, 29, 60, 48, 38, 49, 57, 43, 44, 37, 40, 54, 31, 59, 47, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 31, 40, 35, 56, 53, 33, 49, 60, 45, 58, 39, 41, 48, 44, 57, 59, 47, 34, 54, 46, 29, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPServer.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Invalid Content-Type: {}, Expected: application/json'.format(ctype)\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful response\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 40, 38, 58, 35, 56, 44, 48, 53, 47, 52, 54, 46, 29, 39, 37, 41, 34, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid content type, expected application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # HTTP 400 - Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 57, 29, 53, 35, 34, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021588802337646484, "tests_passed": true, "error": null}}
{"selected_lines": [59, 43, 44, 46, 52, 58, 60, 39, 33, 40, 35, 45, 53, 49, 29, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 33, 35, 45, 46, 57, 31, 47, 41, 54, 53, 59, 34, 40, 37, 38, 56, 58, 44, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful processing\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 39, 35, 34, 59, 45, 60, 40, 49, 48, 44, 57, 53, 54, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid Content-Type: {}, Expected: application/json'.format(ctype)\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022859573364257812, "tests_passed": true, "error": null}}
{"selected_lines": [52, 45, 46, 44, 34, 29, 35, 57, 56, 33, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [40, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022079944610595703, "tests_passed": true, "error": null}}
{"selected_lines": [48, 43, 54, 41, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002298116683959961, "tests_passed": true, "error": null}}
{"selected_lines": [33, 38, 43, 40, 29, 39, 48, 46, 52, 58, 57, 44, 60, 54, 45, 31, 47, 35, 37, 41, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':  # Handle case when Content-Type header is not 'application/json'\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [60, 34, 33, 45, 58, 52, 37, 29, 48, 39, 56, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPServer.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)  # Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 58, 41, 56, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021791458129882812, "tests_passed": true, "error": null}}
{"selected_lines": [48, 29, 46, 34, 56, 37, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023272037506103516, "tests_passed": true, "error": null}}
{"selected_lines": [44, 60, 49, 56, 53, 57, 47, 43, 40, 39, 59, 29, 45, 58, 41, 37, 31, 33, 34, 48, 54, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Invalid content type. Expected application/json.'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length')) if 'Content-Length' in self.headers else 0\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 58, 53, 57, 40, 59, 29, 35, 56, 52, 44, 48, 39, 45, 60, 47, 46, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022389888763427734, "tests_passed": true, "error": null}}
{"selected_lines": [49, 54, 52, 38, 59, 45, 35, 33, 34, 46, 41, 60, 56, 53, 47, 29, 31, 39, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Return a 400 error response\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022928714752197266, "tests_passed": true, "error": null}}
{"selected_lines": [40, 35, 34, 59, 44, 58, 29, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022499561309814453, "tests_passed": true, "error": null}}
{"selected_lines": [48, 43, 35, 44, 34, 54, 49, 38, 52, 37, 33, 45, 41, 59, 58, 47, 46, 57, 60, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>class MyCalc:", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [29, 53, 47, 33, 46, 34, 52, 31, 44, 56, 54, 59, 48, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 54, 43, 38, 44, 56, 52, 46, 48, 57, 39, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Return a 400 error response\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>class MyCalc:", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [29, 31, 46, 52, 47, 34, 43, 59, 41, 38, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023069381713867188, "tests_passed": true, "error": null}}
{"selected_lines": [31, 35, 41, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002215862274169922, "tests_passed": true, "error": null}}
{"selected_lines": [31, 37, 49, 56, 41, 54, 53, 59, 40, 39, 29, 46, 58, 52, 48, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022521018981933594, "tests_passed": true, "error": null}}
{"selected_lines": [53, 29, 48, 35, 45, 40, 41, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Invalid content type. Expected application/json.'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022001266479492188, "tests_passed": true, "error": null}}
{"selected_lines": [53, 31, 57, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022988319396972656, "tests_passed": true, "error": null}}
{"selected_lines": [52, 37, 57, 54, 60, 35, 59, 44, 43, 29, 39, 47, 34, 31, 49, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':  # Handle case when Content-Type header is not 'application/json'\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful processing\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021660327911376953, "tests_passed": true, "error": null}}
{"selected_lines": [49, 33, 45, 31, 52, 53, 29, 37, 60, 48, 35, 47, 40, 58, 39, 57, 54, 44, 41, 46, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the request success\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import cgi", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 40, 54, 44, 47, 52, 38, 46, 31, 43, 37, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002611875534057617, "tests_passed": true, "error": null}}
{"selected_lines": [35, 56, 48, 52, 47, 41, 57, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid HTTP POST request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021970272064208984, "tests_passed": true, "error": null}}
{"selected_lines": [58, 43, 33, 47, 35, 46, 49, 60, 38, 52, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid Content-Type. Please send JSON data.\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>class MyCalc:", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [34, 57, 29, 53, 37, 35, 58, 54, 52, 56, 49, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 58, 49, 37, 56, 60, 43, 59, 41, 35, 38, 54, 39, 31, 33, 48, 46, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':  # Handle case when Content-Type header is not 'application/json'\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 37, 40, 33, 43, 59, 53, 57, 34, 52, 44, 56, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023241043090820312, "tests_passed": true, "error": null}}
{"selected_lines": [59, 43, 52, 60, 54, 46, 53, 45, 39, 47, 29, 31, 44, 56, 48, 49, 37, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful processing\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021741390228271484, "tests_passed": true, "error": null}}
{"selected_lines": [38, 47, 39, 53, 35, 60, 58, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002324819564819336, "tests_passed": true, "error": null}}
{"selected_lines": [54, 57, 34, 41, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022590160369873047, "tests_passed": true, "error": null}}
{"selected_lines": [40, 60, 56, 54, 41, 52, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022630691528320312, "tests_passed": true, "error": null}}
{"selected_lines": [48, 57, 56, 58, 35, 34, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023260116577148438, "tests_passed": true, "error": null}}
{"selected_lines": [48, 33, 47, 53, 58, 41, 31, 45, 44, 29, 35, 34, 46, 49, 43, 57, 52, 59, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 52, 48, 46, 58, 53, 37, 39, 56, 31, 49, 44, 45, 41, 60, 33, 47, 38, 29, 34, 40, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':  # Handle case when Content-Type header is not 'application/json'\n                self.send_response(400)  # Set status code as 400, Bad Request\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021660327911376953, "tests_passed": true, "error": null}}
{"selected_lines": [37, 49, 53, 54, 46, 33, 39, 60, 38, 43, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid HTTP request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023212432861328125, "tests_passed": true, "error": null}}
{"selected_lines": [39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.024684906005859375, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [39, 46, 58, 54, 44, 35, 59, 41, 56, 49, 31, 37, 33, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022029876708984375, "tests_passed": true, "error": null}}
{"selected_lines": [35, 45, 37, 38, 34, 48, 39, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad request\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002298116683959961, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [53, 58, 47, 29, 37, 40, 48, 49, 54, 38, 56, 41, 60, 52, 31, 43, 44, 46, 34, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful response\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import cgi", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 59, 31, 35, 37, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022611618041992188, "tests_passed": true, "error": null}}
{"selected_lines": [31, 37, 46, 33, 54, 43, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [37, 35, 29, 48, 60, 39, 58, 43, 38, 57, 45, 40, 41, 46, 59, 47, 34, 31, 54, 33, 49, 52, 56, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if self.path == '/':  # if the path is '/' (the root directory),\n                self.send_response(400)  # Return a 400 error response\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers['content-length'])\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the request success\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [29, 49, 45, 33, 37, 39, 54, 35, 43, 58, 34, 38, 48, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Content-length', len(json.dumps(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 43, 53, 34, 35, 44, 37, 54, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid HTTP request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.004045963287353516, "tests_passed": true, "error": null}}
{"selected_lines": [43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017935991287231445, "tests_passed": true, "error": null}}
{"selected_lines": [57, 34, 40, 56, 29, 54, 60, 41, 47, 49, 59, 53, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0026102066040039062, "tests_passed": true, "error": null}}
{"selected_lines": [35, 52, 45, 56, 38, 29, 40, 33, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017239093780517578, "tests_passed": true, "error": null}}
{"selected_lines": [38, 33, 53, 34, 58, 52, 40, 57, 47, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Set status code as 400, Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0031969547271728516, "tests_passed": true, "error": null}}
{"selected_lines": [49, 54, 59, 29, 31, 57, 39, 41, 38, 58, 35, 56, 43, 34, 60, 52, 44, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('UTF-8'))\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length).decode('utf-8')\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0025789737701416016, "tests_passed": true, "error": null}}
{"selected_lines": [46, 49, 56, 37, 47, 60, 45, 41, 40, 29, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid HTTP POST request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0029649734497070312, "tests_passed": true, "error": null}}
{"selected_lines": [46, 37, 58, 48, 44, 41, 59, 38, 57, 53, 47, 52, 29, 43, 45, 39, 33, 34, 35, 31, 54, 60, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers['content-length'])\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.003470182418823242, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017935991287231445, "tests_passed": true, "error": null}}
{"selected_lines": [58, 33, 46, 52, 60, 34, 56, 45, 37, 57, 31, 38, 49, 41, 53, 59, 48, 54, 39, 35, 43, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002992868423461914, "tests_passed": true, "error": null}}
{"selected_lines": [57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.018255949020385742, "tests_passed": true, "error": null}}
{"selected_lines": [59, 57, 45, 35, 37, 31, 56, 38, 34, 33, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':  # If Content-Type is not application/json, respond with an error\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not isinstance(message, dict):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [35, 54, 49, 59, 45, 34, 37, 39, 48, 46, 38, 29, 60, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 46, 54, 41, 35, 57, 52, 45, 53, 29, 56, 60, 40, 48, 58, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid Content-Type header'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002561807632446289, "tests_passed": true, "error": null}}
{"selected_lines": [53, 37, 39, 58, 46, 43, 40, 31, 57, 41, 52, 45, 34, 48, 59, 33, 38, 54, 29, 44, 49, 35, 56, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = self.headers.getheaders('content-type')\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = f\"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017239093780517578, "tests_passed": true, "error": null}}
{"selected_lines": [59, 52, 29, 44, 54, 49, 60, 56, 45, 35, 46, 39, 58, 41, 34, 38, 48, 33, 43, 37, 57, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid JSON request.',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002490997314453125, "tests_passed": true, "error": null}}
{"selected_lines": [46, 35, 31, 60, 43, 58, 53, 49, 48, 47, 33, 57, 54, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'Content-Type header is not application/json'})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 49, 44, 31, 52, 46, 40, 58, 54, 34, 56, 57, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid Content-Type. Please send JSON data.\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 56, 37, 49, 45, 35, 46, 39, 41, 58, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022461414337158203, "tests_passed": true, "error": null}}
{"selected_lines": [39, 37, 44, 33, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0025310516357421875, "tests_passed": true, "error": null}}
{"selected_lines": [47, 41, 60, 59, 58, 29, 54, 33, 48, 40, 43, 57, 35, 38, 46, 31, 37, 34, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 means \"Bad Request\", a generic status code\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002441883087158203, "tests_passed": true, "error": null}}
{"selected_lines": [45, 56, 44, 40, 57, 48, 49, 54, 43, 46, 47, 31, 58, 60, 29, 53, 35, 34, 52, 59, 37, 38, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0027618408203125, "tests_passed": true, "error": null}}
{"selected_lines": [57, 35, 46, 45, 59, 60, 41, 56, 52, 38, 33, 53, 34, 48, 58, 40, 43, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('UTF-8'))\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 40, 33, 29, 43, 34, 31, 53, 38, 35, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Invalid Content-Type header'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 31, 49, 38, 37, 48, 29, 35, 43, 58, 54, 57, 56, 47, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Set status code as 400, Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002312183380126953, "tests_passed": true, "error": null}}
{"selected_lines": [38, 39, 45, 37, 35, 58, 31, 53, 54, 40, 59, 34, 43, 29, 60, 49, 47, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid JSON request.',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023729801177978516, "tests_passed": true, "error": null}}
{"selected_lines": [33, 59, 31, 60, 52, 37, 41, 35, 48, 39, 34, 43, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers['content-length'])\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.022449016571044922, "tests_passed": true, "error": null}}
{"selected_lines": [48, 53, 57, 47, 45, 29, 35, 44, 40, 34, 60, 54, 59, 33, 41, 43, 56, 52, 31, 39, 37, 46, 58, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {'status': 'error', 'message': 'Content-Type header is not application/json'}\n                'status': 'error',\n                'message': 'Invalid HTTP POST request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/python", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 49, 52, 43, 39, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022919178009033203, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.019032001495361328, "tests_passed": true, "error": null}}
{"selected_lines": [37, 33, 38, 49, 58, 48, 60, 52, 34, 57, 47, 39, 59, 29, 41, 45, 54, 35, 53, 43, 31, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Set status code as 400, Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 49, 43, 57, 53, 47, 44, 58, 38, 31, 45, 52, 29, 34, 37, 46, 56, 39, 33, 59, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {'status': 'error', 'message': 'Content-Type header is not application/json'}\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if self.headers.get('content-type') != 'application/json':\n                self.send_response(400)  # Bad request\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.018212080001831055, "tests_passed": true, "error": null}}
{"selected_lines": [49, 45, 58, 56, 60, 52, 37, 39, 54, 41, 34, 44, 31, 48, 29, 57, 46, 35, 47, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'}\n            }\n            if ctype != 'application/json':  # If Content-Type is not application/json, respond with an error\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 60, 41, 59, 46, 53, 39, 33, 48, 57, 47, 45, 35, 54, 49, 43, 37, 56, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the request success\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import cgi", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [33, 60, 37, 48, 40, 31, 35, 46, 53, 59, 47, 52, 41, 44, 49, 43, 39, 34, 29, 45, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Invalid content type. Expected application/json.'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 33, 54, 45, 53, 46, 59, 44, 49, 60, 57, 38, 29, 48, 52, 31, 47, 58, 34, 37, 39, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful response\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [53, 52, 43, 34, 60, 59, 39, 57, 47, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import cgi", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 45, 34, 38, 37, 49, 52, 46, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'No data received'})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # HTTP 400 - Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if not isinstance(message, dict):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 47, 53, 43, 59, 40, 29, 39, 46, 57, 35, 41, 60, 54, 52, 44, 34, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 means \"Bad Request\", a generic status code\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002665996551513672, "tests_passed": true, "error": null}}
{"selected_lines": [35, 31, 39, 58, 46, 52, 38, 56, 33, 29, 47, 53, 54, 57, 49, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPServer.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Invalid content type. Content-Type: application/json is required.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 31, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022699832916259766, "tests_passed": true, "error": null}}
{"selected_lines": [57, 56, 29, 41, 37, 60, 46, 40, 58, 54, 34, 39, 33, 43, 53, 49, 38, 44, 48, 45, 59, 52, 31, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid content type, expected application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('UTF-8'))\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful processing\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31, 48, 46, 49, 41, 29, 53, 40, 39, 44, 47, 56, 52, 45, 59, 33, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {'status': 'error', 'message': 'Content-Type header is not application/json'}\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 44, 56, 43, 35, 54, 60, 33, 29, 45, 46, 49, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid request.\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers['content-length'])\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [29, 53, 47, 41, 34, 60, 58, 52, 45, 43, 44, 35, 54, 38, 31, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid HTTP POST request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import cgi", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 48, 29, 60, 57, 39, 54, 44, 47, 31, 58, 49, 35, 38, 56, 43, 40, 34, 33, 46, 59, 45, 53, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Invalid JSON request.',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Return a 400 error response\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>class MyCalc:", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 40, 58, 52, 44, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023670196533203125, "tests_passed": true, "error": null}}
{"selected_lines": [57, 60, 47, 31, 45, 34, 58, 33, 43, 46, 44, 56, 52, 48, 53, 37, 38, 54, 29, 39, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid content type, expected application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [38, 43, 29, 40, 35, 56, 53, 41, 31, 60, 54, 58, 47, 52, 45, 49, 44, 48, 34, 59, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid JSON request.',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length).decode()\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002274036407470703, "tests_passed": true, "error": null}}
{"selected_lines": [49, 39, 46, 37, 58, 35, 34, 47, 44, 41, 33, 43, 29, 60, 45, 48, 38, 40, 59, 52, 57, 53, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 60, 52, 45, 33, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Content-Length', str(len(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 58, 54, 40, 31, 37, 53, 60, 34, 52, 47, 41, 49, 33, 38, 59, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31, 46, 40, 53, 44, 52, 33, 43, 57, 60, 58, 59, 38, 48, 45, 39, 47, 34, 54, 37, 49, 29, 35, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 means \"Bad Request\", a generic status code\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>class MyCalc:", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 41, 48, 38, 29, 53, 40, 45, 57, 46, 31, 37, 52, 49, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad request\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.00232696533203125, "tests_passed": true, "error": null}}
{"selected_lines": [54, 39, 49, 38, 48, 41, 58, 56, 59, 34, 52, 45, 40, 44, 46, 47, 37, 60, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('UTF-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode('utf-8')\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002270936965942383, "tests_passed": true, "error": null}}
{"selected_lines": [54, 58, 46, 44, 53, 56, 49, 33, 45, 40, 31, 35, 29, 57, 59, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [37, 41, 35, 29, 54, 40, 45, 52, 58, 31, 46, 56, 38, 53, 47, 57, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022912025451660156, "tests_passed": true, "error": null}}
{"selected_lines": [43, 37, 54, 29, 57, 40, 59, 31, 34, 45, 41, 46, 33, 48, 47, 39, 52, 35, 58, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 43, 44, 60, 57, 52, 34, 41, 53, 40, 29, 59, 46, 31, 56, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022690296173095703, "tests_passed": true, "error": null}}
{"selected_lines": [29, 46, 45, 31, 35, 48, 53, 38, 41, 40, 34, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023238658905029297, "tests_passed": true, "error": null}}
{"selected_lines": [34, 57, 58, 52, 46, 48, 33, 38, 40, 56, 60, 31, 59, 41, 43, 47, 39, 44, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad request\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [29, 35, 47, 43, 60, 49, 52, 33, 31, 40, 45, 38, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'Content-Type header is not application/json'})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Return a 400 error response\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [38, 52, 40, 44, 49, 43, 53, 47, 56, 37, 29, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length')) if 'Content-Length' in self.headers else 0\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022110939025878906, "tests_passed": true, "error": null}}
{"selected_lines": [58, 53, 48, 44, 40, 54, 41, 47, 43, 34, 31, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the request success\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002370119094848633, "tests_passed": true, "error": null}}
{"selected_lines": [43, 37, 38, 52, 40, 45, 58, 49, 33, 56, 39, 44, 29, 48, 60, 59, 57, 46, 41, 35, 34, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002262115478515625, "tests_passed": true, "error": null}}
{"selected_lines": [48, 46, 29, 56, 49, 34, 44, 39, 37, 52, 31, 47, 43, 60, 57, 58, 45, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Content-Length', str(len(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023353099822998047, "tests_passed": true, "error": null}}
{"selected_lines": [49, 45, 52, 41, 46, 38, 57, 33, 59, 53, 29, 56, 43, 47, 31, 44, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 41, 47, 39, 49, 44, 45, 43, 48, 33, 52, 34, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import cgi", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 53, 44, 34, 54, 52, 49, 31, 33, 39, 43, 48, 29, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'Content-Type header is not application/json'})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [38, 43, 41, 31, 39, 49, 56, 48, 34, 47, 35, 44, 59, 40, 45, 37, 52, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid HTTP request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022792816162109375, "tests_passed": true, "error": null}}
{"selected_lines": [43, 44, 58, 53, 46, 60, 52, 57, 33, 41, 49, 56, 37, 59, 34, 39, 47, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Content-length', len(json.dumps(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023331642150878906, "tests_passed": true, "error": null}}
{"selected_lines": [39, 54, 44, 57, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022406578063964844, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [54, 45, 35, 38, 43, 60, 47, 31, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022420883178710938, "tests_passed": true, "error": null}}
{"selected_lines": [54, 43, 34, 44, 56, 31, 47, 57, 41, 35, 46, 48, 59, 60, 38, 52, 40, 49, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = f\"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022652149200439453, "tests_passed": true, "error": null}}
{"selected_lines": [31, 38, 47, 58, 29, 33, 35, 49, 44, 46, 48, 53, 54, 41, 40, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Set status code as 400, Bad Request\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.018255949020385742, "tests_passed": true, "error": null}}
{"selected_lines": [46, 40, 35, 57, 59, 48, 37, 45, 38, 41, 49, 43, 56, 34, 29, 31, 39, 53, 54, 44, 52, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid HTTP POST request'\n            }\n            if self.headers.get('content-type') != 'application/json':\n                self.send_response(400)  # 400 means \"Bad Request\", a generic status code\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if not isinstance(message, dict):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/python", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [34, 57, 45, 46, 41, 54, 44, 47, 49, 39, 52, 35, 43, 37, 53, 60, 31, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid JSON request.',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021860599517822266, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [33, 52, 39, 58, 45, 47, 57, 37, 44, 35, 60, 59, 54, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/python", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 56, 37, 54, 31, 59, 47, 40, 39, 34, 29, 41, 49, 45, 48, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = f\"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002232789993286133, "tests_passed": true, "error": null}}
{"selected_lines": [56, 49, 60, 47, 46, 39, 33, 44, 43, 54, 41, 34, 40, 48, 31, 59, 29, 53, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = f\"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [35, 52, 60, 54, 57, 43, 41, 59, 45, 48, 37, 49, 39, 40, 53, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [38, 35, 39, 57, 56, 52, 47, 49, 44, 37, 45, 34, 41, 60, 43, 54, 48, 46, 59, 58, 53, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid Content-Type header'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021860599517822266, "tests_passed": true, "error": null}}
{"selected_lines": [46, 52, 37, 58, 60, 54, 31, 47, 39, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0025920867919921875, "tests_passed": true, "error": null}}
{"selected_lines": [33, 46, 56, 40, 39, 41, 52, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [37, 57, 52, 49, 35, 46, 54, 29, 58, 41, 60, 47, 43, 44, 53, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid Content-Type header'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/env python3", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 57, 48, 46, 47, 35, 31, 44, 53, 43, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002270936965942383, "tests_passed": true, "error": null}}
{"selected_lines": [49, 54, 29, 57, 34, 31, 37, 58, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023071765899658203, "tests_passed": true, "error": null}}
{"selected_lines": [54, 44, 31, 43, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [37, 60, 49, 40, 47, 34, 33, 56, 44, 41, 52, 53, 35, 59, 31, 45, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [38, 37, 47, 39, 43, 46, 31, 29, 57, 54, 49, 45, 34, 59, 56, 48, 44, 35, 58, 33, 41, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = self.headers.getheaders('content-type')\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid HTTP POST request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # HTTP 400 - Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002192974090576172, "tests_passed": true, "error": null}}
{"selected_lines": [58, 54, 44, 53, 57, 59, 29, 46, 47, 34, 43, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [33, 58, 40, 54, 37, 48, 34, 53, 47, 35, 59, 46, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {'status': 'error', 'message': 'Content-Type header is not application/json'}\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 39, 46, 47, 49, 31, 54, 37, 58, 52, 40, 45, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not isinstance(message, dict):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023119449615478516, "tests_passed": true, "error": null}}
{"selected_lines": [57, 39, 31, 38, 56, 58, 40, 54, 52, 44, 53, 34, 43, 48, 59, 47, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021648406982421875, "tests_passed": true, "error": null}}
{"selected_lines": [35, 31, 56, 53, 58, 29, 52, 33, 46, 44, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002407073974609375, "tests_passed": true, "error": null}}
{"selected_lines": [35, 56, 52, 41, 48, 53, 44, 47, 57, 33, 43, 34, 49, 54, 45, 40, 38, 58, 37, 59, 39, 46, 29, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'}\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 38, 29, 34, 57, 59, 56, 31, 46, 40, 41, 60, 47, 33, 44, 43, 53, 37, 48, 35, 39, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/env python3", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": false, "time": 0.00022912025451660156, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [44, 52, 33, 46, 34, 54, 37, 59, 48, 40, 56, 43, 53, 41, 31, 60, 38, 29, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022971630096435547, "tests_passed": true, "error": null}}
{"selected_lines": [52, 43, 40, 53, 48, 38, 47, 54, 56, 33, 31, 35, 34, 44, 39, 37, 45, 57, 60, 46, 49, 58, 29, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'Content-Type header is not application/json'})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)  # HTTP 400 - Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import math", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 54, 43, 57, 39, 38, 47, 41, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful response\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002460002899169922, "tests_passed": true, "error": null}}
{"selected_lines": [33, 37, 60, 45, 43, 58, 29, 53, 35, 57, 49, 38, 48, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps(\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [38, 57, 31, 45, 37, 41, 47, 56, 46, 40, 58, 54, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = f\"Content-Type header is not application/json\"\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023250579833984375, "tests_passed": true, "error": null}}
{"selected_lines": [45, 43, 52, 49, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0025708675384521484, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [53, 48, 59, 29, 33, 49, 41, 52, 31, 40, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 57, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023300647735595703, "tests_passed": true, "error": null}}
{"selected_lines": [37, 56, 46, 35, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = self.headers.getheaders('content-type')\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0024712085723876953, "tests_passed": true, "error": null}}
{"selected_lines": [44, 37, 33, 56, 31, 35, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful response\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [38, 29, 59, 46, 34, 53, 52, 43, 60, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0024111270904541016, "tests_passed": true, "error": null}}
{"selected_lines": [43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017935991287231445, "tests_passed": true, "error": null}}
{"selected_lines": [58, 47, 29, 53, 52, 41, 44, 57, 39, 31, 45, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Return a 400 error response\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0025169849395751953, "tests_passed": true, "error": null}}
{"selected_lines": [59, 29, 41, 52, 33, 34, 39, 48, 31, 49, 58, 38, 54, 37, 46, 53, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if self.path == '/':  # if the path is '/' (the root directory),\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length')) if 'Content-Length' in self.headers else 0\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 34, 57, 35, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023696422576904297, "tests_passed": true, "error": null}}
{"selected_lines": [48, 53, 57, 45, 47, 37, 43, 49, 38, 52, 39, 56, 58, 40, 34, 29, 41, 44, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002562999725341797, "tests_passed": true, "error": null}}
{"selected_lines": [53, 54, 39, 49, 43, 56, 40, 44, 35, 34, 47, 29, 58, 46, 37, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid HTTP POST request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.00234222412109375, "tests_passed": true, "error": null}}
{"selected_lines": [58, 40, 56, 31, 44, 45, 47, 43, 35, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0024459362030029297, "tests_passed": true, "error": null}}
{"selected_lines": [53, 60, 35, 48, 49, 40, 33, 37, 29, 58, 57, 39, 34, 59, 43, 41, 52, 56, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid HTTP POST request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023860931396484375, "tests_passed": true, "error": null}}
{"selected_lines": [31, 58, 48, 60, 52, 39, 40, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid content type. Content-Type: application/json is required.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 43, 45, 46, 59, 40, 31, 34, 29, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if not isinstance(message, dict):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0025610923767089844, "tests_passed": true, "error": null}}
{"selected_lines": [58, 29, 34, 49, 48, 40, 52, 41, 39, 60, 43, 45, 33, 47, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002328157424926758, "tests_passed": true, "error": null}}
{"selected_lines": [49, 47, 45, 29, 35, 39, 53, 38, 48, 46, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0024619102478027344, "tests_passed": true, "error": null}}
{"selected_lines": [45, 35, 56, 43, 34, 39, 33, 38, 44, 46, 53, 57, 47, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid Content-Type. Please send JSON data.\"})\n                'status': 'error',\n                'message': 'Invalid HTTP request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 49, 41, 56, 46, 58, 40, 35, 31, 57, 37, 59, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Content-length', len(json.dumps(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0025069713592529297, "tests_passed": true, "error": null}}
{"selected_lines": [43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017935991287231445, "tests_passed": true, "error": null}}
{"selected_lines": [52, 57, 29, 45, 56, 35, 60, 34, 48, 38, 43, 37, 54, 58, 39, 49, 44, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0028526782989501953, "tests_passed": true, "error": null}}
{"selected_lines": [34, 47, 58, 43, 37, 59, 40, 33, 57, 48, 53, 45, 60, 54, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid request.\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 48, 34, 52, 60, 37, 43, 31, 58, 29, 39, 49, 56, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Content-Length', str(len(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002240896224975586, "tests_passed": true, "error": null}}
{"selected_lines": [60, 53, 37, 56, 43, 39, 48, 31, 57, 52, 46, 49, 45, 29, 58, 44, 54, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode('utf-8')\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002276182174682617, "tests_passed": true, "error": null}}
{"selected_lines": [39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.02008795738220215, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [46, 40, 54, 29, 48, 59, 60, 49, 56, 52, 38, 47, 58, 45, 34, 35, 39, 37, 33, 41, 31, 53, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'}\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('UTF-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 29, 53, 52, 44, 41, 43, 60, 31, 49, 56, 35, 45, 33, 57, 39, 37, 34, 58, 48, 38, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Invalid JSON request.',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [35, 45, 54, 57, 46, 29, 39, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful response\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002268075942993164, "tests_passed": true, "error": null}}
{"selected_lines": [59, 48, 34, 52, 54, 49, 37, 57, 40, 60, 39, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if self.headers.get('content-type') != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful processing\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002259969711303711, "tests_passed": true, "error": null}}
{"selected_lines": [43, 60, 34, 48, 35, 56, 41, 53, 45, 37, 47, 44, 49, 58, 46, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022249221801757812, "tests_passed": true, "error": null}}
{"selected_lines": [52, 46, 39, 47, 49, 33, 29, 59, 37, 57, 56, 45, 40, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/python", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 48, 34, 58, 38, 57, 29, 49, 54, 35, 31, 46, 43, 53, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPServer.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # HTTP 400 - Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023698806762695312, "tests_passed": true, "error": null}}
{"selected_lines": [53, 37, 54, 60, 40, 59, 38, 29, 43, 57, 39, 58, 31, 47, 44, 46, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>class MyCalc:", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.021344661712646484, "tests_passed": true, "error": null}}
{"selected_lines": [35, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022478103637695312, "tests_passed": true, "error": null}}
{"selected_lines": [39, 31, 34, 43, 60, 38, 40, 45, 44, 56, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023632049560546875, "tests_passed": true, "error": null}}
{"selected_lines": [47, 44, 59, 56, 60, 39, 58, 43, 45, 29, 53, 33, 57, 38, 52, 54, 37, 41, 46, 48, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002223968505859375, "tests_passed": true, "error": null}}
{"selected_lines": [52, 48, 56, 35, 54, 46, 39, 49, 40, 57, 29, 43, 41, 60, 53, 58, 47, 38, 31, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002298116683959961, "tests_passed": true, "error": null}}
{"selected_lines": [57, 41, 43, 58, 38, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002201080322265625, "tests_passed": true, "error": null}}
{"selected_lines": [52, 48, 47, 53, 38, 54, 33, 59, 34, 40, 39, 46, 41, 49, 45, 56, 60, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Invalid content type. Expected application/json.'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002279043197631836, "tests_passed": true, "error": null}}
{"selected_lines": [52, 59, 60, 48, 57, 49, 34, 44, 53, 43, 54, 39, 31, 45, 58, 46, 33, 41, 40, 29, 47, 56, 38, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Content-Length', str(len(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import math", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 49, 54, 35, 33, 53, 39, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021810531616210938, "tests_passed": true, "error": null}}
{"selected_lines": [44, 57, 58, 52, 46, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023479461669921875, "tests_passed": true, "error": null}}
{"selected_lines": [35, 44, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid HTTP request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022699832916259766, "tests_passed": true, "error": null}}
{"selected_lines": [60, 37, 58, 54, 38, 33, 31, 56, 29, 48, 41, 46, 59, 52, 39, 53, 47, 40, 45, 44, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid content type, expected application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':  # Handle case when Content-Type header is not 'application/json'\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01810312271118164, "tests_passed": true, "error": null}}
{"selected_lines": [29, 46, 59, 44, 43, 56, 58, 57, 52, 53, 49, 37, 31, 54, 40, 47, 41, 45, 35, 48, 38, 34, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPServer.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if self.path == '/':  # if the path is '/' (the root directory),\n                self.send_response(400)  # Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [34, 57, 41, 33, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 57, 38, 53, 34, 49, 52, 47, 48, 44, 33, 46, 58, 31, 45, 43, 54, 29, 60, 40, 56, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002207040786743164, "tests_passed": true, "error": null}}
{"selected_lines": [48, 59, 29, 52, 40, 31, 58, 41, 35, 33, 38, 43, 56, 47, 37, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002319812774658203, "tests_passed": true, "error": null}}
{"selected_lines": [40, 57, 60, 43, 45, 41, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 56, 41, 33, 31, 43, 54, 60, 29, 37, 44, 52, 47, 53, 48, 40, 46, 34, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':  # If Content-Type is not application/json, respond with an error\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/python", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 54, 39, 59, 37, 45, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful response\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022096633911132812, "tests_passed": true, "error": null}}
{"selected_lines": [58, 39, 47, 45, 44, 54, 48, 33, 49, 43, 31, 34, 59, 60, 29, 57, 53, 52, 46, 56, 40, 37, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 40, 35, 41, 37, 57, 54, 47, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023288726806640625, "tests_passed": true, "error": null}}
{"selected_lines": [43, 39, 60, 49, 52, 40, 33, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 43, 59, 35, 33, 58, 34, 41, 31, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {'status': 'error', 'message': 'Content-Type header is not application/json'}\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 44, 53, 58, 37, 34, 35, 41, 40, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid HTTP request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021839141845703125, "tests_passed": true, "error": null}}
{"selected_lines": [49, 37, 39, 47, 38, 44, 29, 33, 34, 52, 57, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 37, 49, 53, 44, 43, 38, 41, 31, 33, 59, 39, 29, 48, 35, 58, 57, 46, 52, 54, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Invalid JSON request.',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful response\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [33, 31, 53, 38, 58, 37, 52, 56, 44, 54, 49, 46, 34, 29, 39, 40, 43, 48, 35, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 31, 29, 40, 45, 49, 53, 56, 47, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = f\"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0030400753021240234, "tests_passed": true, "error": null}}
{"selected_lines": [31, 54, 41, 58, 44, 59, 43, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022630691528320312, "tests_passed": true, "error": null}}
{"selected_lines": [37, 58, 47, 40, 31, 52, 43, 29, 59, 56, 45, 54, 60, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the request success\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002198934555053711, "tests_passed": true, "error": null}}
{"selected_lines": [45, 47, 35, 43, 39, 58, 53, 49, 41, 31, 60, 34, 54, 38, 59, 29, 37, 46, 56, 52, 44, 40, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid content type, expected application/json\"})\n                'status': 'error',\n                'message': 'Invalid content type. Content-Type: application/json is required.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 41, 49, 31, 37, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002408266067504883, "tests_passed": true, "error": null}}
{"selected_lines": [34, 46, 47, 58, 33, 45, 39, 57, 31, 52, 37, 59, 35, 53, 40, 29, 48, 44, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 39, 52, 31, 45, 37, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':  # If Content-Type is not application/json, respond with an error\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002360820770263672, "tests_passed": true, "error": null}}
{"selected_lines": [33, 38, 53, 59, 54, 35, 56, 58, 52, 57, 48, 40, 47, 46, 49, 34, 29, 39, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {'status': 'error', 'message': 'Content-Type header is not application/json'}\n                'status': 'error',\n                'message': 'Invalid HTTP POST request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 34, 31, 58, 41, 46, 44, 59, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021200180053710938, "tests_passed": true, "error": null}}
{"selected_lines": [54, 57, 44, 40, 34, 33, 39, 41, 59, 31, 38, 43, 49, 60, 48, 35, 29, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Set status code as 400, Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import math", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [44, 60, 43, 59, 45, 52, 38, 35, 46, 47, 39, 48, 56, 49, 40, 37, 29, 33, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = self.headers.getheaders('content-type')\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid request.\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 49, 41, 43, 37, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if self.path == '/':  # if the path is '/' (the root directory),\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.00257110595703125, "tests_passed": true, "error": null}}
{"selected_lines": [35, 57, 31, 29, 37, 58, 34, 54, 47, 44, 59, 49, 45, 60, 48, 38, 46, 33, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Invalid JSON request.',\n            }\n            if self.path == '/':  # if the path is '/' (the root directory),\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 56, 47, 34, 45, 37, 43, 59, 38, 44, 53, 54, 29, 39, 60, 40, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if self.path == '/':  # if the path is '/' (the root directory),\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021979808807373047, "tests_passed": true, "error": null}}
{"selected_lines": [49, 29, 59, 56, 54, 48, 58, 45, 37, 38, 52, 53, 31, 41, 39, 34, 57, 60, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002273082733154297, "tests_passed": true, "error": null}}
{"selected_lines": [34, 48, 57, 59, 60, 49, 33, 44, 40, 56, 53, 47, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 49, 44, 46, 58, 29, 37, 47, 38, 31, 43, 35, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid HTTP POST request'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021429061889648438, "tests_passed": true, "error": null}}
{"selected_lines": [33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps(\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": false, "time": 0.00030612945556640625, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [56, 33, 53, 45, 46, 58, 37, 35, 38, 57, 40, 48, 34, 29, 41, 43, 39, 47, 60, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPServer.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'No data received'})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import cgi", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [33, 57, 56, 44, 31, 54, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 52, 58, 53, 57, 54, 56, 37, 49, 59, 34, 29, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022728443145751953, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [49, 40, 29, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'}\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = f\"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid content type. Content-Type: application/json is required.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.02257704734802246, "tests_passed": true, "error": null}}
{"selected_lines": [33, 31, 59, 34, 58, 39, 56, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [35, 44, 58, 45, 31, 29, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Content-Length', str(len(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022411346435546875, "tests_passed": true, "error": null}}
{"selected_lines": [58, 38, 34, 35, 56, 33, 41, 53, 49, 46, 39, 52, 47, 60, 57, 59, 40, 37, 48, 45, 43, 29, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if not 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 57, 37, 46, 52, 41, 31, 33, 49, 29, 34, 58, 38, 47, 53, 45, 56, 40, 54, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Invalid HTTP POST request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful processing\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 43, 29, 48, 45, 54, 41, 39, 57, 37, 34, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002259969711303711, "tests_passed": true, "error": null}}
{"selected_lines": [45, 46, 53, 47, 44, 29, 33, 58, 57, 40, 34, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 38, 46, 33, 54, 56, 60, 47, 31, 39, 49, 44, 37, 45, 35, 41, 53, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid Content-Type. Please send JSON data.\"})\n                'status': 'error',\n                'message': 'Invalid HTTP POST request'\n            }\n            if ctype != 'application/json':  # Handle case when Content-Type header is not 'application/json'\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [37, 47, 33, 39, 56, 43, 40, 49, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31, 39, 44, 47, 46, 48, 40, 37, 41, 54, 45, 59, 56, 49, 34, 35, 53, 33, 58, 60, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [29, 40, 49, 43, 37, 41, 53, 47, 44, 57, 59, 52, 38, 54, 45, 31, 33, 46, 56, 58, 60, 39, 35, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)  # HTTP 400 - Bad Request\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31, 41, 48, 53, 33, 44, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0026102066040039062, "tests_passed": true, "error": null}}
{"selected_lines": [57, 40, 29, 59, 31, 46, 54, 58, 33, 53, 60, 35, 34, 43, 45, 48, 56, 47, 49, 44, 41, 52, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = f\"Content-Type header is not application/json\"\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('UTF-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021979808807373047, "tests_passed": true, "error": null}}
{"selected_lines": [47, 37, 34, 40, 54, 49, 35, 52, 48, 41, 46, 29, 31, 57, 58, 38, 56, 60, 43, 59, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Invalid Content-Type: {}, Expected: application/json'.format(ctype)\n            }\n            if self.headers.get('content-type') != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Content-Length', str(len(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 48, 39, 41, 57, 37, 31, 54, 52, 49, 47, 45, 59, 56, 34, 35, 29, 58, 44, 53, 33, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002274036407470703, "tests_passed": true, "error": null}}
{"selected_lines": [54, 39, 46, 43, 31, 35, 37, 34, 45, 48, 52, 49, 29, 44, 41, 38, 56, 59, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'}\n            }\n            if self.headers.get('content-type') != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31, 33, 29, 35, 53, 59, 45, 40, 41, 57, 48, 39, 46, 56, 38, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Invalid Content-Type: {}, Expected: application/json'.format(ctype)\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [33, 39, 56, 60, 44, 40, 37, 38, 46, 57, 43, 49, 41, 52, 54, 29, 34, 53, 31, 59, 45, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.Handler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid Content-Type: {}, Expected: application/json'.format(ctype)\n            }\n            if self.headers.get('content-type') != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022230148315429688, "tests_passed": true, "error": null}}
{"selected_lines": [34, 37, 56, 29, 38, 41, 60, 43, 59, 44, 53, 57, 54, 48, 58, 52, 31, 40, 47, 35, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':  # If Content-Type is not application/json, respond with an error\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002263784408569336, "tests_passed": true, "error": null}}
{"selected_lines": [35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017130136489868164, "tests_passed": true, "error": null}}
{"selected_lines": [47, 35, 56, 58, 53, 43, 41, 57, 31, 29, 49, 34, 52, 40, 60, 38, 48, 37, 44, 33, 39, 59, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if self.path == '/':  # if the path is '/' (the root directory),\n                self.send_response(400)  # HTTP 400 - Bad Request\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Invalid content type. Expected application/json.'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 47, 45, 35, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid Content-Type: {}, Expected: application/json'.format(ctype)\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022058486938476562, "tests_passed": true, "error": null}}
{"selected_lines": [38, 59, 48, 45, 60, 37, 43, 52, 58, 41, 31, 33, 34, 53, 54, 57, 29, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers['content-length'])\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import cgi", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [37, 48, 56, 34, 53, 43, 52, 33, 40, 39, 49, 29, 44, 46, 58, 31, 57, 59, 41, 38, 45, 60, 54, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid request.\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 58, 37, 49, 53, 52, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Content-length', len(json.dumps(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import math", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 54, 53, 38, 29, 43, 46, 40, 41, 48, 39, 47, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002256155014038086, "tests_passed": true, "error": null}}
{"selected_lines": [33, 46, 44, 34, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 31, 58, 45, 47, 38, 41, 48, 60, 56, 37, 29, 54, 34, 46, 35, 40, 33, 53, 44, 52, 39, 59, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':  # Handle case when Content-Type header is not 'application/json'\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Content-length', len(json.dumps(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [35, 53, 40, 37, 43, 39, 47, 59, 58, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022568702697753906, "tests_passed": true, "error": null}}
{"selected_lines": [45, 29, 31, 58, 33, 56, 41, 43, 57, 52, 44, 46, 40, 59, 37, 34, 38, 54, 39, 35, 48, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid Content-Type. Please send JSON data.\"})\n                'status': 'error',\n                'message': 'Invalid JSON request.',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 means \"Bad Request\", a generic status code\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers['content-length'])\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [34, 43, 53, 47, 44, 57, 52, 39, 29, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode('utf-8')\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.003185272216796875, "tests_passed": true, "error": null}}
{"selected_lines": [37, 56, 43, 35, 59, 46, 58, 38, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Invalid JSON request.',\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [56, 52, 38, 29, 31, 41, 37, 54, 35, 49, 40, 39, 47, 53, 34, 59, 45, 57, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0033407211303710938, "tests_passed": true, "error": null}}
{"selected_lines": [43, 56, 45, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 31, 46, 53, 58, 49, 38, 29, 35, 47, 34, 56, 54, 52, 41, 37, 43, 45, 39, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if not isinstance(message, dict):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the request success\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.003293275833129883, "tests_passed": true, "error": null}}
{"selected_lines": [35, 29, 49, 41, 37, 34, 46, 47, 53, 33, 58, 31, 60, 48, 52, 54, 45, 44, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [29, 52, 40, 43, 38, 48, 41, 45, 59, 47, 31, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.003039121627807617, "tests_passed": true, "error": null}}
{"selected_lines": [54, 47, 57, 39, 44, 41, 48, 58, 33, 31, 29, 37, 34, 59, 45, 38, 52, 56, 40, 46, 60, 49, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid Content-Type. Please send JSON data.\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 39, 46, 35, 31, 41, 29, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0026078224182128906, "tests_passed": true, "error": null}}
{"selected_lines": [37, 39, 43, 31, 44, 34, 52, 54, 38, 58, 59, 60, 29, 33, 53, 35, 40, 46, 41, 47, 56, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'Content-Type header is not application/json'})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if self.headers.get('content-type') != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [29, 58, 57, 43, 47, 48, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0024261474609375, "tests_passed": true, "error": null}}
{"selected_lines": [58, 31, 35, 44, 33, 57, 38, 49, 41, 37, 43, 47, 59, 54, 48, 56, 52, 39, 60, 53, 45, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful response\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0024712085723876953, "tests_passed": true, "error": null}}
{"selected_lines": [37, 57, 29, 45, 40, 39, 43, 48, 60, 58, 49, 47, 34, 52, 56, 38, 53, 44, 54, 35, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid content type. Content-Type: application/json is required.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0024340152740478516, "tests_passed": true, "error": null}}
{"selected_lines": [37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':  # If Content-Type is not application/json, respond with an error\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.02260303497314453, "tests_passed": true, "error": null}}
{"selected_lines": [60, 41, 31, 57, 45, 44, 54, 56, 40, 52, 39, 34, 47, 46, 59, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid Content-Type: {}, Expected: application/json'.format(ctype)\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0024671554565429688, "tests_passed": true, "error": null}}
{"selected_lines": [38, 54, 52, 41, 34, 53, 39, 37, 45, 33, 47, 43, 49, 35, 56, 31, 57, 60, 59, 58, 44, 29, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 34, 58, 35, 45, 39, 43, 49, 57, 29, 56, 33, 40, 37, 48, 52, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 38, 53, 37, 34, 49, 29, 44, 60, 40, 48, 41, 33, 35, 58, 59, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if not 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002273082733154297, "tests_passed": true, "error": null}}
{"selected_lines": [52, 47, 37, 43, 45, 59, 44, 29, 54, 57, 40, 53, 46, 58, 35, 31, 41, 33, 48, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [38, 49, 37, 52, 41, 58, 47, 39, 33, 44, 34, 40, 48, 53, 57, 60, 29, 46, 43, 31, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/python", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.018255949020385742, "tests_passed": true, "error": null}}
{"selected_lines": [40, 56, 39, 60, 46, 37, 57, 41, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0027480125427246094, "tests_passed": true, "error": null}}
{"selected_lines": [57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.018255949020385742, "tests_passed": true, "error": null}}
{"selected_lines": [56, 49, 34, 47, 31, 54, 52, 44, 39, 41, 57, 33, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [53, 31, 43, 52, 45, 41, 29, 46, 47, 33, 49, 59, 54, 57, 60, 56, 58, 39, 44, 48, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 60, 59, 43, 47, 40, 56, 34, 46, 41, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers['content-length'])\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022330284118652344, "tests_passed": true, "error": null}}
{"selected_lines": [31, 41, 48, 53, 33, 44, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0026102066040039062, "tests_passed": true, "error": null}}
{"selected_lines": [29, 44, 58, 53, 31, 33, 46, 34, 49, 37, 41, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps(\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 57, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023300647735595703, "tests_passed": true, "error": null}}
{"selected_lines": [35, 29, 58, 59, 47, 40, 41, 49, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002197742462158203, "tests_passed": true, "error": null}}
{"selected_lines": [49, 40, 53, 47, 54, 43, 34, 38, 48, 58, 57, 59, 35, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Set status code as 400, Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.00226593017578125, "tests_passed": true, "error": null}}
{"selected_lines": [45, 59, 57, 39, 53, 60, 31, 29, 52, 44, 47, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022242069244384766, "tests_passed": true, "error": null}}
{"selected_lines": [34, 60, 31, 43, 57, 53, 41, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 41, 38, 54, 58, 45, 34, 52, 59, 48, 46, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002343893051147461, "tests_passed": true, "error": null}}
{"selected_lines": [43, 54, 52, 35, 49, 37, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':  # Handle case when Content-Type header is not 'application/json'\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022058486938476562, "tests_passed": true, "error": null}}
{"selected_lines": [58, 60, 54, 56, 33, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid content type, expected application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 38, 58, 43, 45, 59, 33, 46, 44, 29, 53, 41, 54, 47, 48, 34, 57, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {'status': 'error', 'message': 'Content-Type header is not application/json'}\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 43, 39, 56, 44, 29, 49, 48, 54, 57, 45, 35, 34, 33, 53, 41, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import math", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 45, 49, 39, 31, 59, 41, 44, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = self.headers.getheaders('content-type')\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023469924926757812, "tests_passed": true, "error": null}}
{"selected_lines": [56, 41, 47, 52, 43, 57, 59, 40, 44, 38, 37, 45, 29, 39, 49, 58, 54, 34, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = self.headers.getheaders('content-type')\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002149820327758789, "tests_passed": true, "error": null}}
{"selected_lines": [34, 60, 37, 43, 40, 59, 58, 33, 29, 45, 38, 48, 56, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid Content-Type. Please send JSON data.\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if self.headers.get('content-type') != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 60, 47, 46, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Set status code as 400, Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import cgi", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.023078203201293945, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [43, 48, 49, 41, 31, 53, 40, 47, 44, 38, 39, 46, 52, 29, 56, 54, 33, 58, 45, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = self.headers.getheaders('content-type')\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Return a 400 error response\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 47, 41, 44, 29, 56, 31, 53, 33, 39, 45, 52, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 33, 49, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import math", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 40, 44, 31, 49, 56, 47, 39, 54, 53, 37, 58, 33, 34, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Content-length', len(json.dumps(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002383708953857422, "tests_passed": true, "error": null}}
{"selected_lines": [53, 57, 37, 33, 56, 59, 47, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31, 58, 54, 45, 29, 59, 33, 37, 46, 49, 53, 39, 34, 47, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length')) if 'Content-Length' in self.headers else 0\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002329111099243164, "tests_passed": true, "error": null}}
{"selected_lines": [56, 49, 34, 29, 46, 35, 37, 39, 45, 47, 44, 41, 48, 58, 33, 60, 38, 54, 53, 43, 31, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import cgi", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [60, 38, 49, 59, 29, 56, 39, 31, 46, 45, 41, 34, 58, 54, 33, 52, 37, 48, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 56, 53, 60, 54, 39, 35, 49, 43, 38, 29, 33, 34, 45, 37, 58, 57, 31, 40, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid content type. Content-Type: application/json is required.'\n            }\n            if self.path == '/':  # if the path is '/' (the root directory),\n                self.send_response(400)  # Return a 400 error response\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023348331451416016, "tests_passed": true, "error": null}}
{"selected_lines": [43, 59, 57, 54, 49, 41, 53, 33, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [37, 44, 52, 47, 60, 31, 46, 48, 41, 56, 59, 35, 33, 58, 43, 40, 57, 39, 38, 29, 54, 45, 34, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [33, 48, 52, 59, 60, 56, 40, 35, 41, 34, 29, 58, 44, 31, 54, 57, 39, 49, 38, 45, 46, 43, 47, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid JSON request.',\n            }\n            if ctype != 'application/json':  # Handle case when Content-Type header is not 'application/json'\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Content-Length', str(len(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022008419036865234, "tests_passed": true, "error": null}}
{"selected_lines": [60, 41, 47, 38, 54, 57, 44, 59, 45, 58, 29, 49, 48, 40, 34, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023250579833984375, "tests_passed": true, "error": null}}
{"selected_lines": [33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": false, "time": 0.00047707557678222656, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.018169641494750977, "tests_passed": true, "error": null}}
{"selected_lines": [33, 59, 45, 31, 58, 57, 47, 52, 60, 46, 43, 29, 48, 35, 54, 38, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31, 45, 53, 44, 54, 60, 59, 40, 38, 35, 34, 48, 58, 52, 29, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021800994873046875, "tests_passed": true, "error": null}}
{"selected_lines": [37, 41, 40, 49, 38, 59, 52, 56, 48, 58, 31, 47, 34, 44, 45, 29, 46, 60, 54, 43, 33, 35, 57, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':  # Handle case when Content-Type header is not 'application/json'\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31, 40, 46, 29, 38, 35, 60, 44, 41, 59, 45, 34, 58, 33, 56, 54, 37, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'}\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [35, 43, 46, 33, 38, 37, 34, 31, 54, 58, 56, 40, 49, 44, 47, 39, 41, 53, 29, 59, 57, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002293825149536133, "tests_passed": true, "error": null}}
{"selected_lines": [60, 43, 52, 56, 34, 45, 49, 29, 58, 54, 33, 31, 46, 38, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002165555953979492, "tests_passed": true, "error": null}}
{"selected_lines": [43, 40, 54, 60, 31, 39, 33, 37, 45, 49, 58, 53, 29, 56, 46, 35, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import math", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [34, 47, 53, 60, 38, 37, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':  # If Content-Type is not application/json, respond with an error\n                self.send_response(400)  # Bad request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017130136489868164, "tests_passed": true, "error": null}}
{"selected_lines": [48, 56, 45, 40, 58, 39, 59, 38, 29, 54, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002298116683959961, "tests_passed": true, "error": null}}
{"selected_lines": [40, 33, 56, 58, 52, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [56, 59, 57, 43, 45, 48, 41, 52, 49, 54, 47, 60, 58, 34, 38, 35, 44, 29, 33, 39, 31, 37, 46, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # HTTP 400 - Bad Request\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 60, 40, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021359920501708984, "tests_passed": true, "error": null}}
{"selected_lines": [53, 38, 29, 60, 54, 49, 33, 45, 52, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 47, 40, 49, 29, 45, 37, 56, 57, 35, 39, 60, 48, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid Content-Type header'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 40, 31, 60, 57, 48, 41, 49, 59, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Invalid content type. Expected application/json.'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002275228500366211, "tests_passed": true, "error": null}}
{"selected_lines": [34, 46, 45, 48, 29, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0024390220642089844, "tests_passed": true, "error": null}}
{"selected_lines": [38, 49, 59, 37, 60, 43, 31, 56, 53, 34, 40, 44, 29, 39, 35, 46, 41, 52, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = f\"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021660327911376953, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [44, 43, 48, 49, 60, 52, 54, 40, 57, 35, 37, 53, 39, 59, 34, 41, 46, 58, 47, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid HTTP request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023229122161865234, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [56, 53, 37, 46, 43, 59, 34, 60, 40, 44, 48, 47, 29, 35, 39, 38, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPServer.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022618770599365234, "tests_passed": true, "error": null}}
{"selected_lines": [39, 44, 41, 46, 31, 45, 56, 43, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022840499877929688, "tests_passed": true, "error": null}}
{"selected_lines": [29, 34, 49, 58, 59, 57, 56, 38, 35, 53, 41, 48, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # HTTP 400 - Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002207040786743164, "tests_passed": true, "error": null}}
{"selected_lines": [53, 48, 52, 34, 57, 44, 54, 37, 58, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002531766891479492, "tests_passed": true, "error": null}}
{"selected_lines": [43, 45, 41, 56, 35, 40, 59, 29, 33, 52, 54, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022292137145996094, "tests_passed": true, "error": null}}
{"selected_lines": [45, 35, 49, 41, 46, 33, 37, 53, 43, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps(\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [34, 58, 60, 31, 45, 59, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import cgi", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 60, 43, 58, 38, 39, 41, 40, 59, 31, 47, 52, 54, 49, 46, 33, 37, 57, 35, 45, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('UTF-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 58, 41, 49, 57, 43, 29, 38, 52, 37, 34, 46, 60, 48, 31, 35, 39, 44, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002319812774658203, "tests_passed": true, "error": null}}
{"selected_lines": [46, 58, 35, 31, 47, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002195119857788086, "tests_passed": true, "error": null}}
{"selected_lines": [45, 35, 57, 38, 52, 47, 56, 58, 54, 43, 49, 48, 34, 46, 33, 44, 40, 60, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid Content-Type. Please send JSON data.\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful processing\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 43, 58, 39, 33, 45, 60, 37, 57, 47, 46, 54, 34, 59, 29, 56, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':  # If Content-Type is not application/json, respond with an error\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>class MyCalc:", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 39, 44, 31, 58, 49, 52, 40, 37, 46, 34, 48, 60, 35, 57, 43, 56, 41, 45, 53, 33, 29, 47, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid request.\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 52, 35, 59, 37, 47, 39, 31, 46, 34, 43, 29, 49, 48, 56, 33, 54, 44, 53, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023500919342041016, "tests_passed": true, "error": null}}
{"selected_lines": [31, 29, 46, 37, 60, 49, 48, 43, 53, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002227783203125, "tests_passed": true, "error": null}}
{"selected_lines": [54, 38, 48, 33, 44, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid content type, expected application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [38, 56, 45, 53, 39, 37, 31, 43, 34, 54, 35, 29, 57, 33, 52, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 33, 43, 31, 46, 48, 49, 29, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 59, 60, 58, 46, 34, 29, 37, 52, 45, 57, 40, 41, 33, 56, 39, 31, 48, 38, 47, 44, 43, 53, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid request.\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017130136489868164, "tests_passed": true, "error": null}}
{"selected_lines": [33, 60, 59, 43, 34, 48, 52, 45, 40, 37, 31, 53, 39, 38, 35, 49, 29, 41, 47, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Invalid Content-Type header'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.019624948501586914, "tests_passed": true, "error": null}}
{"selected_lines": [34, 60, 33, 52, 41, 45, 35, 59, 39, 44, 40, 43, 54, 37, 38, 47, 46, 29, 49, 31, 57, 56, 53, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [29, 37, 46, 38, 54, 44, 59, 56, 47, 49, 60, 45, 34, 53, 31, 33, 43, 57, 52, 48, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Set status code as 400, Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 43, 59, 54, 33, 38, 29, 58, 57, 31, 37, 53, 49, 47, 52, 39, 34, 48, 41, 46, 35, 56, 60, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid Content-Type. Please send JSON data.\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 58, 49, 53, 38, 59, 60, 39, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Set status code as 400, Bad Request\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023741722106933594, "tests_passed": true, "error": null}}
{"selected_lines": [37, 39, 56, 40, 52, 33, 41, 58, 54, 57, 29, 59, 46, 44, 35, 53, 38, 48, 31, 47, 45, 34, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021979808807373047, "tests_passed": true, "error": null}}
{"selected_lines": [59, 46, 40, 37, 52, 44, 31, 33, 34, 54, 47, 48, 45, 49, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002301931381225586, "tests_passed": true, "error": null}}
{"selected_lines": [56, 33, 47, 44, 29, 31, 38, 48, 35, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'Content-Type header is not application/json'})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 41, 53, 43, 60, 56, 47, 33, 46, 34, 48, 31, 49, 59, 40, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022339820861816406, "tests_passed": true, "error": null}}
{"selected_lines": [33, 58, 45, 40, 41, 48, 53, 43, 54, 44, 59, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 38, 35, 47, 49, 56, 33, 40, 59, 53, 37, 29, 39, 58, 60, 34, 41, 57, 54, 48, 52, 31, 44, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid content type, expected application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [33, 39, 31, 60, 54, 58, 44, 47, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002374887466430664, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [54, 47, 46, 44, 58, 35, 37, 57, 56, 31, 43, 34, 45, 29, 49, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length')) if 'Content-Length' in self.headers else 0\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022449493408203125, "tests_passed": true, "error": null}}
{"selected_lines": [54, 33, 39, 34, 37, 57, 47, 31, 59, 44, 49, 45, 35, 46, 41, 38, 40, 52, 43, 56, 60, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31, 39, 33, 34, 48, 54, 43, 56, 52, 45, 47, 40, 58, 57, 59, 38, 35, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # HTTP 400 - Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 46, 52, 56, 38, 44, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023279190063476562, "tests_passed": true, "error": null}}
{"selected_lines": [60, 34, 37, 44, 43, 57, 33, 47, 29, 35, 41, 52, 39, 58, 40, 59, 38, 53, 46, 56, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.Handler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [40, 57, 58, 52, 46, 34, 48, 33, 54, 56, 29, 37, 39, 45, 59, 31, 35, 49, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002168893814086914, "tests_passed": true, "error": null}}
{"selected_lines": [33, 57, 45, 35, 41, 29, 34, 48, 60, 40, 59, 44, 54, 47, 43, 52, 49, 46, 56, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>class MyCalc:", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.022449016571044922, "tests_passed": true, "error": null}}
{"selected_lines": [48, 41, 57, 53, 54, 37, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023300647735595703, "tests_passed": true, "error": null}}
{"selected_lines": [60, 56, 40, 43, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002212047576904297, "tests_passed": true, "error": null}}
{"selected_lines": [35, 29, 58, 59, 47, 40, 41, 49, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002197742462158203, "tests_passed": true, "error": null}}
{"selected_lines": [37, 40, 53, 58, 39, 34, 38, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023462772369384766, "tests_passed": true, "error": null}}
{"selected_lines": [37, 40, 54, 43, 59, 46, 35, 44, 57, 52, 49, 31, 45, 56, 38, 29, 58, 47, 39, 60, 34, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import math", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 38, 53, 29, 59, 54, 57, 33, 52, 46, 43, 47, 31, 39, 45, 37, 60, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = self.headers.getheaders('content-type')\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021660327911376953, "tests_passed": true, "error": null}}
{"selected_lines": [54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.022304058074951172, "tests_passed": true, "error": null}}
{"selected_lines": [29, 46, 40, 47, 52, 39, 49, 41, 48, 38, 33, 53, 37, 45, 60, 58, 59, 34, 57, 54, 31, 44, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode('UTF-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 34, 31, 47, 38, 58, 35, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0024099349975585938, "tests_passed": true, "error": null}}
{"selected_lines": [59, 56, 43, 34, 35, 40, 53, 39, 54, 49, 44, 41, 60, 57, 29, 33, 45, 31, 52, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>class MyCalc:", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 57, 60, 53, 43, 39, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022211074829101562, "tests_passed": true, "error": null}}
{"selected_lines": [57, 48, 59, 38, 58, 43, 34, 33, 53, 45, 52, 39, 31, 56, 49, 46, 60, 54, 40, 37, 35, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'No data received'})\n                'status': 'error',\n                'message': 'Invalid content type. Content-Type: application/json is required.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Invalid content type. Expected application/json.'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 59, 31, 41, 39, 37, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021729469299316406, "tests_passed": true, "error": null}}
{"selected_lines": [34, 43, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.019624948501586914, "tests_passed": true, "error": null}}
{"selected_lines": [52, 58, 35, 37, 57, 56, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0024459362030029297, "tests_passed": true, "error": null}}
{"selected_lines": [52, 44, 49, 59, 40, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002259969711303711, "tests_passed": true, "error": null}}
{"selected_lines": [38, 29, 33, 45, 31, 53, 52, 41, 48, 47, 39, 43, 56, 44, 58, 35, 37, 34, 57, 60, 54, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.Handler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'Content-Type header is not application/json'})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [57, 29, 48, 39, 43, 47, 52, 44, 35, 54, 38, 56, 53, 31, 40, 46, 33, 37, 60, 49, 45, 41, 34, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022258758544921875, "tests_passed": true, "error": null}}
{"selected_lines": [41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.018372774124145508, "tests_passed": true, "error": null}}
{"selected_lines": [53, 58, 37, 44, 39, 35, 48, 29, 49, 59, 41, 46, 38, 57, 47, 60, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Invalid content type. Content-Type: application/json is required.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Return a 400 error response\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode('utf-8')\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 35, 58, 44, 34, 46, 53, 49, 31, 33, 37, 38, 48, 60, 59, 47, 45, 52, 40, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Return a 400 error response\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers['content-length'])\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/env python3", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017935991287231445, "tests_passed": true, "error": null}}
{"selected_lines": [29, 39, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002332925796508789, "tests_passed": true, "error": null}}
{"selected_lines": [35, 52, 49, 31, 37, 44, 59, 38, 48, 39, 33, 57, 43, 54, 56, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}\n                'status': 'error',\n                'message': 'Invalid HTTP POST request'\n            }\n            if self.path == '/':  # if the path is '/' (the root directory),\n                self.send_response(400)  # Return a 400 error response\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 40, 48, 57, 47, 39, 58, 53, 54, 38, 52, 35, 34, 46, 60, 37, 31, 44, 41, 45, 49, 59, 29, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 46, 39, 54, 58, 41, 49, 29, 60, 53, 31, 38, 37, 45, 47, 35, 48, 33, 57, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json.'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)  # Bad Request\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if not 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/env python3", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 34, 57, 37, 31, 56, 38, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if self.headers.get('content-type') != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022039413452148438, "tests_passed": true, "error": null}}
{"selected_lines": [37, 44, 34, 38, 31, 48, 52, 33, 35, 53, 58, 56, 54, 47, 60, 45, 43, 59, 41, 49, 46, 40, 29, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid request.\"})\n                'status': 'error',\n                'message': 'Invalid HTTP POST request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [35, 43, 54, 59, 52, 40, 41, 49, 53, 39, 57, 58, 33, 45, 34, 38, 56, 31, 37, 60, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Content-length', len(json.dumps(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 58, 47, 60, 39, 34, 49, 35, 48, 38, 40, 54, 43, 45, 33, 59, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [38, 44, 52, 53, 41, 46, 60, 56, 29, 39, 33, 47, 35, 59, 48, 34, 58, 54, 57, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Return a 400 error response\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [35, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022478103637695312, "tests_passed": true, "error": null}}
{"selected_lines": [40, 31, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0025942325592041016, "tests_passed": true, "error": null}}
{"selected_lines": [40, 29, 53, 48, 52, 59, 41, 49, 31, 54, 56, 44, 46, 38, 33, 34, 60, 37, 47, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if self.headers.get('content-type') != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid request.\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": false, "time": 0.0002238750457763672, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [57, 35, 41, 56, 45, 29, 58, 49, 48, 37, 52, 44, 47, 33, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [33, 48, 49, 52, 37, 29, 58, 54, 46, 56, 38, 59, 39, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002357006072998047, "tests_passed": true, "error": null}}
{"selected_lines": [43, 35, 60, 39, 59, 41, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid Content-Type: {}, Expected: application/json'.format(ctype)\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0025169849395751953, "tests_passed": true, "error": null}}
{"selected_lines": [58, 56, 43, 57, 49, 52, 40, 54, 29, 46, 41, 48, 35, 31, 39, 60, 47, 37, 33, 44, 34, 59, 53, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.Handler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Content-Length', str(len(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002232074737548828, "tests_passed": true, "error": null}}
{"selected_lines": [57, 39, 43, 40, 34, 56, 58, 60, 46, 31, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023238658905029297, "tests_passed": true, "error": null}}
{"selected_lines": [46, 49, 52, 44, 29, 57, 45, 41, 40, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022127628326416016, "tests_passed": true, "error": null}}
{"selected_lines": [38, 57, 29, 46, 40, 49, 53, 54, 44, 60, 41, 34, 47, 56, 52, 31, 45, 43, 58, 35, 33, 39, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 37, 31, 52, 53, 43, 44, 29, 35, 33, 47, 41, 56, 60, 48, 54, 58, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers['content-length'])\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 59, 52, 49, 56, 60, 47, 53, 33, 41, 39, 38, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0024292469024658203, "tests_passed": true, "error": null}}
{"selected_lines": [53, 34, 59, 52, 31, 39, 56, 44, 58, 54, 38, 48, 40, 46, 33, 49, 29, 60, 37, 57, 45, 47, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Invalid content type. Content-Type: application/json is required.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [45, 41, 54, 37, 59, 58, 33, 43, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length')) if 'Content-Length' in self.headers else 0\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022611618041992188, "tests_passed": true, "error": null}}
{"selected_lines": [41, 53, 57, 60, 54, 44, 49, 40, 56, 39, 33, 38, 48, 37, 59, 52, 34, 46, 45, 47, 58, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers['content-length'])\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/python", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 33, 38, 47, 60, 31, 39, 40, 41, 52, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/python", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [37, 38, 34, 41, 49, 56, 35, 45, 46, 43, 39, 53, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023698806762695312, "tests_passed": true, "error": null}}
{"selected_lines": [48, 33, 41, 34, 60, 31, 38, 57, 37, 49, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPServer.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 39, 44, 54, 45, 56, 35, 48, 59, 33, 40, 38, 49, 46, 34, 37, 53, 52, 43, 31, 58, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Invalid Content-Type header'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 38, 44, 35, 59, 60, 47, 41, 31], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>class MyCalc:", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [29, 57, 33, 37, 56, 31, 59, 54, 35, 40, 38, 44, 52, 53, 45, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Return a 400 error response\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002218008041381836, "tests_passed": true, "error": null}}
{"selected_lines": [41, 31, 35, 54, 60, 39, 59, 33, 44, 49, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid content type, expected application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [37, 44, 54, 35, 58, 49, 38, 56, 39, 40, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = f\"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023522377014160156, "tests_passed": true, "error": null}}
{"selected_lines": [53, 46, 57, 33, 31, 60, 29, 48, 59, 40, 58, 44, 35, 37, 49, 39, 34, 54, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 54, 60, 40, 45, 46, 37, 34, 56, 59, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if self.path == '/':  # if the path is '/' (the root directory),\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022079944610595703, "tests_passed": true, "error": null}}
{"selected_lines": [49, 43, 59, 37, 34, 54, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022878646850585938, "tests_passed": true, "error": null}}
{"selected_lines": [53, 41, 46, 38, 44, 29, 57, 34, 40, 37, 59, 58, 60, 45, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPServer.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022521018981933594, "tests_passed": true, "error": null}}
{"selected_lines": [52, 35, 44, 53, 56, 48, 31, 38, 40, 46, 60, 47, 45, 59, 54, 39, 49, 41], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Set status code as 400, Bad Request\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002318859100341797, "tests_passed": true, "error": null}}
{"selected_lines": [54, 44, 38, 39, 47, 34, 52, 58, 60, 59, 33, 53, 49, 41, 43, 56, 35, 40, 46, 29, 48, 31, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002189159393310547, "tests_passed": true, "error": null}}
{"selected_lines": [57, 54, 29, 44, 35, 43, 59, 38, 40, 31, 37, 41, 49, 45, 47, 56, 34, 33, 48, 60, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':  # If Content-Type is not application/json, respond with an error\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode('utf-8')\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the successful processing\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017935991287231445, "tests_passed": true, "error": null}}
{"selected_lines": [37, 39, 45, 34, 33, 44, 43, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid content type, expected application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.024684906005859375, "tests_passed": true, "error": null}}
{"selected_lines": [43, 48, 38, 37, 59, 31, 53, 33, 34, 29, 56, 54, 47, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)  # Bad request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31, 57, 52, 54, 37, 49, 40, 58, 46, 38, 33, 35, 56, 53, 34, 59, 41, 60, 47, 44, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [46, 35, 39, 45, 41, 58, 48, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002315044403076172, "tests_passed": true, "error": null}}
{"selected_lines": [41, 38, 35, 46, 44, 31, 56, 47, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # HTTP 400 - Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021581649780273438, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [33, 45, 53, 44, 40, 34, 52, 39, 59, 38, 57, 56, 54, 43, 35, 49, 37, 31, 60, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps(\n                'status': 'error',\n                'message': 'Invalid Content-Type header'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 35, 57, 43, 56, 38, 54, 58, 45, 39, 59, 52, 29, 34, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022978782653808594, "tests_passed": true, "error": null}}
{"selected_lines": [40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.023078203201293945, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [52, 46, 44, 57, 41, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002218008041381836, "tests_passed": true, "error": null}}
{"selected_lines": [41, 34, 31, 29, 56, 54, 43, 58, 44, 53, 52, 35, 49, 39, 46, 59], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = self.headers.getheaders('content-type')\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002282857894897461, "tests_passed": true, "error": null}}
{"selected_lines": [44, 49, 45, 60, 56, 40, 41, 46, 43, 33, 31, 34, 52, 57, 38, 48, 29, 54, 35, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'}\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 54, 39, 33, 37, 40, 57, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Invalid content type. Expected application/json.'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid Content-Type: {}, Expected: application/json'.format(ctype)\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0234830379486084, "tests_passed": true, "error": null}}
{"selected_lines": [60, 39, 37, 46, 48, 49, 34, 40, 41, 52, 38, 35, 31, 47, 33, 29, 56, 45, 44, 54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Invalid content type. Content-Type: application/json is required.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 48, 57, 56, 58, 34, 33, 47, 38, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Return a 400 error response\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>import cgi", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 40, 41, 44, 47, 39, 54, 34, 33, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [39, 57, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002229928970336914, "tests_passed": true, "error": null}}
{"selected_lines": [29, 57, 31, 33, 40, 53, 47, 58, 39, 59, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 39, 48, 35], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022580623626708984, "tests_passed": true, "error": null}}
{"selected_lines": [53, 44, 39, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022230148315429688, "tests_passed": true, "error": null}}
{"selected_lines": [33, 39, 35, 41, 47, 48], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Invalid Content-Type: {}, Expected: application/json'.format(ctype)\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 33, 38, 52, 47, 58, 60, 48, 46, 31, 39, 56, 54, 59, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 39, 46, 38, 57, 59, 48, 45, 40, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0026509761810302734, "tests_passed": true, "error": null}}
{"selected_lines": [40, 35, 53, 37, 54, 43, 56, 57, 44, 48, 58, 46, 41, 59, 45, 47, 52, 49], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002231121063232422, "tests_passed": true, "error": null}}
{"selected_lines": [52, 49, 29, 54, 40, 45, 58, 35, 31, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.Handler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.00228118896484375, "tests_passed": true, "error": null}}
{"selected_lines": [54], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.022304058074951172, "tests_passed": true, "error": null}}
{"selected_lines": [35, 41, 48, 58, 34, 54, 56, 38, 45, 37, 33, 49, 31, 40, 53, 39, 43, 44, 57, 60, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Invalid HTTP POST request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Invalid content type. Expected application/json.'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [58, 31, 54, 44, 56, 37, 41, 46, 48, 60, 47, 35, 40, 52, 49, 39, 45, 33, 53, 43, 38], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps(\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers['content-length'])\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/env python3", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [54, 41, 44, 35, 60, 56, 39, 59, 38, 34, 48, 45, 37, 31, 52, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':  # Handle case when Content-Type header is not 'application/json'\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if not isinstance(message, dict):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002177000045776367, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [34, 33, 48, 37, 44, 41, 38, 35, 52, 54, 60, 47, 31, 59, 56, 29, 49, 40, 57, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)  # 400 means \"Bad Request\", a generic status code\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 49, 33, 29, 38, 48, 44, 35, 54, 46, 60], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # HTTP 400 - Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>class MyCalc:", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 43, 41, 53, 38, 37, 56, 48, 39, 40, 57, 59, 44, 31, 58, 54, 52, 47, 49, 33, 45, 29, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Invalid content type. Expected application/json.'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/env python3", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [31, 40, 58, 45, 46, 47, 49, 56, 57, 41, 54, 38, 48, 29, 34, 53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.send_header('Content-length', len(json.dumps(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023980140686035156, "tests_passed": true, "error": null}}
{"selected_lines": [35, 44, 41, 39, 58, 29, 46, 45, 52], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Content-length', len(json.dumps(success_response)))\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002191305160522461, "tests_passed": true, "error": null}}
{"selected_lines": [45, 59, 33, 49, 52, 47, 37, 38, 48, 40, 44, 46, 54, 43, 31, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps({'status': 'error', 'message': 'Content-Type header is not application/json'})\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [29, 45, 47, 49, 57, 38, 60, 46, 31, 48, 39, 43, 44, 37, 41, 53, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_headers(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022840499877929688, "tests_passed": true, "error": null}}
{"selected_lines": [58, 46, 44, 33, 56], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [34, 49, 43, 58, 33, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0024750232696533203, "tests_passed": true, "error": null}}
{"selected_lines": [48, 41, 43, 44, 38, 54, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021829605102539062, "tests_passed": true, "error": null}}
{"selected_lines": [48, 44, 52, 34, 60, 53, 37, 29, 45, 58, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023469924926757812, "tests_passed": true, "error": null}}
{"selected_lines": [39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.017567157745361328, "tests_passed": true, "error": null}}
{"selected_lines": [53], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.01789116859436035, "tests_passed": true, "error": null}}
{"selected_lines": [38, 58, 33], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = json.dumps({\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 41, 29, 59, 44, 35, 53, 56, 38, 45, 48, 31, 49, 46, 60, 57, 52, 33, 37, 40, 43], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, clength, fext = self.headers.getheaders('content-type')\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if self.path == '/':  # if the path is '/' (the root directory),\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0022377967834472656, "tests_passed": true, "error": null}}
{"selected_lines": [39, 43, 44, 52, 54, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023279190063476562, "tests_passed": true, "error": null}}
{"selected_lines": [49, 33, 39, 58, 34, 38, 59, 40, 52, 31, 57, 43, 35, 60, 47, 54, 56, 41, 45, 46, 29, 37, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.CGIHTTPServer.CGIHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>def task_func():", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [37, 48, 54, 45, 34, 49, 52, 40, 57, 38, 56, 41, 53, 35, 59, 33, 46, 29, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002190113067626953, "tests_passed": true, "error": null}}
{"selected_lines": [56, 35, 60, 47, 46, 38, 31, 57], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023059844970703125, "tests_passed": true, "error": null}}
{"selected_lines": [46, 56, 53, 35, 59, 37, 31, 54, 47, 57, 39, 38, 40, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype == 'application/json':\n                self.send_response(400, 'Content-Type header is not application/json')\n                self.send_header('Content-Type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the request success\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0021927356719970703, "tests_passed": true, "error": null}}
{"selected_lines": [56, 35, 45, 52, 33, 60, 41, 44, 57, 49, 29, 48, 43, 54, 53, 58, 31, 59, 40], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.Handler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(bytes(json.dumps(error_response), 'utf-8'))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>#!/usr/bin/python", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [59, 56, 48, 39, 34, 60, 35, 40, 49, 29, 33, 53, 47, 58, 38, 44, 41, 52, 54, 43, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.003512859344482422, "tests_passed": true, "error": null}}
{"selected_lines": [41, 46, 48, 52, 44], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002830982208251953, "tests_passed": true, "error": null}}
{"selected_lines": [57, 58, 54, 33, 59, 45], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0029449462890625, "tests_passed": true, "error": null}}
{"selected_lines": [44, 38, 58, 37, 54, 57, 53, 48, 31, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype == 'application/json':\n                self.send_response(400)  # 400 Bad Request\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = self.rfile.read(length).decode()\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002686023712158203, "tests_passed": true, "error": null}}
{"selected_lines": [58, 35, 47, 59, 60, 48, 34, 43, 44, 29], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid HTTP POST request'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0026471614837646484, "tests_passed": true, "error": null}}
{"selected_lines": [39, 46, 40, 56, 54, 58], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type'))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = \"Content-Type header is not application/json\"\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the data received\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0023801326751708984, "tests_passed": true, "error": null}}
{"selected_lines": [57, 45, 41, 40, 56, 43, 38, 49, 59, 33, 53, 35, 34, 29, 47, 54, 58, 31, 46], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get(\"content-type\", \"\"))\n            # Define error response directly within the method\n            error_response = json.dumps({\"status\": \"error\", \"message\": \"Invalid Content-Type. Please send JSON data.\"})\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.send_json(error_response)\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if not isinstance(message, dict):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': ''  # This will be modified based on the success condition\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [60, 34, 49, 52, 45, 31, 53, 35, 43, 56, 47], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Content-Type header is not application/json',\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if not message.get('data'):\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0024988651275634766, "tests_passed": true, "error": null}}
{"selected_lines": [58, 39, 31, 53, 40, 38, 59, 48, 52, 37, 47, 41, 46, 34], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': ''  # This will be modified based on the error condition\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # Return a 400 error response\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode('utf-8'))\n                return\n            length = int(self.headers.get('content-length'))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.002341032028198242, "tests_passed": true, "error": null}}
{"selected_lines": [46, 37, 41, 43, 49, 56, 48, 34, 52, 35, 53, 45, 38, 31, 47, 39], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(http.server.BaseHTTPRequestHandler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('Content-Type', ''))\n            # Define error response directly within the method\n            error_response = {\n                'status': 'error',\n                'message': 'Invalid content type. Content-Type: application/json is required.'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)  # HTTP 400 - Bad Request\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response))\n                return\n            length = int(self.headers.get('content-length', 0))\n            message = json.loads(self.rfile.read(length))\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler", "compilation_passed": true, "time": 0.0025582313537597656, "tests_passed": true, "error": null}}
{"selected_lines": [45, 59, 60, 48, 31, 33, 39, 52, 57, 34, 40, 47, 54, 53, 29, 43, 44, 56, 58, 46, 49, 35, 37], "result": {"code": "import cgi\nimport http.server\nimport json\n\ndef task_func():\n    \"\"\"\n    The function creates an HTTP POST request handler for processing incoming data. The data is expected to be in JSON format with a key 'data'. The handler responds with a 200 success message if the data is valid, or an error message otherwise.\n\n    Notes:\n    - If the 'Content-Type' header is not 'application/json', the server responds with a 400 Bad Request status and a JSON object:\n      {\"status\": \"error\", \"message\": \"Content-Type header is not application/json\"}.\n    - If the received JSON object does not contain a 'data' key, the response is a 400 Bad Request with a JSON object:\n      {\"status\": \"error\", \"message\": \"No data received\"}.\n    - For successfully processed requests, the server responds with a 200 OK status and a JSON object:\n      {\"status\": \"success\", \"message\": \"Data received successfully.\"}.\n\n    Returns:\n    class: A class that is a subclass of http.server.BaseHTTPRequestHandler, designed to handle HTTP POST requests.\n\n    Requirements:\n    - cgi\n    - http.server\n    - json\n\n    Example:\n    >>> handler = task_func()\n    >>> server = http.server.HTTPServer(('127.0.0.1', 8080), handler)\n    >>> server.serve_forever()\n    \"\"\"\n    class PostRequestHandler(cgi.Handler):\n        def do_POST(self):\n            ctype, pdict = cgi.parse_header(self.headers.get('content-type', ''))\n            # Define error response directly within the method\n            error_response = json.dumps(\n                'status': 'error',\n                'message': 'Content-Type header is not application/json'\n            }\n            if ctype != 'application/json':\n                self.send_response(400)\n                self.send_header('Content-type', 'application/json')\n                error_response['message'] = 'Content-Type header is not application/json'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            length = int(self.headers.get('content-length', '0'))\n            message = self.rfile.read(length)\n            if 'data' not in message:\n                self.send_response(400)\n                self.end_headers()\n                error_response['message'] = 'No data received'\n                self.wfile.write(json.dumps(error_response).encode())\n                return\n            # Define success response directly within the method\n            success_response = {\n                'status': 'success',\n                'message': 'Data received successfully.'\n            }\n            self.send_response(200)\n            self.end_headers()\n            self.end_headers()\n            self.wfile.write(json.dumps(success_response).encode())\n    return PostRequestHandler<|endoftext|>class MyCalc:", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
