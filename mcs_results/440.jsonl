{"selected_lines": [44, 53, 47, 48, 42, 41, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"Empty input arrays.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Matrix and tensor must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 48, 51, 43, 50, 41, 52, 42, 47, 53, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Input matrices must not be empty\")\n    if P.shape[0] * P.shape[1] != T.shape[0] * T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 52, 49, 53, 45, 50, 51, 47, 41, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.dot(P, T).flatten()\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 43, 51, 42, 53, 44, 52, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"The matrix and tensor must not be empty\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Matrix-Tensor multiplication not possible.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 51, 50, 45, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 51, 48, 44, 53, 41, 52, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes, P and T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 44, 47, 51, 50, 43, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 45, 43, 48, 50, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} should match the shape of the tensor T: {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.reshape(result, (result.shape[1] * result.shape[2], result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 43, 53, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == T.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018129348754882812, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [44, 47, 42, 51, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Empty input arrays.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 50, 43, 42, 52, 49, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P and T cannot be empty\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\"Matrix-Tensor multiplication not possible.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 43, 49, 48, 44, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3 or T.ndim != P.ndim:\n        raise ValueError(f\"Incompatible shapes: {P.shape} and {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.reshape(result, (result.shape[1] * result.shape[2], result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 45, 44, 42, 52, 48, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\"Incompatible dimensions for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 43, 49, 53, 47, 48, 52, 41, 42, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if P.shape != T.shape:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match\")\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.reshape(result.size, order=\"C\"))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 52, 41, 45, 53, 51, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Number of columns of P must be equal to the number of rows of T.\")\n            f\"Matrix P shape {P.shape[1]} should match the shape of the tensor T: {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 41, 49, 48, 44, 43, 53, 45, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size or not T.size:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} must match tensor shape T {T.shape} in order to perform multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 53, 52, 47, 45, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} must match\"\n        )\n    result = P.dot(T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 42, 51, 53, 41, 45, 52, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Input matrices/tensors must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} must match tensor shape T {T.shape} in order to perform multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 47, 53, 44, 49, 50, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices cannot be empty.\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\"Incompatible dimensions for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 42, 45, 51, 50, 52, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == T.ndim:\n        raise ValueError(\"P or T is empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are not compatible for matrix-tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 45, 48, 42, 52, 43, 49, 47, 44, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Incompatible shapes: P and T must have same columns number.\")\n            f\"Matrix P shape {P.shape} does not match tensor T shape {T.shape}.\")\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Input matrices and tensor must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 41, 42, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} does not match tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 43, 48, 45, 47, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] * P.shape[1] != T.shape[0] * T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = P @ T\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 48, 44, 43, 53, 50, 42, 41, 47, 45, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if T.ndim != 3 or P.ndim != 2:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} does not match tensor T shape {T.shape}.\")\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten()).reshape((-1, len(P[0])))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 41, 45, 49, 48, 52, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == T.ndim:\n        raise ValueError(\"Input matrices and tensor must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(result.size)).reshape(-1, result.shape[1])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 53, 52, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] < 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Number of columns of P must be equal to the number of rows of T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"The matrix and tensor must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018291473388671875, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [47, 52, 48, 43, 44, 53, 45, 51, 42, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input arrays cannot be empty.\")\n    if P.ndim != 3 or T.ndim != 3 or T.shape[1] != P.shape[1] or T.shape[0] != 1:\n        raise ValueError(\"Shapes of P and T are incompatible for multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match for multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(result.size, -1))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 48, 51, 50, 42, 49, 45, 52, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} must match tensor shape T {T.shape} in order to perform multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler(copy=False, with_mean=False, with_std=False)\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 52, 53, 45, 44, 49, 51, 50, 47, 43, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == T.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 3 or T.ndim != 3 or T.shape[1] != P.shape[1] or T.shape[0] != 1:\n        raise ValueError(\"Number of columns of P must be equal to the number of rows of T.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 49, 51, 45, 42, 41, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 42, 53, 44, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"Input arrays cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shape of P and T are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 53, 43, 44, 42, 50, 49, 45, 51, 52, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"The input matrices must not be empty!\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(f\"Shapes of P and T are incompatible. P.shape[1] = {P.shape[1]}, T.shape[0] = {T.shape[0]}\")\n            f\"Matrix P shape {P.shape[1]} does not match tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(result.size)).reshape(-1, result.shape[1])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 43, 53, 47, 44, 42, 41, 52, 51, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"The matrix and tensor must not be empty\")\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = P.dot(T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 48, 41, 50, 51, 45, 42, 52, 53, 49, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not np.size(P) > 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.ndim == 1:\n        raise ValueError(f\"Shape of P (row: {P.shape[0]}) and T (column: {T.shape[1]}) should be the same!\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 44, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\"Incompatible shapes: P and T must have same columns number.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 45, 47, 43, 52, 50, 51, 44, 53, 41, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} must be equal to tensor T shape {T.shape}\")\n        )\n    result = np.dot(P, T)\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 41, 47, 51, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if not np.issubdtype(P.dtype, np.number):\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0017898082733154297, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [47, 49, 48, 44, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\"Number of columns of P must be equal to the number of rows of T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result.reshape(result.size, -1))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 43, 41, 53, 48, 42, 50, 49, 44, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"P and T cannot be empty\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Incompatible dimensions for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T).reshape(T.size)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 41, 53, 43, 50, 47, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} must be equal to tensor T shape {T.shape}\")\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 41, 42, 48, 45, 51, 53, 43, 50, 44, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"P and T cannot be empty\")\n    if P.ndim == 1:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} must match\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler(copy=False, with_mean=False, with_std=False)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shape of P (row: {P.shape[0]}) and T (column: {T.shape[1]}) should be the same!\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": false, "time": 8.916854858398438e-05, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [45, 51, 50, 43, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} does not match the number of columns in tensor T: {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 53, 42, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 47, 45, 41, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler(copy=False, with_mean=False, with_std=False)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 42, 47, 45, 41, 43, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError(\"Matrix and Tensor cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} must match tensor T shape {T.shape[0]}\"\n        )\n    result = np.matmul(P, T).reshape(T.size)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 43, 44, 52, 50, 48, 49, 51, 45, 41, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"Inputs cannot be empty.\")\n    if not np.issubdtype(P.dtype, np.number):\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape} does not match tensor T shape {T.shape}.\")\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 52, 41, 43, 44, 50, 53, 42, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"Input matrices must not be empty\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 51, 42, 48, 45, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} must match tensor shape T {T.shape} in order to perform multiplication.\"\n        )\n    result = P @ T\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 45, 49, 44, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Matrix and tensor must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} does not match tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.001806020736694336, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if T.ndim != 3 or P.ndim != 2:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0017910003662109375, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [45, 51, 53, 41, 47, 50, 52, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 50, 53, 45, 41, 52, 42, 43, 47, 48, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Matrix and Tensor cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 48, 53, 45, 44, 47, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shape of P and T are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} does not match tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T\n    result = pd.DataFrame(result, columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 50, 49, 52, 42, 53, 51, 47, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError(\"Input matrices and tensor must not be empty.\")\n    if T.ndim != 3 or P.ndim != 2:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 51, 44, 48, 52, 43, 41, 47, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == T.ndim != 2:\n        raise ValueError(\"P and T cannot be empty\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\"Matrix and tensor must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 41, 53, 48, 44, 49, 47, 50, 43, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(\"Incompatible shapes for matrix-tensor multiplication\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.reshape(result.size)).reshape(-1, result.shape[1])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 47, 43, 48, 53, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"The matrix and tensor must not be empty\")\n    if P.ndim != 2:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 42, 50, 44, 45, 48, 53, 52, 49, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices must not be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shape of P (row: {P.shape[0]}) and T (column: {T.shape[1]}) should be the same!\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are incompatible.\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = StandardScaler().fit_transform(result.reshape(result.size, -1))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 42, 51, 47, 41, 45, 43, 52, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"P and T cannot be empty\")\n    if P.ndim != 3 or T.ndim != 3:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 50, 47, 44, 48, 51, 42, 45, 43, 53, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[0] * P.shape[1] != T.shape[0] * T.shape[1]:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match for multiplication.\"\n        )\n    result = P @ T\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.001882791519165039, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [51, 52, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 48, 51, 53, 42, 50, 47, 41, 43, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2 or np.shape(P)[1] != np.ndim(T) or np.shape(T)[0] != np.shape(P)[1]:\n        raise ValueError(\"P and T must be non-empty arrays.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 47, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices should not be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 47, 51, 43, 48, 45, 50, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices should not be empty')\n    if P.shape[0] != T.shape[0] or P.shape[1] != T.shape[1] or P.shape[2] != T.shape[2]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} should match the shape of the tensor T: {T.shape[0]}\"\n        )\n    result = P.dot(T)\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(len(result.T))]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 44, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible dimensions for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 44, 50, 51, 49, 42, 53, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices should not be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 41, 44, 43, 42, 47, 50, 51, 45, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"The input matrices must not be empty!\")\n    if P.ndim != 3 or T.ndim != 3 or T.shape[1] != P.shape[1] or T.shape[0] != 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 43, 49, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices must not be empty')\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 44, 50, 48, 47, 42, 45, 49, 52, 43, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1 and T.ndim == 3:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(f\"Incompatible shapes: {P.shape} and {T.shape}.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\")\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 49, 42, 43, 52, 44, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"The matrix and tensor must not be empty\")\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 51, 50, 53, 49, 42, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices and tensors cannot be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 45, 52, 53, 42, 48, 41, 44, 43, 49, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or not isinstance(T, np.ndarray):\n        raise ValueError(\"Input matrices must not be empty\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(f\"Incompatible shapes: {P.shape} and {T.shape}.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result.reshape(result.size, -1))\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 47, 49, 48, 45, 51, 41, 52, 53, 44, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1 and T.ndim == 3:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match\")\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(result.size, -1))\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 53, 50, 42, 41, 48, 43, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == 0:\n        raise ValueError(\"P and T must not be empty\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 42, 45, 43, 48, 47, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Matrices P and T must not be empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} does not match tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 44, 47, 51, 53, 45, 52, 50, 49, 42, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"The inputs must not be empty\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Incompatible dimensions for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = P.dot(T)\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 44, 45, 41, 50, 48, 43, 51, 53, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == T.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape != T.shape:\n        raise ValueError(\"Incompatible shapes: P and T must have same columns number.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 41, 43, 52, 42, 48, 53, 51, 50, 47, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError(\"The input matrices must not be empty!\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}\")\n        )\n    result = np.matmul(P, T)\n    result = np.reshape(result, (result.shape[1] * result.shape[2], result.shape[-1]))\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 48, 52, 51, 49, 53, 41, 45, 50, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == T.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are incompatible.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 50, 51, 41, 43, 44, 47, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError('Input matrices should not be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 51, 49, 47, 53, 50, 41, 43, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"The matrix and tensor must not be empty\")\n    if P.shape != T.shape:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} does not match the number of columns in tensor T: {T.shape}.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Matrix and tensor must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 44, 48, 45, 43, 41, 52, 50, 49, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.shape[0] * P.shape[1] != T.shape[0] * T.shape[1]:\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are incompatible.\"\n        )\n    result = np.matmul(P, T)\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 52, 51, 53, 48, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are incompatible.\"\n        )\n    result = np.matmul(P, T)\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 42, 53, 44, 41, 47, 52, 50, 43, 45, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} must match\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 53, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 3 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 51, 52, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(len(result.T))]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 51, 53, 50, 42, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"The inputs must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes for matrix-tensor multiplication\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 49, 53, 52, 48, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 51, 49, 43, 44, 50, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 41, 50, 43, 48, 47, 42, 53, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1 and T.ndim == 3:\n        raise ValueError(\"Input matrices and tensors must not be empty.\")\n    if P.shape != T.shape:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, P.shape[1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 52, 44, 53, 48, 41, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 50, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shape of P (row: {P.shape[0]}) and T (column: {T.shape[1]}) should be the same!\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 52, 43, 53, 41, 51, 50, 49, 45, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError(\"Input matrices must not be empty\")\n    if P.ndim != 3 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are incompatible.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 44, 51, 53, 43, 50, 42, 45, 52, 47, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not np.size(P) > 0:\n        raise ValueError(\"Input matrices and tensors must not be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 49, 50, 42, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Invalid input data. Please ensure both matrices are non-empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 50, 48, 49, 42, 53, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"The input matrix or tensor must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.reshape(result, [-1, P.shape[1]])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 41, 52, 47, 43, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 3 or T.ndim != 3 or T.shape[1] != P.shape[1] or T.shape[0] != 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 44, 51, 52, 47, 41, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shape of P and T are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P.dot(T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 48, 52, 53, 47, 43, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.reshape(result.size, order=\"C\"))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 47, 41, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P.dot(T)\n    result = StandardScaler().fit_transform(result.flatten()).reshape((-1, len(P[0])))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 49, 52, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shapes of P and T are incompatible. P.shape[1] = {P.shape[1]}, T.shape[0] = {T.shape[0]}\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018260478973388672, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [42, 44, 53, 43, 48, 52, 51, 50, 41, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1 and T.ndim == 3:\n        raise ValueError(\"P and T must not be empty\")\n    if P.ndim != 3 or T.ndim != 3 or T.shape[1] != P.shape[1] or T.shape[0] != 1:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, P.shape[1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.001882791519165039, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [43, 52, 41, 44, 53, 45, 47, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2 or np.shape(P)[1] != np.ndim(T) or np.shape(T)[0] != np.shape(P)[1]:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 and T.ndim != 3:\n        raise ValueError(\"Incompatible shapes.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 49, 51, 41, 53, 45, 44, 43, 50, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.ndim == 1:\n        raise ValueError(f\"Shape of P (row: {P.shape[0]}) and T (column: {T.shape[1]}) should be the same!\")\n            f\"Matrix P shape {P.shape[1]} does not match tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T.flatten()\n    result = pd.DataFrame(result, columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 48, 51, 50, 52, 53, 42, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input matrices must have compatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 42, 47, 41, 49, 43, 51, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 44, 41, 47, 52, 48, 42, 43, 45, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Input matrices cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} does not match the number of columns in tensor T: {T.shape}.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.reshape(result.size)).reshape(-1, result.shape[1])\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 52, 49, 51, 41, 45, 47, 48, 44, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not np.size(P) > 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"The number of columns in P must match T, got {P.shape[1]} != {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = P @ T.flatten()\n    result = StandardScaler().fit_transform(result.reshape(result.size)).reshape(-1, result.shape[1])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 43, 48, 45, 52, 47, 51, 42, 49, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Empty matrices are not allowed.\")\n    if P.shape[0] != T.shape[1]:\n        raise ValueError(\"Input matrices must have compatible shapes.\")\n            f\"Matrix P shape {P.shape} must match tensor shape T {T.shape} in order to perform multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_%s\" % i for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 50, 48, 53, 52, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Number of columns of P must be equal to the number of rows of T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 47, 44, 45, 53, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = P @ T.reshape(\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018591880798339844, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [48, 49, 50, 47, 53, 51, 52, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T.flatten()\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0017828941345214844, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [48, 47, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 43, 52, 41, 48, 45, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2 or np.shape(P)[1] != np.ndim(T) or np.shape(T)[0] != np.shape(P)[1]:\n        raise ValueError(\"Input matrices/tensors must not be empty\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are not compatible for matrix-tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.reshape(result, (result.shape[1] * result.shape[2], result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 53, 49, 52, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} must be equal to the tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 47, 52, 44, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 41, 53, 52, 51, 50, 44, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == T.ndim:\n        raise ValueError(\"Invalid input data. Please ensure both matrices are non-empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible dimensions for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler(copy=False, with_mean=False, with_std=False).fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 48, 50, 41, 43, 42, 53, 44, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size or not T.size:\n        raise ValueError(\"The inputs must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten()).reshape((-1, len(P[0])))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 52, 42, 53, 41, 51, 44, 45, 49, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.ndim != 2 or T.ndim != 3 or T.ndim != P.ndim:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} must match\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_%s\" % i for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 43, 44, 47, 41, 49, 50, 51, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T).reshape(T.size)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 42, 44, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices/tensors must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 41, 53, 49, 52, 42, 50, 48, 51, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Matrix and tensor must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 51, 49, 44, 50, 41, 43, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 41, 44, 51, 50, 49, 52, 47, 48, 42, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"The input matrices must not be empty!\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape} does not match the number of columns in tensor T: {T.shape}.\"\n        )\n    result = np.matmul(P, T).reshape(T.size)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 43, 51, 50, 45, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim == 1:\n        raise ValueError(\"Shapes of P and T are incompatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 50, 42, 47, 45, 53, 43, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input arrays cannot be empty.\")\n    if T.ndim != 3 or P.ndim != 2:\n        raise ValueError(\"Matrix and tensor must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 50, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] != T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 41, 47, 43, 53, 49, 51, 45, 50, 52, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"The matrix and tensor must not be empty\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible dimensions: the number of columns in P should match the first dimension of T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": false, "time": 7.700920104980469e-05, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [47, 50, 52, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 43, 48, 41, 47, 42, 45, 44, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"The input matrices must not be empty!\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(f\"Shapes of P and T are incompatible. P.shape[1] = {P.shape[1]}, T.shape[0] = {T.shape[0]}\")\n            f\"Matrix P shape {P.shape[1]} is incompatible with tensor shape {T.shape[0]}.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 49, 53, 52, 44, 42, 43, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input arrays cannot be empty.\")\n    if P.shape[-1] != T.shape[1]:\n        raise ValueError(\"Incompatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 53, 49, 42, 41, 51, 43, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Inputs cannot be empty\")\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 50, 41, 47, 49, 48, 42, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1 and T.ndim == 3:\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if P.ndim != 3 or T.ndim != 3 or T.shape[1] != P.shape[1] or T.shape[0] != 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T).flatten()\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 48, 53, 45, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are incompatible.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(result.size, -1))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 53, 44, 50, 47, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices and tensors cannot be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 42, 43, 52, 50, 48, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"Inputs cannot be empty\")\n    if P.ndim != 2:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten()).reshape((-1, len(P[0])))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 44, 45, 47, 52, 42, 49, 51, 43, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices and tensors must not be empty.\")\n    if P.ndim == 1:\n        raise ValueError(\"Matrix-Tensor multiplication not possible.\")\n            f\"Matrix P shape {P.shape[1]} must match tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 44, 51, 48, 53, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes, P and T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices and tensors must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Incompatible shapes: {P.shape} and {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 42, 51, 45, 48, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError('Input matrices must not be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} should match the shape of the tensor T: {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 44, 50, 47, 52, 42, 49, 41, 51, 43, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\")\n        )\n    result = P @ T.flatten()\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 41, 45, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} does not match tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 42, 49, 43, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices/tensors must not be empty\")\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 48, 42, 45, 44, 50, 49, 51, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not np.size(P) > 0:\n        raise ValueError(\"P or T is empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Matrix and tensor must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} must match tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(result, columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 42, 47, 50, 44, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\"The inputs must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}\")\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 42, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices should not be empty')\n    if P.shape[0] != T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 52, 45, 42, 48, 53, 47, 49, 51, 44, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Input arrays must not be empty\")\n    if P.shape[0] != T.shape[1]:\n        raise ValueError(\"Input shapes are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are incompatible.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input matrices must have compatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": false, "time": 8.0108642578125e-05, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [45, 48, 41, 51, 52, 44, 43, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not np.size(P) > 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(f\"The number of columns in P must match T, got {P.shape[1]} != {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1])).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or not isinstance(T, np.ndarray):\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018093585968017578, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [43, 49, 42, 51, 41, 44, 50, 47, 45, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Matrices P and T must not be empty.\")\n    if P.ndim == 1:\n        raise ValueError(f\"Shapes of P and T are incompatible. P.shape[1] = {P.shape[1]}, T.shape[0] = {T.shape[0]}\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 50, 53, 51, 41, 44, 48, 52, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2 or np.shape(P)[1] != np.ndim(T) or np.shape(T)[0] != np.shape(P)[1]:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape} must be equal to tensor T shape {T.shape}\")\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 43, 49, 45, 41, 44, 52, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Input arrays must not be empty\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.reshape(result, (result.shape[1] * result.shape[2], result.shape[-1]))\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 52, 47, 51, 43, 42, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Empty matrices not allowed')\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(result.size)).reshape(-1, result.shape[1])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 52, 51, 44, 45, 41, 42, 49, 43, 47, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"P or T is empty\")\n    if P.ndim != 2:\n        raise ValueError(f\"The number of columns in P must match T, got {P.shape[1]} != {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} must have same columns number.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 52, 53, 44, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 45, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 49, 45, 51, 42, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if P.ndim == 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 51, 41, 43, 47, 49, 52, 48, 42, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"P and T must not be empty\")\n    if P.ndim != 3 or T.ndim != 3:\n        raise ValueError(f\"Incompatible shapes: {P.shape} and {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(len(result.T))]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 50, 41, 45, 53, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(f\"Shape of P (row: {P.shape[0]}) and T (column: {T.shape[1]}) should be the same!\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 45, 44, 52, 50, 42, 48, 53, 47, 49, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == T.ndim:\n        raise ValueError('Input matrices must not be empty')\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are not compatible for matrix-tensor multiplication.\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 41, 45, 52, 50, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim == 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.reshape(result, [-1, P.shape[1]])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 52, 51, 50, 42, 45, 44, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if P.shape != T.shape:\n        raise ValueError(\"Incompatible dimensions for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are incompatible.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 48, 53, 45, 49, 43, 51, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P and T must be non-empty arrays.\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Shapes of P and T are incompatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} must have same columns number.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(len(result.T))]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 53, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 50, 51, 41, 47, 43, 48, 44, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 and T.ndim != 3:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape} does not match tensor T shape {T.shape}.\")\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_%s\" % i for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 52, 50, 44, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"The number of columns in P must match T, got {P.shape[1]} != {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} must have same columns number.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 45, 53, 48, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} should match the shape of the tensor T: {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 47, 49, 44, 50, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape != T.shape:\n        raise ValueError(\"Input shapes are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 49, 43, 51, 47, 50, 52, 41, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or not isinstance(T, np.ndarray):\n        raise ValueError(\"Input arrays must not be empty\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler(copy=False, with_mean=False, with_std=False)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 44, 49, 50, 41, 47, 43, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size or not T.size:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 42, 43, 52, 41, 53, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == T.ndim:\n        raise ValueError(\"The input matrices must not be empty!\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 50, 42, 52, 43, 49, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 53, 45, 49, 41, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor shape {T.shape[0]}\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] != T.shape[0] or P.shape[1] != T.shape[1] or P.shape[2] != T.shape[2]:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 43, 49, 48, 51, 45, 44, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 3 or T.ndim != 3:\n        raise ValueError(\"Incompatible dimensions for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 42, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"The matrix and tensor must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(result.size, order=\"C\"))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 47, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 47, 49, 41, 52, 45, 42, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError(\"Input matrices must not be empty\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}\")\n        )\n    result = np.dot(P, T).flatten()\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 45, 47, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\"\n        )\n    result = P @ T\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 47, 49, 52, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T.flatten()\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 50, 51, 48, 42, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Matrices P and T must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Incompatible shapes: {P.shape} and {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.reshape(result, [-1, P.shape[1]])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 44, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes: P and T must have same columns number.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 48, 53, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] * P.shape[1] != T.shape[0] * T.shape[1]:\n        raise ValueError(\"Incompatible dimensions: the number of columns in P should match the first dimension of T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.reshape(result, (result.shape[1] * result.shape[2], result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 43, 53, 51, 52, 49, 48, 47, 44, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size or not T.size:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim == 1:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_%s\" % i for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 50, 42, 52, 47, 51, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are incompatible.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 52, 51, 49, 50, 42, 45, 41, 47, 43, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"P or T is empty\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are incompatible.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 42, 53, 52, 45, 48, 49, 44, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Empty input arrays.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 47, 41, 43, 48, 53, 49, 51, 52, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not (P.ndim == T.ndim == 2):\n        raise ValueError(\"Input matrices and tensor must not be empty.\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1])).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 41, 47, 48, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not (P.ndim == T.ndim == 2):\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0017981529235839844, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [47, 49, 41, 43, 50, 44, 42, 48, 53, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError('Input matrices and tensors cannot be empty')\n    if P.ndim != 3 or T.ndim != 3 or T.shape[1] != P.shape[1] or T.shape[0] != 1:\n        raise ValueError(\"Incompatible dimensions for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} does not match the number of columns in tensor T: {T.shape}.\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 48, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] != T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.reshape(result, (result.shape[1] * result.shape[2], result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 49, 45, 51, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 43, 47, 42, 41, 52, 51, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2:\n        raise ValueError(\"Input matrices cannot be empty.\")\n    if P.ndim == 1:\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 45, 53, 42, 48, 49, 52, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"P and T cannot be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler(copy=False, with_mean=False, with_std=False)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 44, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes for matrix-tensor multiplication\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 53, 41, 48, 47, 45, 49, 44, 52, 42, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError(\"Empty input arrays.\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} does not match tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 45, 44, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Matrix and tensor must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 48, 42, 41, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Input matrices/tensors must not be empty\")\n    if P.ndim != 2:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(result, columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 53, 44, 49, 52, 42, 48, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError('Empty matrices not allowed')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shapes of P and T are incompatible. P.shape[1] = {P.shape[1]}, T.shape[0] = {T.shape[0]}\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 50, 52, 53, 49, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Number of columns of P must be equal to the number of rows of T.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P and T must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018067359924316406, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [43, 47, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim == 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 48, 43, 45, 50, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} must be equal to the tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 48, 41, 53, 45, 49, 43, 51, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 47, 52, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == T.ndim:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 47, 48, 41, 52, 49, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T).flatten()\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 42, 51, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler(copy=False, with_mean=False, with_std=False)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 49, 50, 45, 52, 42, 44, 43, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Empty input arrays.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(f\"Incompatible shapes: {P.shape} and {T.shape}.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler(copy=False, with_mean=False, with_std=False)\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 42, 53, 43, 48, 41, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(f\"Shapes of P and T are incompatible. P.shape[1] = {P.shape[1]}, T.shape[0] = {T.shape[0]}\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 49, 42, 41, 50, 43, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Matrices P and T must not be empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 42, 51, 52, 45, 49, 41, 44, 43, 48, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] != T.shape[1]:\n        raise ValueError('Input matrices and tensors cannot be empty')\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 47, 45, 52, 42, 51, 49, 44, 50, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"The inputs must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = P @ T\n    result = pd.DataFrame(result, columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018267631530761719, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.001837015151977539, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [47, 41, 52, 53, 42, 51, 44, 50, 45, 43, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Input matrices/tensors must not be empty\")\n    if P.ndim != 1 and T.ndim != 3:\n        raise ValueError(\"Incompatible shapes: P and T must have same columns number.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 52, 50, 49, 53, 48, 45, 51, 47, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Incompatible shapes: {P.shape} and {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} is incompatible with tensor shape {T.shape[0]}.\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 50, 49, 53, 47, 44, 42, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.shape[0] != T.shape[1]:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T.flatten()\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 41, 49, 53, 50, 45, 51, 44, 47, 43, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == 0:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes for matrix-tensor multiplication\")\n            f\"Matrix P shape {P.shape[1]} should match the shape of the tensor T: {T.shape[0]}\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices and tensors cannot be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Matrix-Tensor multiplication not possible.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 49, 48, 50, 43, 45, 47, 53, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError(\"P and T cannot be empty\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} should match the shape of the tensor T: {T.shape[0]}\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 44, 51, 41, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size or not T.size:\n        raise ValueError(\"P or T is empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Incompatible shapes: {P.shape} and {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": false, "time": 0.00015807151794433594, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [42, 47, 43, 52, 44, 45, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2 or np.shape(P)[1] != np.ndim(T) or np.shape(T)[0] != np.shape(P)[1]:\n        raise ValueError(\"Matrices P and T must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\")\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 49, 43, 50, 51, 44, 53, 52, 42, 41, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"The input matrices must not be empty!\")\n    if P.shape != T.shape:\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape[1]} must be equal to the tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 41, 49, 45, 43, 47, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} does not match tensor T shape {T.shape[0]}\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 42, 47, 44, 50, 49, 52, 48, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Matrix and Tensor cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Matrix-Tensor multiplication not possible.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 49, 48, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(result.size)).reshape(-1, result.shape[1])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 53, 48, 47, 45, 44, 51, 50, 43, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P and T must not be empty\")\n    if P.ndim != 3 or T.ndim != 3 or T.shape[1] != P.shape[1] or T.shape[0] != 1:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} should match the shape of the tensor T: {T.shape[0]}\"\n        )\n    result = np.matmul(P, T).reshape(T.size)\n    result = StandardScaler().fit_transform(result.reshape(result.size)).reshape(-1, result.shape[1])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 47, 49, 42, 43, 48, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match for multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(-1, P.shape[1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 42, 48, 51, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Empty matrices not allowed')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} does not match tensor T shape {T.shape}.\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 41, 42, 53, 45, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not (P.ndim == T.ndim == 2):\n        raise ValueError(\"The matrix and tensor must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} must be equal to the tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(result.size, order=\"C\"))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 44, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"The input matrix or tensor must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 48, 52, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P.dot(T)\n    result = StandardScaler().fit_transform(result.reshape(result.size, order=\"C\"))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 51, 41, 44, 48, 42, 47, 53, 43, 50, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] < 2:\n        raise ValueError(\"Inputs cannot be empty\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\"Incompatible dimensions for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} should match the shape of the tensor T: {T.shape[0]}\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [\"feature_%s\" % i for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 42, 47, 51, 45, 50, 52, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"The inputs must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result.flatten()).reshape((-1, len(P[0])))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 41, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Matrix-Tensor multiplication not possible.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 52, 47, 42, 49, 45, 41, 44, 53, 43, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError('Input matrices and tensors cannot be empty')\n    if T.ndim != 3 or P.ndim != 2:\n        raise ValueError(f\"Shapes of P and T are incompatible. P.shape[1] = {P.shape[1]}, T.shape[0] = {T.shape[0]}\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = StandardScaler().fit_transform(result.flatten()).reshape((-1, len(P[0])))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 43, 42, 51, 49, 48, 47, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError('Input matrices and tensors cannot be empty')\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} must be equal to the tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T.flatten()\n    result = StandardScaler().fit_transform(result.flatten()).reshape((-1, len(P[0])))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 43, 44, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices and tensors cannot be empty')\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(f\"Shape of P (row: {P.shape[0]}) and T (column: {T.shape[1]}) should be the same!\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1])).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 51, 52, 42, 41, 48, 53, 44, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"Empty matrices are not allowed.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T.flatten()\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 42, 44, 47, 52, 43, 41, 49, 51, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Input matrices and tensors must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shape of P and T are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 48, 52, 42, 47, 51, 53, 44, 49, 41, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"P and T cannot be empty\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\"Incompatible shapes: P and T must have same columns number.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 53, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} does not match tensor T shape {T.shape}.\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler(copy=False, with_mean=False, with_std=False).fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 48, 47, 42, 53, 49, 51, 43, 52, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Matrices P and T must not be empty.\")\n    if P.ndim != 1 and T.ndim != 3:\n        raise ValueError(f\"Shape of P (row: {P.shape[0]}) and T (column: {T.shape[1]}) should be the same!\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T).flatten()\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 48, 53, 50, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible dimensions: the number of columns in P should match the first dimension of T.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shape of P and T are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": false, "time": 7.677078247070312e-05, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [48, 43, 49, 41, 50, 44, 47, 42, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError('Empty matrices not allowed')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Matrix and tensor must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} must match\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 52, 44, 49, 51, 45, 48, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} must match tensor shape T {T.shape} in order to perform multiplication.\"\n        )\n    result = P @ T\n    result = pd.DataFrame(\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 41, 49, 44, 53, 51, 45, 50, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == T.ndim:\n        raise ValueError(\"Empty input arrays.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"The number of columns in P must match T, got {P.shape[1]} != {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 41, 47, 52, 45, 42, 51, 49, 50, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"The input matrices must not be empty!\")\n    if P.ndim == 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 47, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018460750579833984, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [47, 48, 49, 53, 45, 44, 50, 52, 41, 42, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"P or T is empty\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\"Incompatible shapes, P and T.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}\")\n        )\n    result = P @ T.reshape(\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 45, 52, 41, 53, 43, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 47, 48, 43, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"The input matrix or tensor must not be empty\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 43, 48, 41, 52, 51, 50, 53, 44, 45, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(\"Input matrices must have compatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are incompatible.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(result.size)).reshape(-1, result.shape[1])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 50, 47, 51, 44, 41, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 and T.ndim != 3:\n        raise ValueError(\"Input shapes are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 52, 49, 43, 50, 41, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} does not match tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 48, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 48, 42, 43, 44, 52, 53, 50, 49, 47, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(f\"Shapes of P and T are incompatible. P.shape[1] = {P.shape[1]}, T.shape[0] = {T.shape[0]}\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 48, 45, 47, 41, 44, 49, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 44, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Matrix and tensor must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 49, 44, 45, 53, 42, 48, 52, 43, 51, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"P and T must be non-empty arrays.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Incompatible dimensions: the number of columns in P should match the first dimension of T.\")\n            f\"Matrix P shape {P.shape[1]} must be equal to the tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 42, 41, 43, 53, 48, 51, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"Empty matrices are not allowed.\")\n    if P.shape[0] * P.shape[1] != T.shape[0] * T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 47, 42, 49, 45, 51, 43, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"The inputs must not be empty\")\n    if P.ndim != 2 or T.ndim != 3 or T.ndim != P.ndim:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 51, 45, 44, 50, 52, 41, 42, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\"Input arrays cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Incompatible shapes: P and T must have same columns number.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 43, 49, 52, 42, 47, 45, 48, 50, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Empty input arrays.\")\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(\"Shape of P and T are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} must have same columns number.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 48, 44, 45, 43, 42, 53, 47, 41, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Input matrices/tensors must not be empty\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is incompatible with tensor shape {T.shape[0]}.\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 53, 48, 52, 43, 47, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Matrices P and T must not be empty.\")\n    if P.ndim != 2:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 48, 52, 49, 42, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_%s\" % i for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 52, 51, 47, 44, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Matrix-Tensor multiplication not possible.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, P.shape[1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 52, 43, 44, 41, 50, 48, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError(\"Matrices P and T must not be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler(copy=False, with_mean=False, with_std=False).fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 49, 47, 45, 44, 51, 41, 50, 43, 48, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(\"Incompatible shapes.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match for multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 43, 42, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices must not be empty\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(result.size, -1))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 50, 48, 41, 45, 51, 53, 49, 43, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\"Input shapes are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\")\n        )\n    result = P @ T.reshape(\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 53, 51, 52, 45, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} should match the shape of the tensor T: {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 41, 44, 53, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shape of P (row: {P.shape[0]}) and T (column: {T.shape[1]}) should be the same!\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 50, 44, 48, 43, 47, 41, 52, 53, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 47, 51, 48, 41, 53, 42, 45, 50, 43, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if T.ndim != 3 or P.ndim != 2:\n        raise ValueError(\"Input shapes are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} does not match tensor T shape {T.shape[0]}\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler(copy=False, with_mean=False, with_std=False)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 47, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices/tensors must not be empty\")\n    if P.shape[0] != T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018050670623779297, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [53, 45, 48, 49, 47, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"The matrix and tensor must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} should match the shape of the tensor T: {T.shape[0]}\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 43, 53, 45, 51, 42, 49, 50, 41, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if P.ndim != 1 and T.ndim != 3:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 41, 43, 51, 53, 47, 49, 52, 48, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not np.size(P) > 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\"Incompatible shapes for matrix-tensor multiplication\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} must match\"\n        )\n    result = np.matmul(P, T)\n    result = np.reshape(result, [-1, P.shape[1]])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018312931060791016, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [49, 45, 50, 41, 47, 44, 52, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or not isinstance(T, np.ndarray):\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 48, 52, 44, 43, 50, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input arrays cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 42, 47, 41, 45, 53, 52, 51, 48, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or not isinstance(T, np.ndarray):\n        raise ValueError(\"Empty matrices are not allowed.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are incompatible.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 44, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(result.size, -1))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 52, 45, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if not np.issubdtype(P.dtype, np.number):\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 49, 41, 42, 51, 45, 53, 43, 52, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018270015716552734, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [52, 45, 50, 53, 43, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3 or T.ndim != P.ndim:\n        raise ValueError(f\"The number of columns in P must match T, got {P.shape[1]} != {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are not compatible for matrix-tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0017817020416259766, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [42, 49, 50, 43, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices and tensors cannot be empty')\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.001882791519165039, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [52, 43, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3 or T.ndim != P.ndim:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 43, 49, 41, 48, 42, 51, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"P and T cannot be empty\")\n    if P.ndim == 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 49, 45, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} does not match the number of columns in tensor T: {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 53, 44, 47, 52, 42, 45, 50, 51, 43, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError(\"Invalid input data. Please ensure both matrices are non-empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler(copy=False, with_mean=False, with_std=False)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 47, 49, 50, 44, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Number of columns of P must be equal to the number of rows of T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T).reshape(T.size)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": false, "time": 7.510185241699219e-05, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [53, 49, 45, 50, 47, 51, 42, 41, 52, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size or not T.size:\n        raise ValueError(\"Input matrices and tensor must not be empty.\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} does not match tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 50, 42, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices and tensors cannot be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Incompatible shapes: {P.shape} and {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 48, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shape of P and T are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 52, 41, 43, 50, 51, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError('Input matrices must not be empty')\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 51, 43, 47, 50, 44, 45, 49, 42, 52, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = P.dot(T)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 52, 47, 49, 45, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices and tensors must not be empty.\")\n    if P.ndim != 3 or T.ndim != 3 or T.shape[1] != P.shape[1] or T.shape[0] != 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} must match tensor shape T {T.shape} in order to perform multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes, P and T.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 44, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Matrix and tensor must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 47, 43, 53, 50, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 44, 50, 47, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible dimensions: the number of columns in P should match the first dimension of T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 47, 51, 48, 53, 42, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"The input matrix or tensor must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 52, 47, 42, 45, 41, 53, 48, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1 and T.ndim == 3:\n        raise ValueError(\"P and T cannot be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible for tensor T shape {T.shape}.\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes: P and T must have same columns number.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": false, "time": 7.796287536621094e-05, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [53, 44, 52, 43, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Incompatible shapes: P and T must have same columns number.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 49, 47, 43, 50, 42, 52, 51, 53, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"The inputs must not be empty\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape[1]} must be equal to the tensor T shape {T.shape[0]}\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 47, 52, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"The matrix and tensor must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Matrices P and T must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018320083618164062, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [48, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(-1, P.shape[1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 52, 42, 53, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Matrix and Tensor cannot be empty.\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 51, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Empty input arrays.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shapes of P and T are incompatible. P.shape[1] = {P.shape[1]}, T.shape[0] = {T.shape[0]}\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": false, "time": 8.702278137207031e-05, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [53, 44, 49, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 43, 42, 48, 51, 50, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty\")\n    if not np.issubdtype(P.dtype, np.number):\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 50, 43, 42, 48, 47, 49, 52, 45, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input arrays must not be empty\")\n    if P.shape[0] * P.shape[1] != T.shape[0] * T.shape[1]:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 48, 42, 44, 43, 53, 45, 49, 47, 41, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not (P.ndim == T.ndim == 2):\n        raise ValueError(\"Empty input arrays.\")\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape} does not match the number of columns in tensor T: {T.shape}.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0017981529235839844, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [50, 48, 41, 45, 47, 51, 52, 44, 53, 43, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError('Input matrices should not be empty')\n    if P.shape != T.shape:\n        raise ValueError(f\"Shapes of P and T are incompatible. P.shape[1] = {P.shape[1]}, T.shape[0] = {T.shape[0]}\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match for multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = np.reshape(result, [-1, P.shape[1]])\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 43, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices should not be empty')\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 44, 48, 41, 42, 47, 49, 51, 52, 53, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"Input arrays must not be empty\")\n    if P.shape[-1] != T.shape[1]:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(len(result.T))]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": false, "time": 0.00015807151794433594, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [49, 43, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if not np.issubdtype(P.dtype, np.number):\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 43, 45, 49, 51, 50, 47, 42, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} must have same columns number.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 48, 47, 50, 44, 41, 52, 49, 45, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError('Input matrices must not be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Matrix-Tensor multiplication not possible.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match\")\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 41, 43, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 43, 41, 52, 53, 51, 45, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are incompatible.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten()).reshape((-1, len(P[0])))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 43, 52, 41, 49, 42, 48, 50, 51, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2:\n        raise ValueError(\"Invalid input data. Please ensure both matrices are non-empty.\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(\n            f\"Matrix P shape {P.shape} must be equal to tensor T shape {T.shape}\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 45, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input shapes are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} does not match tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 45, 42, 49, 48, 52, 50, 43, 51, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"Inputs must not be empty.\")\n    if T.ndim != 3 or P.ndim != 2:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor shape {T.shape[0]}\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 50, 48, 42, 43, 52, 51, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == T.ndim != 2:\n        raise ValueError(\"Input arrays must not be empty\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1])).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 52, 45, 51, 47, 42, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not (P.ndim == T.ndim == 2):\n        raise ValueError(\"Input arrays must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Matrix-Tensor multiplication not possible.\")\n            f\"Matrix P shape {P.shape} does not match tensor T shape {T.shape}.\")\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 42, 43, 47, 53, 49, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input arrays must not be empty\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 47, 42, 45, 53, 48, 50, 49, 43, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"The matrix and tensor must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible for tensor T shape {T.shape}.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1])).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 53, 48, 52, 44, 50, 45, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 43, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input arrays must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 49, 41, 51, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 50, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} must have same columns number.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 50, 48, 47, 41, 53, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes for matrix-tensor multiplication\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not (P.ndim == T.ndim == 2):\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018208026885986328, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [41, 45, 42, 44, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Input arrays must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor shape {T.shape[0]}\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 48, 51, 47, 41, 50, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 43, 49, 48, 50, 53, 45, 51, 41, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(result.size, order=\"C\"))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 48, 43, 49, 47, 51, 42, 50, 44, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not (P.ndim == T.ndim == 2):\n        raise ValueError(\"The inputs must not be empty\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = np.reshape(result, [-1, P.shape[1]])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 49, 52, 48, 43, 47, 53, 41, 45, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == T.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} must match\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 41, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError('Input matrices must not be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T.reshape(\n    result = pd.DataFrame(result, columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 52, 42, 48, 50, 41, 44, 47, 51, 45, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == T.ndim != 2:\n        raise ValueError(\"The input matrices must not be empty!\")\n    if P.shape[0] * P.shape[1] != T.shape[0] * T.shape[1]:\n        raise ValueError(\"Incompatible shapes: P and T must have same columns number.\")\n            f\"Matrix P shape {P.shape[1]} must match tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T\n    result = np.reshape(result, [-1, P.shape[1]])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 47, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 48, 50, 49, 53, 42, 44, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P and T cannot be empty\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.reshape(result, (result.shape[1] * result.shape[2], result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 48, 43, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P or T is empty\")\n    if P.ndim != 1 and T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 52, 48, 43, 50, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 and T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 49, 43, 50, 42, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[0] * P.shape[1] != T.shape[0] * T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T).flatten()\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 50, 53, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 41, 45, 43, 53, 47, 51, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\"Number of columns of P must be equal to the number of rows of T.\")\n            f\"Matrix P shape {P.shape[1]} should match the shape of the tensor T: {T.shape[0]}\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(result.size, -1))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 50, 48, 45, 43, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1])).reshape(\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 51, 50, 45, 44, 53, 47, 49, 48, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] != T.shape[1]:\n        raise ValueError(f\"Shapes of P and T are incompatible. P.shape[1] = {P.shape[1]}, T.shape[0] = {T.shape[0]}\")\n            f\"Matrix P shape {P.shape} is incompatible for tensor T shape {T.shape}.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 52, 48, 47, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 42, 44, 47, 43, 51, 49, 41, 50, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == T.ndim != 2:\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape[1]} must be equal to the tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 52, 49, 51, 42, 48, 44, 47, 41, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}\")\n        )\n    result = np.dot(P, T)\n    result = pd.DataFrame(result, columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 50, 41, 47, 48, 42, 44, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"The input matrices must not be empty!\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1])).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(len(result.T))]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 49, 41, 52, 50, 51, 47, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(len(result.T))]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 47, 43, 48, 50, 42, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[0] * P.shape[1] != T.shape[0] * T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P.dot(T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 52, 49, 53, 51, 42, 41, 48, 44, 47, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor shape {T.shape[0]}\")\n        )\n    result = np.matmul(P, T)\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 41, 50, 48, 45, 43, 49, 44, 52, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = StandardScaler().fit_transform(result.flatten()).reshape((-1, len(P[0])))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 50, 53, 45, 43, 48, 52, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices cannot be empty.\")\n    if P.ndim != 2:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} must be equal to the tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(result, columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 50, 41, 48, 52, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 43, 44, 49, 47, 48, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Incompatible dimensions for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(-1, P.shape[1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} must have same columns number.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018610954284667969, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [52, 47, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 47, 51, 52, 41, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not (P.ndim == T.ndim == 2):\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(len(result.T))]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 52, 48, 53, 45, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 47, 48, 42, 41, 49, 43, 50, 45, 52, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"P and T must not be empty\")\n    if P.shape[0] * P.shape[1] != T.shape[0] * T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = np.matmul(P, T)\n    result = pd.DataFrame(result, columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 45, 47, 41, 48, 50, 53, 52, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if not np.issubdtype(P.dtype, np.number):\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is incompatible with tensor shape {T.shape[0]}.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 52, 45, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 51, 50, 52, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(result.size, -1))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 45, 44, 43, 50, 47, 48, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size or not T.size:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Matrices P and T must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T).reshape(T.size)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\"Incompatible shapes: P and T must have same columns number.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 51, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are not compatible for matrix-tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 50, 44, 43, 49, 53, 42, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == T.ndim != 2:\n        raise ValueError(\"Input matrices and tensors must not be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Incompatible shapes for matrix-tensor multiplication\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 47, 52, 50, 41, 45, 48, 51, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"The input matrices must not be empty!\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible for tensor T shape {T.shape}.\"\n        )\n    result = P @ T\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 49, 44, 41, 48, 51, 52, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes for matrix-tensor multiplication\")\n            f\"Matrix P shape {P.shape[1]} must match tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 53, 42, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices should not be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices and tensors cannot be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.001811981201171875, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [49, 44, 52, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible dimensions: the number of columns in P should match the first dimension of T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 52, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 48, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices must not be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shapes of P and T are incompatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 49, 48, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Number of columns of P must be equal to the number of rows of T.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 41, 43, 47, 45, 53, 52, 42, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError('Input matrices should not be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} must be equal to the tensor T shape {T.shape[0]}\"\n        )\n    result = np.dot(P, T).flatten()\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 42, 49, 50, 53, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size or not T.size:\n        raise ValueError('Empty matrices not allowed')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 41, 47, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not np.size(P) > 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape != T.shape:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T).flatten()\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018138885498046875, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [41, 52, 53, 45, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible for tensor T shape {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 47, 48, 43, 42, 49, 45, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P and T cannot be empty\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} should match the shape of the tensor T: {T.shape[0]}\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler(copy=False, with_mean=False, with_std=False)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 41, 51, 53, 44, 48, 50, 47, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Inputs cannot be empty\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018689632415771484, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0017940998077392578, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [51, 49, 50, 47, 52, 43, 48, 42, 41, 53, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0:\n        raise ValueError(\"P and T cannot be empty\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten()).reshape((-1, len(P[0])))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 51, 53, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 and T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 47, 52, 51, 41, 49, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T.flatten()\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1])).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 50, 43, 44, 53, 47, 51, 42, 41, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Empty matrices are not allowed.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\"Incompatible dimensions for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = np.reshape(result, [-1, P.shape[1]])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 42, 50, 41, 45, 43, 51, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0:\n        raise ValueError(\"Input arrays cannot be empty.\")\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T.flatten()\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 50, 48, 44, 42, 52, 47, 41, 43, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] < 2:\n        raise ValueError(\"Matrices P and T must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 53, 51, 48, 43, 42, 41, 47, 45, 49, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError(\"Empty matrices are not allowed.\")\n    if P.ndim != 3 or T.ndim != 3:\n        raise ValueError(\"Shape of P and T are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} must match tensor shape T {T.shape} in order to perform multiplication.\"\n        )\n    result = np.matmul(P, T).reshape(T.size)\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 42, 51, 45, 50, 49, 48, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Matrices P and T must not be empty.\")\n    if not np.issubdtype(P.dtype, np.number):\n        raise ValueError(\"Matrix-Tensor multiplication not possible.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 48, 53, 45, 43, 50, 51, 44, 47, 41, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1 and T.ndim == 3:\n        raise ValueError(\"Input matrices and tensors must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes.\")\n            f\"Matrix P shape {P.shape} must be equal to tensor T shape {T.shape}\")\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 51, 53, 42, 47, 45, 49, 41, 44, 52, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Matrices P and T must not be empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 47, 51, 43, 44, 41, 45, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 3 or T.ndim != 3:\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape[1]} must match tensor T shape {T.shape[0]}\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 45, 47, 41, 43, 50, 48, 49, 52, 53, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(f\"Incompatible shapes: {P.shape} and {T.shape}.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = P.dot(T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 45, 47, 53, 51, 50, 41, 42, 52, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size or not T.size:\n        raise ValueError(\"Input arrays cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Incompatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} does not match tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 43, 50, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == T.ndim:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.shape[-1] != T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 49, 45, 41, 44, 51, 52, 43, 48, 53, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Matrices P and T must not be empty.\")\n    if P.shape[0] * P.shape[1] != T.shape[0] * T.shape[1]:\n        raise ValueError(\"Matrix and tensor must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = np.matmul(P, T)\n    result = np.reshape(result, [-1, P.shape[1]])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 48, 51, 47, 44, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input shapes are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 48, 50, 53, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shape of P and T are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.reshape(result, (result.shape[1] * result.shape[2], result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 43, 51, 48, 52, 45, 42, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P and T cannot be empty\")\n    if P.ndim == 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\"\n        )\n    result = P @ T\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 52, 41, 45, 43, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 45, 41, 52, 44, 49, 42, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Number of columns of P must be equal to the number of rows of T.\")\n            f\"Matrix P shape {P.shape} is incompatible for tensor T shape {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 49, 45, 50, 53, 42, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Input matrices/tensors must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 50, 51, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible for tensor T shape {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten()).reshape((-1, len(P[0])))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 49, 48, 50, 45, 53, 52, 43, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError('Input matrices and tensors cannot be empty')\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 43, 51, 49, 47, 50, 52, 45, 53, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(\"Incompatible dimensions: the number of columns in P should match the first dimension of T.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}\")\n        )\n    result = np.matmul(P, T)\n    result = np.reshape(result, (result.shape[1] * result.shape[2], result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 51, 41, 48, 52, 44, 45, 53, 50, 47, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Inputs cannot be empty\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Incompatible dimensions for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = P.dot(T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0017940998077392578, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [53, 45, 41, 48, 42, 47, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"P and T must be non-empty arrays.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten()).reshape((-1, len(P[0])))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 50, 52, 41, 45, 49, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 53, 47, 49, 41, 50, 48, 43, 52, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError('Input matrices and tensors cannot be empty')\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 49, 44, 48, 53, 41, 42, 50, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not np.size(P) > 0:\n        raise ValueError(\"Input matrices and tensor must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible dimensions for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = P @ T.reshape(\n    result = StandardScaler().fit_transform(result.reshape(result.size)).reshape(-1, result.shape[1])\n    scaler = StandardScaler(copy=False, with_mean=False, with_std=False)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 45, 50, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 49, 51, 52, 41, 44, 50, 53, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 53, 47, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T.flatten()\n    result = StandardScaler(copy=False, with_mean=False, with_std=False).fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 48, 45, 52, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices and tensors must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 41, 51, 47, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"P or T is empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 52, 41, 44, 53, 51, 43, 49, 47, 48, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or not isinstance(T, np.ndarray):\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] != T.shape[0] or P.shape[1] != T.shape[1] or P.shape[2] != T.shape[2]:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape[1]} must match tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T.reshape(\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 43, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] != T.shape[0] or P.shape[1] != T.shape[1] or P.shape[2] != T.shape[2]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_%s\" % i for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018270015716552734, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [44, 48, 43, 52, 51, 45, 47, 41, 53, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1 and T.ndim == 3:\n        raise ValueError('Input matrices and tensors cannot be empty')\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(\"Input matrices must have compatible shapes.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\")\n        )\n    result = P @ T.flatten()\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0017940998077392578, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [51, 48, 52, 47, 45, 53, 50, 44, 43, 49, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 3 or T.ndim != 3:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1])).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 53, 50, 44, 51, 43, 42, 45, 49, 41, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\"Matrix and Tensor cannot be empty.\")\n    if P.shape[0] != T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} does not match the number of columns in tensor T: {T.shape}.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 41, 43, 48, 42, 53, 47, 44, 49, 52, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"P and T must be non-empty arrays.\")\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten()).reshape((-1, len(P[0])))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 41, 51, 45, 52, 53, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim == 1:\n        raise ValueError(f\"The number of columns in P must match T, got {P.shape[1]} != {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape} does not match tensor T shape {T.shape}.\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 41, 53, 48, 42, 44, 47, 51, 49, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == T.ndim:\n        raise ValueError(\"Input matrices and tensors must not be empty.\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 51, 52, 48, 44, 41, 47, 42, 53, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} must have same columns number.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 49, 44, 41, 53, 51, 52, 42, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"P and T cannot be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} does not match tensor T shape {T.shape}.\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, P.shape[1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 44, 41, 43, 52, 45, 42, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1 and T.ndim == 3:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(\"Shapes of P and T are incompatible for multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} must match\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 50, 44, 47, 51, 48, 45, 49, 43, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Empty input arrays.\")\n    if T.ndim != 3 or P.ndim != 2:\n        raise ValueError(\"Input shapes are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are incompatible.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 49, 52, 48, 47, 45, 50, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"The input matrix or tensor must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} must match tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 41, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 53, 44, 49, 43, 48, 51, 52, 50, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Empty matrices are not allowed.\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(f\"Shapes of P and T are incompatible. P.shape[1] = {P.shape[1]}, T.shape[0] = {T.shape[0]}\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor shape {T.shape[0]}\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(len(result.T))]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 51, 45, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are incompatible.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Matrix-Tensor multiplication not possible.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 47, 45, 44, 49, 43, 53, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Incompatible dimensions: the number of columns in P should match the first dimension of T.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 41, 42, 48, 53, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"The input matrices must not be empty!\")\n    if P.ndim != 2 or T.ndim != 3 or T.ndim != P.ndim:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 45, 43, 47, 53, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] != T.shape[0] or P.shape[1] != T.shape[1] or P.shape[2] != T.shape[2]:\n        raise ValueError(\"Input shapes are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} must match\"\n        )\n    result = np.matmul(P, T).reshape(T.size)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 41, 45, 49, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} does not match tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 42, 45, 52, 51, 41, 47, 48, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\")\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 45, 53, 47, 41, 44, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible dimensions: the number of columns in P should match the first dimension of T.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}\")\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 50, 51, 53, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible dimensions: the number of columns in P should match the first dimension of T.\")\n            f\"Matrix P shape {P.shape} does not match the number of columns in tensor T: {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 43, 50, 51, 42, 47, 53, 45, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Empty matrices are not allowed.\")\n    if P.ndim == 1:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} must be equal to tensor T shape {T.shape}\")\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 52, 44, 49, 53, 45, 43, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape != T.shape:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} must match tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 44, 45, 48, 52, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shape of P and T are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(-1, P.shape[1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 50, 52, 42, 53, 47, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1])).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 52, 43, 42, 41, 45, 48, 44, 51, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError('Input matrices should not be empty')\n    if T.ndim != 3 or P.ndim != 2:\n        raise ValueError(\"Input matrices must have compatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 43, 41, 49, 45, 42, 52, 48, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Input matrices must not be empty\")\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape} does not match the number of columns in tensor T: {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 47, 45, 51, 53, 50, 52, 43, 41, 44, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size or not T.size:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim == 1:\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\")\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 44, 50, 45, 48, 42, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.ndim == 1:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are not compatible for matrix-tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 52, 50, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 43, 52, 45, 42, 53, 50, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Input matrices must not be empty\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} does not match the number of columns in tensor T: {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 52, 50, 42, 47, 45, 51, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"The input matrix or tensor must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.001837015151977539, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": false, "time": 7.700920104980469e-05, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.001882791519165039, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [48, 44, 51, 45, 42, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices and tensors must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} must match tensor shape T {T.shape} in order to perform multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1])).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 42, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1 and T.ndim == 3:\n        raise ValueError(\"The inputs must not be empty\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 51, 44, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} must match\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 48, 51, 53, 49, 41, 50, 42, 52, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not np.size(P) > 0:\n        raise ValueError(\"Input matrices and tensors must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.matmul(P, T).reshape(T.size)\n    result = StandardScaler().fit_transform(result.flatten()).reshape((-1, len(P[0])))\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 51, 47, 42, 41, 52, 49, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Input arrays cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match\")\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 41, 53, 42, 52, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Invalid input data. Please ensure both matrices are non-empty.\")\n    if P.ndim != 1 and T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 41, 44, 50, 51, 47, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] < 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match for multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 47, 45, 44, 41, 50, 43, 48, 51, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not np.size(P) > 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Incompatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler(copy=False, with_mean=False, with_std=False).fit_transform(result)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 51, 48, 53, 42, 45, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} must match\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 43, 45, 42, 53, 48, 49, 41, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == 0:\n        raise ValueError(\"The inputs must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible for tensor T shape {T.shape}.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 48, 50, 51, 45, 53, 44, 42, 52, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or not isinstance(T, np.ndarray):\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 52, 48, 41, 49, 50, 45, 44, 53, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2:\n        raise ValueError(\"Incompatible dimensions: the number of columns in P should match the first dimension of T.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} must match\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 51, 49, 41, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == T.ndim:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 47, 49, 50, 52, 41, 43, 53, 44, 42, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == T.ndim:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler(copy=False, with_mean=False, with_std=False).fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 43, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 52, 44, 48, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3 or T.ndim != P.ndim:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, P.shape[1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible dimensions for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": false, "time": 7.891654968261719e-05, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [43, 50, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] != T.shape[0] or P.shape[1] != T.shape[1] or P.shape[2] != T.shape[2]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 51, 50, 41, 47, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 50, 47, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 45, 48, 41, 51, 50, 42, 44, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Empty matrices are not allowed.\")\n    if P.ndim != 2 or T.ndim != 3 or T.ndim != P.ndim:\n        raise ValueError(\"Input shapes are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} should match the shape of the tensor T: {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 49, 43, 48, 44, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] != T.shape[1]:\n        raise ValueError(\"Matrix and tensor must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler(copy=False, with_mean=False, with_std=False).fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 42, 49, 47, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Input arrays cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shape of P and T are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T).reshape(T.size)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 44, 53, 52, 47, 51, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices should not be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Matrix-Tensor multiplication not possible.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 44, 50, 43, 42, 48, 47, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.shape != T.shape:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 47, 53, 44, 42, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"The matrix and tensor must not be empty\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": false, "time": 0.00014209747314453125, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [48, 43, 50, 52, 45, 53, 41, 42, 44, 47, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} does not match tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 43, 52, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 53, 48, 43, 49, 44, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices and tensors cannot be empty')\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Incompatible shapes, P and T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 53, 49, 45, 44, 52, 48, 50, 51, 42, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not (P.ndim == T.ndim == 2):\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"The number of columns in P must match T, got {P.shape[1]} != {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = P @ T.reshape(\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_%s\" % i for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 48, 53, 50, 49, 52, 47, 44, 42, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size or not T.size:\n        raise ValueError(\"P and T must be non-empty arrays.\")\n    if P.ndim != 1 and T.ndim != 3:\n        raise ValueError(\"Incompatible shapes: P and T must have same columns number.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 42, 52, 41, 43, 45, 48, 53, 44, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError('Empty matrices not allowed')\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(f\"Incompatible shapes: {P.shape} and {T.shape}.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 49, 43, 50, 51, 53, 48, 52, 47, 44, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Empty matrices not allowed')\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(f\"The number of columns in P must match T, got {P.shape[1]} != {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 49, 48, 42, 51, 45, 50, 52, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1 and T.ndim == 3:\n        raise ValueError(\"Input matrices cannot be empty.\")\n    if P.ndim != 1 and T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} must match tensor shape T {T.shape} in order to perform multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 50, 47, 43, 44, 45, 53, 51, 52, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} must be equal to tensor T shape {T.shape}\")\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 41, 44, 52, 49, 43, 53, 47, 42, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"P or T is empty\")\n    if P.shape[0] != T.shape[1]:\n        raise ValueError(\"Incompatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.001882791519165039, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [51, 52, 45, 43, 44, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim == 1:\n        raise ValueError(f\"Shapes of P and T are incompatible. P.shape[1] = {P.shape[1]}, T.shape[0] = {T.shape[0]}\")\n            f\"Matrix P shape {P.shape} must be equal to tensor T shape {T.shape}\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten()).reshape((-1, len(P[0])))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 45, 44, 53, 48, 42, 41, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == T.ndim:\n        raise ValueError('Input matrices and tensors cannot be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes for matrix-tensor multiplication\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 48, 52, 41, 50, 51, 53, 47, 45, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size or not T.size:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} does not match tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 53, 51, 44, 52, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\"Incompatible shapes, P and T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_%s\" % i for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 43, 41, 47, 51, 52, 53, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError('Empty matrices not allowed')\n    if P.ndim != 3 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible dimensions: the number of columns in P should match the first dimension of T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": false, "time": 7.700920104980469e-05, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [52, 41, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 53, 45, 51, 44, 52, 50, 41, 48, 47, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError('Input matrices and tensors cannot be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.matmul(P, T)\n    result = np.reshape(result, (result.shape[1] * result.shape[2], result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 45, 49, 42, 50, 44, 43, 47, 51, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Empty input arrays.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are not compatible for matrix-tensor multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 48, 41, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 45, 44, 43, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Incompatible shapes: P and T must have same columns number.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor shape {T.shape[0]}\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(result.size, order=\"C\"))\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 52, 44, 53, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Incompatible shapes: {P.shape} and {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are incompatible.\"\n        )\n    result = np.dot(P, T).flatten()\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 43, 42, 50, 48, 41, 44, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or not isinstance(T, np.ndarray):\n        raise ValueError(\"Matrices P and T must not be empty.\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\"Matrix and tensor must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.reshape(result, (result.shape[1] * result.shape[2], result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 47, 51, 52, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == T.ndim:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] * P.shape[1] != T.shape[0] * T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 41, 44, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 42, 45, 43, 49, 53, 41, 51, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0:\n        raise ValueError(\"Matrix and Tensor cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for multiplication.\"\n        )\n    result = P @ T.flatten()\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T).flatten()\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018301010131835938, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [43, 47, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 51, 53, 43, 48, 42, 45, 47, 44, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError(\"Input matrices cannot be empty.\")\n    if T.ndim != 3 or P.ndim != 2:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(result.size)).reshape(-1, result.shape[1])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 52, 44, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes, P and T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 50, 53, 47, 44, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible dimensions for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P.dot(T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 42, 47, 45, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices and tensors cannot be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes for matrix-tensor multiplication\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor shape {T.shape[0]}\")\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 49, 45, 53, 43, 48, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1 and T.ndim == 3:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] != T.shape[0] or P.shape[1] != T.shape[1] or P.shape[2] != T.shape[2]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.reshape(result, (result.shape[1] * result.shape[2], result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": false, "time": 0.00015020370483398438, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [49, 52, 41, 48, 45, 44, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == 0:\n        raise ValueError(\"Input matrices and tensors must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input shapes are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(result, columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 49, 51, 47, 52, 43, 41, 42, 44, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 52, 45, 53, 41, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"P and T cannot be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Matrix-Tensor multiplication not possible.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 44, 50, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shape of P (row: {P.shape[0]}) and T (column: {T.shape[1]}) should be the same!\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(result, columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 44, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Empty matrices are not allowed.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes for matrix-tensor multiplication\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 43, 52, 53, 44, 50, 49, 45, 47, 42, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices and tensors must not be empty.\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Incompatible shapes: P and T must have same columns number.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor shape {T.shape[0]}\")\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 43, 51, 48, 42, 47, 45, 41, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size or not T.size:\n        raise ValueError(\"P and T cannot be empty\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} is incompatible with tensor shape {T.shape[0]}.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018270015716552734, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [52, 47, 51, 42, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 52, 43, 48, 42, 51, 45, 50, 41, 44, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Empty matrices are not allowed.\")\n    if P.ndim != 3 or T.ndim != 3:\n        raise ValueError(\"Incompatible dimensions for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} does not match the number of columns in tensor T: {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 42, 52, 45, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} does not match the number of columns in tensor T: {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 42, 51, 47, 49, 48, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P and T cannot be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T).flatten()\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 52, 42, 53, 48, 50, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P or T is empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, P.shape[1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 51, 47, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Incompatible shapes: {P.shape} and {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 50, 48, 44, 45, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"The input matrix or tensor must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor shape {T.shape[0]}\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 42, 41, 51, 43, 48, 44, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2:\n        raise ValueError(\"Input matrices/tensors must not be empty\")\n    if P.shape[-1] != T.shape[1]:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 42, 47, 44, 45, 53, 52, 41, 50, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"Empty input arrays.\")\n    if P.ndim != 3 or T.ndim != 3:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 43, 52, 51, 48, 41, 44, 50, 49, 42, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"The inputs must not be empty\")\n    if P.shape[-1] != T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is incompatible with tensor shape {T.shape[0]}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 51, 49, 52, 41, 50, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are not compatible for matrix-tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_%s\" % i for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 53, 43, 44, 41, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(f\"Incompatible shapes: {P.shape} and {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 49, 43, 42, 50, 48, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices and tensors must not be empty.\")\n    if P.ndim != 2 or T.ndim != 3 or T.ndim != P.ndim:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(result.size)).reshape(-1, result.shape[1])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018239021301269531, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [47, 43, 42, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Input matrices cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 50, 43, 45, 53, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == T.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 41, 50, 52, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes, P and T.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 44, 47, 50, 52, 43, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices must not be empty')\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 47, 52, 50, 44, 41, 49, 53, 48, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape[1]} must be equal to the tensor T shape {T.shape[0]}\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 53, 44, 49, 41, 50, 45, 51, 52, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Input arrays cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T.flatten()\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 42, 41, 53, 45, 47, 51, 44, 48, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == T.ndim:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Matrix and tensor must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} is incompatible for tensor T shape {T.shape}.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 51, 48, 53, 43, 50, 45, 47, 42, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Invalid input data. Please ensure both matrices are non-empty.\")\n    if P.shape[0] != T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} does not match tensor T shape {T.shape[0]}\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or not isinstance(T, np.ndarray):\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 43, 45, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] < 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} must match\"\n        )\n    result = np.matmul(P, T).reshape(T.size)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 49, 51, 44, 53, 43, 48, 52, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if P.ndim != 3 or T.ndim != 3 or T.shape[1] != P.shape[1] or T.shape[0] != 1:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T).flatten()\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 53, 51, 42, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Empty input arrays.\")\n    if P.ndim != 2 or T.ndim != 3 or T.ndim != P.ndim:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 53, 41, 47, 48, 49, 44, 43, 42, 51, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Input matrices cannot be empty.\")\n    if P.shape[0] != T.shape[0] or P.shape[1] != T.shape[1] or P.shape[2] != T.shape[2]:\n        raise ValueError(f\"The number of columns in P must match T, got {P.shape[1]} != {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} must have same columns number.\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 43, 51, 41, 52, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2:\n        raise ValueError(\"P and T must not be empty\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(len(result.T))]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 47, 50, 41, 44, 45, 49, 48, 52, 53, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1 and T.ndim == 3:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 and T.ndim != 3:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} must match\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten()).reshape((-1, len(P[0])))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.001882791519165039, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [53, 44, 45, 43, 47, 50, 42, 52, 41, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Input matrices and tensor must not be empty.\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(f\"The number of columns in P must match T, got {P.shape[1]} != {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\"\n        )\n    result = P @ T.flatten()\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 42, 53, 47, 49, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0:\n        raise ValueError('Input matrices and tensors cannot be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 48, 41, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"P and T cannot be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 52, 45, 44, 42, 47, 49, 48, 41, 50, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] < 2:\n        raise ValueError(\"Input matrices and tensors must not be empty.\")\n    if not np.issubdtype(P.dtype, np.number):\n        raise ValueError(\"Incompatible shapes, P and T.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.dot(P, T).flatten()\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 49, 48, 41, 43, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"P and T must not be empty\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 53, 48, 45, 44, 50, 47, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} must match tensor T shape {T.shape[0]}\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.reshape(result.size, order=\"C\"))\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 44, 53, 52, 47, 48, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input matrices must have compatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"The input matrix or tensor must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 42, 44, 52, 47, 45, 48, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(\"Incompatible shapes for matrix-tensor multiplication\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 48, 47, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == T.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 43, 47, 52, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"Input matrices/tensors must not be empty\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 52, 41, 48, 43, 45, 51, 44, 42, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Inputs cannot be empty\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} must match tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input matrices must have compatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 45, 42, 44, 48, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 42, 47, 49, 44, 53, 41, 43, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"P and T must not be empty\")\n    if P.ndim != 1 and T.ndim != 3:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} does not match tensor T shape {T.shape}.\")\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 45, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is incompatible with tensor shape {T.shape[0]}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(result, columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 41, 42, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"P and T must be non-empty arrays.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 44, 41, 52, 50, 49, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shapes of P and T are incompatible. P.shape[1] = {P.shape[1]}, T.shape[0] = {T.shape[0]}\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T).flatten()\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 47, 44, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Number of columns of P must be equal to the number of rows of T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 51, 52, 41, 50, 48, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 53, 45, 41, 42, 51, 52, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"Empty matrices are not allowed.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, P.shape[1]))\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 47, 53, 45, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} must have same columns number.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 49, 45, 48, 52, 44, 50, 47, 42, 51, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError('Input matrices should not be empty')\n    if P.ndim != 3 or T.ndim != 3 or T.shape[1] != P.shape[1] or T.shape[0] != 1:\n        raise ValueError(\"Matrix-Tensor multiplication not possible.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are not compatible for matrix-tensor multiplication.\"\n        )\n    result = np.dot(P, T).flatten()\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 41, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 45, 48, 49, 50, 44, 41, 52, 47, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] * P.shape[1] != T.shape[0] * T.shape[1]:\n        raise ValueError(\"Incompatible shapes.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 47, 44, 51, 41, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or not isinstance(T, np.ndarray):\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 52, 50, 49, 48, 47, 45, 51, 42, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Input arrays must not be empty\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result.reshape(result.size, order=\"C\"))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes: P and T must have same columns number.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": false, "time": 7.796287536621094e-05, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [53, 49, 42, 50, 43, 45, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P and T must not be empty\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} must have same columns number.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 51, 49, 47, 50, 41, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 43, 44, 51, 53, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(f\"Shapes of P and T are incompatible. P.shape[1] = {P.shape[1]}, T.shape[0] = {T.shape[0]}\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler(copy=False, with_mean=False, with_std=False)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 53, 50, 52, 51, 44, 45, 48, 42, 47, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Invalid input data. Please ensure both matrices are non-empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor shape {T.shape[0]}\")\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 51, 41, 42, 47, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 52, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shapes of P and T are incompatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 42, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not np.size(P) > 0:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 42, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Empty input arrays.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Matrix-Tensor multiplication not possible.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 52, 49, 43, 45, 42, 48, 41, 50, 44, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError('Input matrices should not be empty')\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\"Shape of P and T are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 43, 42, 49, 41, 47, 50, 48, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError(\"The inputs must not be empty\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 42, 47, 44, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] < 2:\n        raise ValueError(\"Empty matrices are not allowed.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T).flatten()\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 47, 50, 44, 53, 41, 45, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input shapes are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} must match tensor shape T {T.shape} in order to perform multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 53, 49, 44, 52, 51, 48, 43, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 49, 45, 42, 50, 48, 53, 43, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices and tensors must not be empty.\")\n    if P.shape != T.shape:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match for multiplication.\"\n        )\n    result = P @ T\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 44, 41, 50, 49, 48, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T).flatten()\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 41, 51, 50, 49, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 3 or T.ndim != 3 or T.shape[1] != P.shape[1] or T.shape[0] != 1:\n        raise ValueError(\"Incompatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 41, 52, 53, 44, 47, 50, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError(\"Invalid input data. Please ensure both matrices are non-empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible dimensions for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}\")\n        )\n    result = P @ T.reshape(\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 53, 44, 45, 52, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shapes of P and T are incompatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} is incompatible with tensor shape {T.shape[0]}.\"\n        )\n    result = np.matmul(P, T).reshape(T.size)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 51, 42, 49, 52, 47, 43, 53, 50, 48, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices must not be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\")\n        )\n    result = np.matmul(P, T)\n    result = pd.DataFrame(result, columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 52, 43, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or not isinstance(T, np.ndarray):\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 50, 49, 51, 42, 43, 41, 48, 52, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == T.ndim:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 49, 43, 50, 45, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices cannot be empty.\")\n    if P.shape[0] != T.shape[0] or P.shape[1] != T.shape[1] or P.shape[2] != T.shape[2]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} must match tensor shape T {T.shape} in order to perform multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018360614776611328, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [44, 49, 50, 53, 47, 52, 51, 42, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input arrays must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Incompatible shapes: {P.shape} and {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler(copy=False, with_mean=False, with_std=False).fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 44, 53, 43, 50, 49, 48, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 42, 44, 47, 53, 52, 49, 51, 43, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices cannot be empty.\")\n    if T.ndim != 3 or P.ndim != 2:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} does not match the number of columns in tensor T: {T.shape}.\"\n        )\n    result = P @ T.flatten()\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 43, 53, 44, 42, 47, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Matrix and Tensor cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Incompatible dimensions: the number of columns in P should match the first dimension of T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 53, 52, 44, 51, 49, 50, 48, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shape of P (row: {P.shape[0]}) and T (column: {T.shape[1]}) should be the same!\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": false, "time": 0.0001590251922607422, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [48, 42, 47, 53, 41, 44, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == T.ndim != 2:\n        raise ValueError('Input matrices should not be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(result.size, -1))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 53, 48, 52, 42, 51, 50, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match\")\n        )\n    result = P @ T\n    result = pd.DataFrame(result, columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 42, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Empty matrices are not allowed.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shape of P and T are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 51, 43, 45, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 42, 52, 45, 51, 49, 43, 48, 47, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Empty input arrays.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor shape {T.shape[0]}\")\n        )\n    result = P @ T\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.001882791519165039, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [48, 42, 53, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 47, 50, 45, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} does not match the number of columns in tensor T: {T.shape}.\"\n        )\n    result = P @ T.reshape(\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018649101257324219, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [47, 44, 43, 49, 50, 53, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(\"Incompatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 43, 42, 48, 53, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input arrays must not be empty\")\n    if P.ndim != 1 and T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 43, 52, 51, 50, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(result.size, -1))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 43, 42, 47, 49, 51, 48, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P and T cannot be empty\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} does not match the number of columns in tensor T: {T.shape}.\"\n        )\n    result = P.dot(T)\n    result = StandardScaler(copy=False, with_mean=False, with_std=False).fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 41, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 41, 43, 49, 47, 50, 45, 53, 42, 48, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not np.size(P) > 0:\n        raise ValueError(\"Invalid input data. Please ensure both matrices are non-empty.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}\")\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 49, 43, 52, 50, 42, 48, 45, 47, 51, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[0] != T.shape[0] or P.shape[1] != T.shape[1] or P.shape[2] != T.shape[2]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}\")\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler(copy=False, with_mean=False, with_std=False).fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 48, 47, 53, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 42, 41, 53, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"P and T must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 53, 50, 41, 43, 44, 49, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T).reshape(T.size)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 45, 43, 52, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} must be equal to the tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": false, "time": 7.581710815429688e-05, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [47, 50, 52, 45, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Invalid input data. Please ensure both matrices are non-empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\")\n        )\n    result = np.dot(P, T).flatten()\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 51, 43, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 42, 47, 52, 45, 41, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError(\"Invalid input data. Please ensure both matrices are non-empty.\")\n    if P.ndim == 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 45, 48, 47, 43, 41, 50, 53, 49, 52, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == T.ndim != 2:\n        raise ValueError(\"Input matrices and tensors must not be empty.\")\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor shape {T.shape[0]}\")\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten()).reshape((-1, len(P[0])))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 44, 49, 52, 47, 48, 45, 41, 51, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim == 1:\n        raise ValueError(\"Input matrices must have compatible shapes.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match\")\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = StandardScaler().fit_transform(result.reshape(result.size)).reshape(-1, result.shape[1])\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 41, 51, 48, 43, 50, 45, 47, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} does not match tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 41, 43, 45, 42, 48, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"Empty matrices are not allowed.\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Input shapes are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1])).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 43, 45, 52, 48, 53, 42, 44, 49, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"P and T cannot be empty\")\n    if P.ndim != 1 and T.ndim != 3:\n        raise ValueError(\"Incompatible shapes.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 44, 41, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 51, 53, 49, 42, 44, 48, 52, 45, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Matrices P and T must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes for matrix-tensor multiplication\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 41, 51, 45, 50, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 and T.ndim != 3:\n        raise ValueError(\"Input matrices must have compatible shapes.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are not compatible for matrix-tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 45, 51, 48, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.ndim == 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} must match tensor T shape {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(len(result.T))]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 41, 50, 47, 52, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 45, 42, 52, 50, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 52, 51, 50, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} must be equal to tensor T shape {T.shape}\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 45, 41, 47, 44, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1 and T.ndim == 3:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} does not match tensor T shape {T.shape}.\")\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 44, 43, 42, 47, 41, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if P.ndim != 3 or T.ndim != 3 or T.shape[1] != P.shape[1] or T.shape[0] != 1:\n        raise ValueError(f\"Shapes of P and T are incompatible. P.shape[1] = {P.shape[1]}, T.shape[0] = {T.shape[0]}\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 42, 43, 52, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"The input matrices must not be empty!\")\n    if P.shape[0] != T.shape[0] or P.shape[1] != T.shape[1] or P.shape[2] != T.shape[2]:\n        raise ValueError(\"Matrix and tensor must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 48, 49, 51, 53, 44, 50, 52, 41, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == 0:\n        raise ValueError(\"Invalid input data. Please ensure both matrices are non-empty.\")\n    if P.shape[0] != T.shape[1]:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 51, 49, 52, 44, 45, 53, 42, 41, 48, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"P or T is empty\")\n    if P.ndim != 2:\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are not compatible for matrix-tensor multiplication.\"\n        )\n    result = np.matmul(P, T).reshape(T.size)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 41, 48, 43, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 42, 44, 51, 43, 52, 48, 47, 45, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input arrays cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3 or T.ndim != P.ndim:\n        raise ValueError(\"Shapes of P and T are incompatible for multiplication.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}\")\n        )\n    result = np.dot(P, T)\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_%s\" % i for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"The input matrix or tensor must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.001811981201171875, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [47, 44, 50, 52, 42, 41, 48, 43, 51, 49, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if T.ndim != 3 or P.ndim != 2:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 52, 47, 45, 42, 41, 49, 43, 50, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1 and T.ndim == 3:\n        raise ValueError(\"Inputs cannot be empty\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} is incompatible for tensor T shape {T.shape}.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input arrays must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 41, 49, 42, 47, 52, 53, 51, 48, 50, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or not isinstance(T, np.ndarray):\n        raise ValueError(\"Empty matrices are not allowed.\")\n    if T.ndim != 3 or P.ndim != 2:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = np.reshape(result, (result.shape[1] * result.shape[2], result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 53, 48, 50, 44, 52, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten()).reshape((-1, len(P[0])))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 53, 50, 47, 41, 48, 42, 51, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError('Input matrices must not be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\")\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 52, 53, 45, 47, 43, 49, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Empty matrices are not allowed.\")\n    if P.shape[0] != T.shape[1]:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\")\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 43, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is incompatible with tensor shape {T.shape[0]}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 41, 53, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.001837015151977539, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [45, 48, 41, 43, 52, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size or not T.size:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] != T.shape[0] or P.shape[1] != T.shape[1] or P.shape[2] != T.shape[2]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are incompatible.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 44, 49, 45, 51, 47, 48, 52, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if not np.issubdtype(P.dtype, np.number):\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\")\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 47, 41, 49, 44, 45, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim == 1:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 48, 52, 42, 41, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2:\n        raise ValueError(\"P and T must be non-empty arrays.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler(copy=False, with_mean=False, with_std=False).fit_transform(result)\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 48, 50, 43, 44, 52, 53, 47, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not (P.ndim == T.ndim == 2):\n        raise ValueError(\"Inputs cannot be empty.\")\n    if T.ndim != 3 or P.ndim != 2:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T.flatten()\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1])).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 49, 43, 47, 42, 50, 52, 45, 48, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not np.size(P) > 0:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\"Number of columns of P must be equal to the number of rows of T.\")\n            f\"Matrix P shape {P.shape} does not match tensor T shape {T.shape}.\")\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 42, 43, 51, 53, 52, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices must not be empty\")\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 43, 53, 47, 50, 44, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\"Incompatible dimensions for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} must match tensor shape T {T.shape} in order to perform multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0017862319946289062, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [43, 53, 41, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 and T.ndim != 3:\n        raise ValueError(\"Shape of P and T are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018291473388671875, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [51, 52, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input arrays cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 43, 52, 44, 48, 45, 42, 41, 50, 47, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"P and T must be non-empty arrays.\")\n    if P.shape != T.shape:\n        raise ValueError(\"Number of columns of P must be equal to the number of rows of T.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor shape {T.shape[0]}\")\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(result.size, order=\"C\"))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices and tensor must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 43, 42, 47, 41, 53, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2:\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if P.shape[0] * P.shape[1] != T.shape[0] * T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\")\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 47, 45, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\")\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 43, 50, 52, 44, 41, 42, 47, 45, 49, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} is incompatible with tensor shape {T.shape[0]}.\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 41, 43, 49, 53, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = np.dot(P, T).flatten()\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 41, 52, 53, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == 0:\n        raise ValueError(\"Input arrays must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 42, 53, 43, 50, 49, 47, 44, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError('Input matrices should not be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible dimensions for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 43, 53, 45, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P or T is empty\")\n    if P.shape[-1] != T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} must have same columns number.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 44, 45, 48, 47, 50, 53, 51, 41, 52, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"Input arrays must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes for matrix-tensor multiplication\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are not compatible for matrix-tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 45, 44, 51, 43, 50, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\"Shape of P and T are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} is incompatible for tensor T shape {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 48, 44, 42, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes, P and T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 45, 50, 48, 49, 53, 47, 42, 41, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} is incompatible with tensor shape {T.shape[0]}.\"\n        )\n    result = np.matmul(P, T)\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 45, 53, 44, 49, 47, 52, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Incompatible shapes: {P.shape} and {T.shape}.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} must match\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(len(result.T))]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 47, 50, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices and tensor must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 41, 42, 51, 49, 53, 43, 50, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"P and T cannot be empty\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 42, 51, 44, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P or T is empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 47, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T).flatten()\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 44, 49, 43, 42, 51, 53, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input arrays must not be empty\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(\"Incompatible dimensions for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} is incompatible with tensor shape {T.shape[0]}.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 44, 43, 49, 53, 50, 47, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices and tensors must not be empty.\")\n    if not np.issubdtype(P.dtype, np.number):\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P or T is empty\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 44, 47, 49, 48, 51, 52, 43, 42, 45, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"P and T cannot be empty\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(f\"Shapes of P and T are incompatible. P.shape[1] = {P.shape[1]}, T.shape[0] = {T.shape[0]}\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 53, 43, 44, 51, 49, 41, 50, 48, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == T.ndim:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] * P.shape[1] != T.shape[0] * T.shape[1]:\n        raise ValueError(f\"Shapes of P and T are incompatible. P.shape[1] = {P.shape[1]}, T.shape[0] = {T.shape[0]}\")\n            f\"Matrix P shape {P.shape[1]} should match the shape of the tensor T: {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 51, 43, 48, 41, 47, 49, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.dot(P, T).flatten()\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 47, 52, 50, 48, 49, 45, 44, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are not compatible for matrix-tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 52, 45, 44, 42, 53, 48, 41, 43, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"P or T is empty\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Input matrices must have compatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} is incompatible with tensor shape {T.shape[0]}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 49, 47, 48, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = np.matmul(P, T).reshape(T.size)\n    result = StandardScaler().fit_transform(result.reshape(-1, P.shape[1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 52, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 3 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are incompatible.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 48, 52, 53, 42, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Matrices P and T must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 53, 47, 48, 41, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Input arrays must not be empty\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1])).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 43, 42, 41, 48, 45, 53, 51, 52, 50, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Input matrices and tensors must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 50, 49, 45, 41, 51, 52, 42, 44, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == 0:\n        raise ValueError('Input matrices should not be empty')\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Shape of P and T are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 50, 52, 47, 43, 53, 48, 42, 41, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError('Empty matrices not allowed')\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\"Matrix-Tensor multiplication not possible.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] != T.shape[0] or P.shape[1] != T.shape[1] or P.shape[2] != T.shape[2]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.001825094223022461, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [51, 44, 45, 41, 49, 53, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == 0:\n        raise ValueError(\"Invalid input data. Please ensure both matrices are non-empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 50, 44, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible dimensions: the number of columns in P should match the first dimension of T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 47, 52, 45, 48, 50, 49, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Empty matrices not allowed')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shapes of P and T are incompatible. P.shape[1] = {P.shape[1]}, T.shape[0] = {T.shape[0]}\")\n            f\"Matrix P shape {P.shape} is incompatible for tensor T shape {T.shape}.\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result.flatten()).reshape((-1, len(P[0])))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 49, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 42, 51, 49, 45, 52, 47, 41, 44, 53, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError('Input matrices should not be empty')\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Shapes of P and T are incompatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} should match the shape of the tensor T: {T.shape[0]}\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 42, 53, 43, 52, 44, 50, 47, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"P and T must not be empty\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 50, 43, 48, 42, 53, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices and tensor must not be empty.\")\n    if P.ndim != 3 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} does not match tensor T shape {T.shape}.\")\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 52, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Empty matrices not allowed')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input matrices must have compatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 51, 44, 48, 42, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P and T cannot be empty\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\"Input matrices must have compatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1])).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 43, 41, 42, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Input matrices must not be empty\")\n    if P.shape[-1] != T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 53, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 49, 41, 53, 42, 52, 47, 51, 48, 44, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError('Input matrices should not be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input matrices must have compatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} must match tensor T shape {T.shape[0]}\"\n        )\n    result = np.matmul(P, T).reshape(T.size)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 53, 48, 50, 52, 41, 45, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError(\"Invalid input data. Please ensure both matrices are non-empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} must match\"\n        )\n    result = np.dot(P, T)\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 45, 50, 41, 51, 42, 44, 52, 48, 43, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] < 2:\n        raise ValueError(\"The input matrices must not be empty!\")\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}\")\n        )\n    result = P @ T.flatten()\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not (P.ndim == T.ndim == 2):\n        raise ValueError(\"The input matrices must not be empty!\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 48, 41, 47, 53, 43, 52, 50, 44, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"The inputs must not be empty\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape} does not match tensor T shape {T.shape}.\")\n        )\n    result = P @ T.reshape(\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 53, 45, 47, 52, 44, 49, 41, 48, 42, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"P and T must not be empty\")\n    if P.ndim != 3 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} does not match tensor T shape {T.shape[0]}\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 43, 47, 50, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 41, 53, 50, 42, 47, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"The inputs must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Incompatible shapes: {P.shape} and {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T.reshape(\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 41, 53, 43, 50, 44, 47, 52, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size or not T.size:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(\"Shapes of P and T are incompatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T).reshape(T.size)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 44, 49, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices and tensors cannot be empty')\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Incompatible shapes, P and T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 42, 41, 45, 50, 52, 49, 48, 53, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError(\"The input matrix or tensor must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.reshape(result, [-1, P.shape[1]])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices and tensors cannot be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.001811981201171875, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [50, 47, 51, 44, 41, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 42, 52, 43, 51, 49, 41, 45, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"Input arrays cannot be empty.\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match for multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 50, 41, 48, 49, 52, 42, 43, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"Inputs cannot be empty\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes, P and T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 50, 43, 48, 52, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 49, 52, 44, 51, 42, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 45, 43, 52, 51, 49, 53, 44, 50, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices must not be empty')\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(f\"The number of columns in P must match T, got {P.shape[1]} != {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 41, 48, 52, 50, 49, 51, 53, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 3 or T.ndim != 3 or T.shape[1] != P.shape[1] or T.shape[0] != 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(result.size, -1))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 48, 43, 47, 41, 52, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim == 1:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 44, 47, 52, 48, 51, 50, 43, 41, 42, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] < 2:\n        raise ValueError(\"P and T must be non-empty arrays.\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 49, 47, 48, 53, 42, 44, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1 and T.ndim == 3:\n        raise ValueError(\"Input matrices and tensor must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input shapes are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 44, 42, 49, 50, 48, 53, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 53, 45, 43, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 50, 49, 52, 47, 42, 45, 51, 41, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] < 2:\n        raise ValueError(\"Input arrays must not be empty\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\"Matrix and tensor must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 50, 42, 47, 48, 41, 43, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == 0:\n        raise ValueError(\"The input matrices must not be empty!\")\n    if P.shape[0] * P.shape[1] != T.shape[0] * T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 50, 44, 41, 43, 45, 51, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError('Input matrices should not be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 51, 52, 44, 47, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": false, "time": 9.799003601074219e-05, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [43, 42, 48, 49, 51, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size or not T.size:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 45, 43, 41, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are not compatible for matrix-tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 51, 42, 48, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Input matrices/tensors must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 47, 44, 49, 53, 52, 51, 48, 50, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] < 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.matmul(P, T).reshape(T.size)\n    result = StandardScaler().fit_transform(result.reshape(-1, P.shape[1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 52, 51, 49, 53, 47, 43, 48, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 3 or T.ndim != 3 or T.shape[1] != P.shape[1] or T.shape[0] != 1:\n        raise ValueError(\"Matrix and tensor must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 44, 48, 49, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size or not T.size:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, P.shape[1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 52, 51, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices and tensors must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 52, 42, 51, 44, 53, 50, 49, 48, 41, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes for matrix-tensor multiplication\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} must have same columns number.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 47, 41, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not np.size(P) > 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 47, 41, 43, 44, 50, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] != T.shape[1]:\n        raise ValueError(\"Number of columns of P must be equal to the number of rows of T.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are incompatible.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 41, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 42, 45, 53, 47, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Matrix and Tensor cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} does not match tensor T shape {T.shape}.\")\n        )\n    result = P @ T.flatten()\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 52, 47, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 51, 52, 41, 53, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim == 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 53, 42, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T.flatten()\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 53, 43, 45, 49, 52, 50, 44, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] * P.shape[1] != T.shape[0] * T.shape[1]:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor shape {T.shape[0]}\")\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 53, 50, 43, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] < 2:\n        raise ValueError(\"Inputs cannot be empty\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 43, 41, 47, 50, 42, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"The inputs must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 44, 52, 41, 48, 51, 47, 43, 53, 49, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError('Input matrices must not be empty')\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\"Input matrices must have compatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 41, 48, 47, 50, 44, 43, 51, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] < 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Matrix and tensor must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} must match\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 43, 42, 51, 41, 49, 45, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Empty input arrays.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} must match\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 48, 42, 45, 44, 41, 52, 49, 47, 50, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Input matrices and tensor must not be empty.\")\n    if T.ndim != 3 or P.ndim != 2:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\")\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 43, 41, 53, 49, 52, 51, 42, 44, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError(\"Input matrices/tensors must not be empty\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\"Number of columns of P must be equal to the number of rows of T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler(copy=False, with_mean=False, with_std=False)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 47, 41, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} must match tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T.reshape(\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 45, 49, 43, 51, 53, 44, 42, 52, 48, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Empty matrices are not allowed.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Input matrices must have compatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor shape {T.shape[0]}\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 48, 43, 51, 52, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 51, 48, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(result.size, -1))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 47, 48, 49, 52, 41, 45, 50, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Input shapes are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape} does not match tensor T shape {T.shape}.\")\n        )\n    result = P @ T\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 42, 45, 53, 43, 44, 50, 52, 41, 51, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Matrix and Tensor cannot be empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\"Incompatible dimensions: the number of columns in P should match the first dimension of T.\")\n            f\"Matrix P shape {P.shape} must match tensor shape T {T.shape} in order to perform multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 44, 42, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 41, 52, 42, 44, 47, 51, 50, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"Inputs cannot be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(len(result.T))]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 45, 47, 53, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Matrices P and T must not be empty.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\")\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes, P and T.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} must match\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 48, 43, 45, 50, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 and T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible for tensor T shape {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 41, 51, 47, 53, 44, 52, 45, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2:\n        raise ValueError(\"Matrices P and T must not be empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = P @ T.reshape(\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 44, 52, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input shapes are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P or T is empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shapes of P and T are incompatible. P.shape[1] = {P.shape[1]}, T.shape[0] = {T.shape[0]}\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 41, 47, 50, 48, 43, 53, 52, 44, 42, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not np.size(P) > 0:\n        raise ValueError(\"Matrix and Tensor cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Matrix-Tensor multiplication not possible.\")\n            f\"Matrix P shape {P.shape} must match tensor shape T {T.shape} in order to perform multiplication.\"\n        )\n    result = np.dot(P, T).flatten()\n    result = np.reshape(result, (result.shape[1] * result.shape[2], result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 49, 44, 45, 52, 42, 53, 48, 47, 50, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == T.ndim:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if P.ndim != 3 or T.ndim != 3 or T.shape[1] != P.shape[1] or T.shape[0] != 1:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = np.dot(P, T)\n    result = np.reshape(result, [-1, P.shape[1]])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 44, 45, 47, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible dimensions for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} should match the shape of the tensor T: {T.shape[0]}\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler(copy=False, with_mean=False, with_std=False)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 45, 41, 50, 44, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"P and T must be non-empty arrays.\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(f\"Shapes of P and T are incompatible. P.shape[1] = {P.shape[1]}, T.shape[0] = {T.shape[0]}\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 47, 45, 51, 41, 49, 52, 43, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size or not T.size:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor shape {T.shape[0]}\")\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 52, 53, 48, 47, 43, 49, 42, 51, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if P.shape != T.shape:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} must match tensor shape T {T.shape} in order to perform multiplication.\"\n        )\n    result = P.dot(T)\n    result = np.reshape(result, (result.shape[1] * result.shape[2], result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(result, columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 51, 52, 53, 49, 44, 42, 45, 41, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == T.ndim:\n        raise ValueError(\"P and T cannot be empty\")\n    if P.shape[0] != T.shape[1]:\n        raise ValueError(\"Incompatible shapes for matrix-tensor multiplication\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\")\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 49, 47, 52, 41, 43, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or not isinstance(T, np.ndarray):\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 48, 50, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Invalid input data. Please ensure both matrices are non-empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 49, 53, 47, 42, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 45, 43, 42, 41, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not (P.ndim == T.ndim == 2):\n        raise ValueError(\"The input matrices must not be empty!\")\n    if P.shape[-1] != T.shape[1]:\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape} does not match tensor T shape {T.shape}.\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 52, 44, 53, 41, 49, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(result.size)).reshape(-1, result.shape[1])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 51, 45, 42, 48, 50, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Input arrays cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} must match\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 51, 53, 48, 42, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Matrices P and T must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 49, 42, 52, 47, 48, 51, 53, 43, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2 or np.shape(P)[1] != np.ndim(T) or np.shape(T)[0] != np.shape(P)[1]:\n        raise ValueError(\"The input matrix or tensor must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 49, 53, 47, 44, 51, 42, 45, 41, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Invalid input data. Please ensure both matrices are non-empty.\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 44, 42, 53, 47, 41, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError('Input matrices and tensors cannot be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes for matrix-tensor multiplication\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T.reshape(\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": false, "time": 8.0108642578125e-05, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [50, 47, 52, 41, 43, 51, 45, 49, 53, 42, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1 and T.ndim == 3:\n        raise ValueError(\"P and T must not be empty\")\n    if P.shape != T.shape:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = StandardScaler().fit_transform(result.reshape(-1, P.shape[1]))\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 44, 43, 41, 51, 47, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2:\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 43, 47, 49, 44, 52, 50, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 3 or T.ndim != 3 or T.shape[1] != P.shape[1] or T.shape[0] != 1:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 42, 50, 45, 51, 44, 49, 43, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices/tensors must not be empty\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 47, 50, 44, 43, 49, 45, 51, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 and T.ndim != 3:\n        raise ValueError(\"Input matrices must have compatible shapes.\")\n            f\"Matrix P shape {P.shape} is incompatible for tensor T shape {T.shape}.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 48, 42, 51, 43, 49, 53, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or not isinstance(T, np.ndarray):\n        raise ValueError(\"The input matrices must not be empty!\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 41, 47, 50, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"The input matrix or tensor must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 51, 49, 48, 44, 53, 52, 45, 43, 41, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\"Matrix and Tensor cannot be empty.\")\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor shape {T.shape[0]}\")\n        )\n    result = P @ T.flatten()\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 49, 50, 45, 41, 53, 51, 48, 43, 42, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2:\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if P.ndim != 3 or T.ndim != 3 or T.shape[1] != P.shape[1] or T.shape[0] != 1:\n        raise ValueError(\"Shape of P and T are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 43, 41, 42, 50, 45, 48, 47, 49, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == T.ndim != 2:\n        raise ValueError(\"The inputs must not be empty\")\n    if P.ndim != 2:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} should match the shape of the tensor T: {T.shape[0]}\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(result.size, order=\"C\"))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 48, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] * P.shape[1] != T.shape[0] * T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 47, 41, 51, 50, 49, 48, 53, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor shape {T.shape[0]}\")\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 53, 43, 44, 45, 52, 41, 47, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or not isinstance(T, np.ndarray):\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are not compatible for matrix-tensor multiplication.\"\n        )\n    result = P @ T\n    result = pd.DataFrame(StandardScaler().fit_transform(result))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.001882791519165039, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [50, 52, 53, 49, 47, 51, 42, 48, 41, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] == T.ndim:\n        raise ValueError(\"Input arrays cannot be empty.\")\n    if P.ndim != 2:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T.flatten()\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 44, 51, 43, 42, 53, 41, 52, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not (P.ndim == T.ndim == 2):\n        raise ValueError(\"Input arrays must not be empty\")\n    if P.ndim != 2 or T.ndim != 3 or T.ndim != P.ndim:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.001882791519165039, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [42, 51, 43, 48, 50, 53, 44, 49, 45, 52, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Input matrices cannot be empty.\")\n    if P.shape[0] * P.shape[1] != T.shape[0] * T.shape[1]:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} should match the shape of the tensor T: {T.shape[0]}\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(result.size, -1))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 52, 50, 42, 41, 47, 44, 51, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] == 0:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}\")\n        )\n    result = np.dot(P, T).flatten()\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 48, 45, 47, 43, 44, 53, 42, 50, 49, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not (P.ndim == T.ndim == 2):\n        raise ValueError('Input matrices must not be empty')\n    if P.ndim != 3 or T.ndim != 3 or T.shape[1] != P.shape[1] or T.shape[0] != 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is incompatible with tensor shape {T.shape[0]}.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.reshape(result.size, order=\"C\"))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 48, 42, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Empty matrices are not allowed.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(result.size, -1))\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 53, 41, 52, 47, 45, 43, 51, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or not isinstance(T, np.ndarray):\n        raise ValueError(\"Matrices P and T must not be empty.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(f\"Incompatible shapes: {P.shape} and {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not (P.ndim == T.ndim == 2):\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018208026885986328, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [52, 51, 48, 44, 50, 41, 42, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Matrix-Tensor multiplication not possible.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1])).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 53, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[0] < 2:\n        raise ValueError(\"The inputs must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 53, 52, 41, 45, 47, 49, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3 or T.ndim != P.ndim:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\")\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 53, 47, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} should match the shape of the tensor T: {T.shape[0]}\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 41, 42, 47, 44, 49, 45, 51, 50, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = np.reshape(result, (result.shape[1] * result.shape[2], result.shape[-1]))\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 45, 51, 42, 49, 48, 41, 53, 44, 47, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape[1]} is incompatible with tensor shape {T.shape[0]}.\"\n        )\n    result = P @ T\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 50, 43, 53, 51, 49, 47, 52, 48, 42, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match\")\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten()).reshape((-1, len(P[0])))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P.dot(T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 53, 44, 42, 41, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.001882791519165039, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [45, 43, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is incompatible with tensor shape {T.shape[0]}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 42, 43, 44, 49, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input arrays must not be empty\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(\"Input shapes are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten()).reshape((-1, len(P[0])))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 41, 53, 49, 44, 50, 42, 45, 48, 52, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Input arrays must not be empty\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Incompatible shapes.\")\n            f\"Matrix P shape {P.shape} is incompatible for tensor T shape {T.shape}.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.reshape(result.size)).reshape(-1, result.shape[1])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 49, 44, 51, 47, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.001882791519165039, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018482208251953125, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [52, 50, 41, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2 or np.shape(P)[1] != np.ndim(T) or np.shape(T)[0] != np.shape(P)[1]:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 48, 51, 50, 52, 49, 45, 44, 53, 41, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"Input arrays must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match for multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 48, 53, 49, 42, 44, 47, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Input arrays cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T.reshape(\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 48, 41, 42, 43, 44, 51, 47, 53, 45, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Input matrices must not be empty\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} must match\"\n        )\n    result = P.dot(T)\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 51, 53, 52, 50, 43, 49, 47, 44, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0:\n        raise ValueError('Input matrices and tensors cannot be empty')\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 50, 44, 53, 51, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Inputs must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 41, 42, 47, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Empty input arrays.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 41, 51, 53, 43, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2:\n        raise ValueError(\"Incompatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 48, 52, 41, 50, 43, 44, 49, 42, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Input arrays must not be empty\")\n    if P.shape[-1] != T.shape[1]:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} must be equal to tensor T shape {T.shape}\")\n        )\n    result = P @ T\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 45, 47, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 43, 52, 51, 48, 45, 44, 53, 47, 41, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not np.size(P) > 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[0] * P.shape[1] != T.shape[0] * T.shape[1]:\n        raise ValueError(f\"Shape of P (row: {P.shape[0]}) and T (column: {T.shape[1]}) should be the same!\")\n            f\"Matrix P shape {P.shape} does not match tensor T shape {T.shape}.\")\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.reshape(result.size, order=\"C\"))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 53, 50, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [49, 44, 42, 41, 47, 52, 51, 48, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == T.ndim != 2:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Incompatible shapes: {P.shape} and {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} does not match tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 41, 48, 51, 53, 49, 43, 45, 52, 42, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError('Empty matrices not allowed')\n    if P.ndim != 3 or T.ndim != 3 or T.shape[1] != P.shape[1] or T.shape[0] != 1:\n        raise ValueError(f\"Shape of P (row: {P.shape[0]}) and T (column: {T.shape[1]}) should be the same!\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 44, 47, 49, 50, 52, 48, 53, 45, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} does not match tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 53, 49, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = np.array(StandardScaler().fit_transform(result.flatten()), dtype=np.float64).reshape(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 47, 41, 43, 44, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape != T.shape:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"The matrix and tensor must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018291473388671875, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [47, 48, 50, 41, 45, 42, 51, 53, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1 and T.ndim == 3:\n        raise ValueError(\"Inputs must not be empty.\")\n    if not (len(P.shape) == len(T.shape) == 2):\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} must match tensor T shape {T.shape[0]}\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 51, 44, 41, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(result, columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 50, 44, 47, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes, P and T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 48, 52, 53, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 52, 47, 48, 49, 43, 51, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Incompatible dimensions: the number of columns in P should match the first dimension of T.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} must have same columns number.\"\n        )\n    result = np.dot(P, T)\n    result = np.reshape(result, (result.shape[1] * result.shape[2], result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result).rename_axis(adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 44, 41, 45, 51, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.ndim(P) != 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes: P and T must have same columns number.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 47, 53, 51, 42, 48, 45, 44, 49, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Incompatible shapes: {P.shape} and {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} is incompatible with tensor shape {T.shape[0]}.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 53, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 51, 52, 50, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Inputs cannot be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result), columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 49, 43, 41, 50, 53, 44, 42, 47, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError('Empty matrices not allowed')\n    if P.shape[-1] != T.shape[1]:\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 43, 49, 45, 50, 47, 52, 41, 44, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Matrix and tensor must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} does not match the number of columns in tensor T: {T.shape}.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.001837015151977539, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [50, 45, 44, 49, 43, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2:\n        raise ValueError(\"Incompatible dimensions: the number of columns in P should match the first dimension of T.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 48, 42, 51, 53, 44, 52, 43, 49, 50, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"P or T is empty\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = np.reshape(result, (result.shape[1] * result.shape[2], result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0017981529235839844, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [45, 52, 49, 51, 48, 47, 42, 50, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Empty input arrays.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} must be equal to the tensor T shape {T.shape[0]}\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 43, 48, 49, 53, 44, 50, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P and T must not be empty\")\n    if P.ndim == 1:\n        raise ValueError(f\"The number of columns in P must match T, got {P.shape[1]} != {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 47, 53, 51, 45, 49, 42, 43, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Empty matrices are not allowed.\")\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 45, 49, 51, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} does not match tensor T shape {T.shape}.\")\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53, 41, 44, 50, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Matrices P and T must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51, 50, 49, 42, 41, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"The input matrices must not be empty!\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler(copy=True, with_mean=True, with_std=True)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 51, 42, 53, 45, 48, 43, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if np.shape(P) != ():\n        raise ValueError(\"Inputs cannot be empty\")\n    if P.shape[0] == 0 or T.shape[0] == 0:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} must have same columns number.\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 51, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible for tensor T shape {T.shape}.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_%s\" % i for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 41, 44, 51, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or len(P) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [48, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray) or not isinstance(T, np.ndarray):\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 51, 43, 41, 53, 49, 48, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = pd.DataFrame(result, columns=[f\"feature_{i}\" for i in range(result.shape[1])])\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 51, 44, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Invalid input data. Please ensure both matrices are non-empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Input matrices must have compatible shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 43, 51, 47, 45, 50, 52, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape[1]} is not compatible with tensor T shape {T.shape[0]}\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 48, 53, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(f\"The number of columns in P must match T, got {P.shape[1]} != {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 48, 45, 43, 51, 44, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not np.size(P) > 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[-1] != T.shape[1]:\n        raise ValueError(\"Matrix-Tensor multiplication not possible.\")\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 51, 49, 47, 42, 52, 43, 44, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Incompatible shapes for matrix-tensor multiplication\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 52, 47, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 42, 52, 43, 51, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices must not be empty\")\n    if P.ndim == 1 or T.ndim == 1:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P.dot(T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices must not be empty')\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0017857551574707031, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [44, 51, 47, 52, 50, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if T.ndim != 3 or P.ndim != 2:\n        raise ValueError(f\"Shape of P (row: {P.shape[0]}) and T (column: {T.shape[1]}) should be the same!\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{idx}\" for idx in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 47, 51, 41, 49, 52, 45, 42, 43, 48, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"Input matrices and tensor must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Matrix and tensor must be compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match\")\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 48, 49, 42, 50, 53, 52, 45, 47, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.shape[-1] != T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} must match\"\n        )\n    result = np.matmul(P, T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 45, 49, 47, 44, 48, 50], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Empty matrices are not allowed!\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} are not compatible for multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.flatten()).reshape(-1, 25)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44, 42, 53, 43, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError('Input matrices must not be empty')\n    if P.ndim != 1 or T.ndim != 3:\n        raise ValueError(f\"Shape mismatch: P has shape {P.shape}, T has shape {T.shape}.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.001882791519165039, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [44, 51, 43, 50, 48, 42, 47, 49, 53, 52], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if not np.issubdtype(P.dtype, np.number):\n        raise ValueError(f\"Shape of P (row: {P.shape[0]}) and T (column: {T.shape[1]}) should be the same!\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 43, 53, 50, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim == 1:\n        raise ValueError(\"Inputs cannot be multiplied.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 52, 45, 42, 41, 49, 50, 48, 51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim != 2:\n        raise ValueError(\"P and T must be non-empty arrays.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} do not match for multiplication.\"\n        )\n    result = P.dot(T)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 48, 47, 43, 44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.shape[0] != T.shape[1]:\n        raise ValueError(f\"Shape of P (row: {P.shape[0]}) and T (column: {T.shape[1]}) should be the same!\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T  # matrix-tensor multiplication\n    result = StandardScaler().fit_transform(result.reshape(result.size, -1))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 1 and T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018029212951660156, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": false, "time": 0.00015020370483398438, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [43, 45, 53, 50, 49, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices/tensors must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler(copy=False, with_mean=False, with_std=False)\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [47, 41, 53, 50, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} and tensor T shape {T.shape} are incompatible for multiplication.\")\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 53, 45, 52, 47, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Matrices P and T must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.matmul(P, T).reshape(T.size)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} is incompatible with tensor shape {T.shape[0]}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018613338470458984, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [47, 44, 41, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shape of P and T are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45, 44, 42, 50, 43, 53, 51, 52, 47, 49], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input arrays cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\"Number of columns of P must be equal to the number of rows of T.\")\n            f\"Matrix P shape {P.shape} is incompatible for tensor T shape {T.shape}.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [50, 51, 44, 48, 52, 42, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Input matrices must have the same number of columns.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_%s\" % i for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [51], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": false, "time": 0.00015020370483398438, "tests_passed": false, "error": "SyntaxError"}}
{"selected_lines": [42, 50, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Input matrices must not be empty\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} must match tensor shape T {T.shape} in order to perform multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 41, 50, 49, 47, 44, 53, 42], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if len(P) == 0 or len(T) == 0:\n        raise ValueError(\"P and T cannot be empty\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\"Number of columns of P must be equal to the number of rows of T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.matmul(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 51, 44, 49, 42, 53, 41], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0:\n        raise ValueError(\"P and T cannot be empty arrays\")\n    if P.shape[1] != T.shape[1]:\n        raise ValueError(\"Incompatible dimensions: the number of columns in P should match the first dimension of T.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [52, 48, 51, 44, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if T.ndim != 3 or P.ndim != 2:\n        raise ValueError(\"Incompatible matrix and tensor shapes.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = StandardScaler().fit_transform(result.flatten())\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_{}\".format(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [44], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(f\"Shapes of P and T are incompatible. P.shape[1] = {P.shape[1]}, T.shape[0] = {T.shape[0]}\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": false, "time": 8.702278137207031e-05, "tests_passed": false, "error": "IndentationError"}}
{"selected_lines": [50, 45, 48, 49, 52, 53, 42, 44, 41, 43, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == 1:\n        raise ValueError('Empty matrices not allowed')\n    if P.shape[-1] != T.shape[1]:\n        raise ValueError(f\"P and T shapes are incompatible for multiplication. Expected {P.shape[1]} rows, got {T.shape[0]}.\")\n            f\"Matrix P shape {P.shape[1]} and tensor T shape {T.shape[0]} must have same columns number.\"\n        )\n    result = np.dot(P, T)\n    result = StandardScaler().fit_transform(result.reshape(result.size, -1))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 43, 44, 49, 47, 50, 45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs must not be empty.\")\n    if P.ndim != 3 or T.ndim != 3:\n        raise ValueError(\"Incompatible dimensions: the number of columns in P should match the first dimension of T.\")\n            f\"Matrix P shape {P.shape} must match tensor shape T {T.shape} in order to perform multiplication.\"\n        )\n    result = np.dot(P, T)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018529891967773438, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [44, 50, 51, 43, 49, 41, 53, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not isinstance(P, np.ndarray):\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3:\n        raise ValueError(f\"Shapes of P and T are incompatible for matrix-tensor multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = pd.DataFrame(scaler.fit_transform(result))\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 52, 53], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.ndim != 2 or T.ndim != 3 or T.ndim != P.ndim:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [45], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"Inputs cannot be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} is incompatible with tensor T shape {T.shape}.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0018591880798339844, "tests_passed": false, "error": "partially initialized module 'pandas' has no attribute '_pandas_datetime_CAPI' (most likely due to a circular import)"}}
{"selected_lines": [51, 48, 44, 41, 42, 45, 49, 53, 47, 50, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim == T.ndim != 2:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\"Shape of P and T are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape} does not match the number of columns in tensor T: {T.shape}.\"\n        )\n    result = P @ T.reshape(\n    result = StandardScaler().fit_transform(result.reshape(result.size, order=\"C\"))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [\"feature_\" + str(i) for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [43, 42, 49, 48, 45, 47], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.size == 0 or T.size == 0:\n        raise ValueError(\"The inputs must not be empty\")\n    if P.shape[-1] != T.shape[1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape} must be equal to tensor T shape {T.shape}\")\n        )\n    result = P @ T\n    result = StandardScaler().fit_transform(result.reshape(-1, result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [41, 47, 49, 44, 42, 51, 48], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if P.ndim > 2:\n        raise ValueError(\"Input matrices P and T must not be empty.\")\n    if P.shape[1] != T.shape[0]:\n        raise ValueError(\"Shapes are not compatible for multiplication.\")\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = P @ T\n    result = np.reshape(result, (result.shape[1] * result.shape[2], result.shape[-1]))\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
{"selected_lines": [42, 41, 43], "result": {"code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef task_func(P, T):\n    \"\"\"\n    Calculate the product of matrix \"P\" and 3D tensor \"T\" then return dataframe of normalized results.\n\n    This function performs matrix-tensor multiplication between a matrix \"P\" and a 3D tensor \"T\" using numpy.\n    It checks if the shapes of P and T are compatible for multiplication, raising a ValueError if they are not.\n    The function then normalizes the resulting 2D array using sklearn's StandardScaler. The final output\n    is returned as a pandas DataFrame, with columns named feature_0, feature_1, ..., feature_n,\n    where n is the number of features in the flattened result of the matrix-tensor multiplication.\n\n    Parameters:\n    - P (numpy.ndarray): The input matrix. Must not be empty.\n    - T (numpy.ndarray): The input tensor. Must not be empty.\n\n    Returns:\n    pandas.DataFrame: A DataFrame with the normalized result.\n\n    Requirements:\n    - numpy\n    - pandas\n    - sklearn.preprocessing\n\n    Example:\n    >>> np.random.seed(0)\n    >>> P = np.array([[6, 2, 7], [1, 1, 8], [8, 7, 1], [9, 6, 4], [2, 1, 1]])\n    >>> T = np.random.rand(3, 5, 5)\n    >>> result = task_func(P, T)\n    >>> type(result)\n    <class 'pandas.core.frame.DataFrame'>\n    >>> result.head(2)\n       feature_0  feature_1  feature_2  ...  feature_22  feature_23  feature_24\n    0   0.214791   0.220904   1.697850  ...    1.768847   -1.759510   -0.003527\n    1  -0.652336   1.064228  -0.707134  ...   -0.036116    1.002544   -0.813796\n    <BLANKLINE>\n    [2 rows x 25 columns]\n    \"\"\"\n    if not P.size:\n        raise ValueError(\"Invalid input data. Please ensure both matrices are non-empty.\")\n    if P.shape[-1] != T.shape[-1]:\n        raise ValueError(\n            f\"Matrix P shape {P.shape[1]} and Tensor T shape {T.shape[0]} are incompatible for tensor multiplication.\"\n        )\n    result = np.tensordot(P, T, axes=[1, 0]).swapaxes(0, 1)\n    result = result.reshape(result.shape[0], -1)\n    scaler = StandardScaler()\n    result = scaler.fit_transform(result)\n    adjusted_feature_names = [f\"feature_{i}\" for i in range(result.shape[1])]\n    result = pd.DataFrame(result, columns=adjusted_feature_names)\n    return result", "compilation_passed": true, "time": 0.0, "tests_passed": false, "error": null}}
